<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","benches","draw_benchmarks.rs"],"content":"use std::time::Duration;\n\nuse criterion::{\n    black_box,\n    criterion_group,\n    criterion_main,\n    Criterion,\n};\nuse metro_map_editor::{\n    algorithm::drawing::{\n        draw_edge,\n        CanvasContext,\n    },\n    models::{\n        GridNode,\n        Map,\n    },\n    utils::graphml,\n    CanvasState,\n};\n\nfn draw_edge_benchmark(c: \u0026mut Criterion) {\n    let context = CanvasContext::new();\n    let mut state = CanvasState::default();\n    state.set_square_size(5);\n    state.set_size((50, 50));\n    let from = GridNode::from((0, 0));\n    let to = GridNode::from((8, 8));\n    let steps = vec![\n        GridNode::from((1, 1)),\n        GridNode::from((2, 2)),\n        GridNode::from((3, 3)),\n        GridNode::from((4, 4)),\n        GridNode::from((5, 5)),\n        GridNode::from((6, 6)),\n        GridNode::from((7, 7)),\n        GridNode::from((8, 8)),\n        GridNode::from((9, 9)),\n        GridNode::from((10, 10)),\n        GridNode::from((11, 11)),\n        GridNode::from((11, 12)),\n        GridNode::from((11, 13)),\n        GridNode::from((11, 12)),\n        GridNode::from((11, 11)),\n        GridNode::from((10, 10)),\n        GridNode::from((9, 9)),\n    ];\n\n    c.bench_function(\"draw_edge\", |b| {\n        b.iter(|| {\n            draw_edge(\n                black_box(from),\n                black_box(to),\n                black_box(\u0026steps),\n                black_box(\u0026context),\n                black_box(state),\n                black_box(1.0),\n            )\n        })\n    });\n}\n\nfn draw_map_benchmark(c: \u0026mut Criterion) {\n    let context = CanvasContext::new();\n    let mut canvas = CanvasState::new();\n    canvas.set_square_size(7);\n    canvas.set_size((700, 1500)); // Without enlarging the canvas, some stations will overlap due to map size\n\n    let test_file_content = std::fs::read_to_string(\"existing_maps/berlin.graphml\")\n        .expect(\"test data file does not exist\");\n    let map = graphml::decode_map(\u0026test_file_content, canvas).expect(\"failed to decode graphml\");\n\n    c.bench_function(\"draw_map\", |b| {\n        b.iter(|| {\n            Map::draw(\n                black_box(\u0026map),\n                black_box(\u0026context),\n                black_box(canvas),\n            )\n        })\n    });\n}\n\ncriterion_group!(\n    name = drawing_benches;\n    config = Criterion::default().measurement_time(Duration::from_secs(10));\n    targets = draw_edge_benchmark,draw_map_benchmark\n);\ncriterion_main!(drawing_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","benches","map_algo_benchmarks.rs"],"content":"use std::time::Duration;\n\nuse criterion::{\n    black_box,\n    criterion_group,\n    criterion_main,\n    Criterion,\n};\nuse metro_map_editor::{\n    algorithm::{\n        recalculate_map,\n        run_a_star,\n    },\n    models::GridNode,\n    utils::{\n        graphml,\n        json,\n    },\n    CanvasState,\n    MapState,\n};\n\npub fn a_star_benchmark(c: \u0026mut Criterion) {\n    let from = GridNode::from((0, 0));\n    let to = GridNode::from((10, 15));\n\n    c.bench_function(\"a_star\", |b| {\n        b.iter(|| run_a_star(black_box(from), black_box(to)))\n    });\n}\n\npub fn full_recalculation_simple_benchmark(c: \u0026mut Criterion) {\n    let mut canvas = CanvasState::new();\n    canvas.set_square_size(5);\n\n    let test_file_content = std::fs::read_to_string(\"existing_maps/routing_test.json\")\n        .expect(\"test data file does not exist\");\n    let map = json::decode_map(\u0026test_file_content, canvas).expect(\"failed to decode json\");\n\n    let mut state = MapState::new(map.clone());\n    state.calculate_algorithm_settings();\n    let settings = state.get_algorithm_settings();\n\n    c.bench_function(\"full_recalculation_simple\", |b| {\n        b.iter(|| {\n            let mut map = map.clone();\n            recalculate_map(black_box(settings), black_box(\u0026mut map))\n        })\n    });\n}\n\n// TODO: change back to berlin\npub fn full_recalculation_karlsruhe_benchmark(c: \u0026mut Criterion) {\n    let mut canvas = CanvasState::new();\n    canvas.set_square_size(7);\n    canvas.set_size((700, 1600)); // Without enlarging the canvas, some stations will overlap due to map size\n\n    let test_file_content = std::fs::read_to_string(\"existing_maps/karlsruhe.graphml\")\n        .expect(\"test data file does not exist\");\n    let map = graphml::decode_map(\u0026test_file_content, canvas).expect(\"failed to decode graphml\");\n\n    let mut state = MapState::new(map.clone());\n    state.calculate_algorithm_settings();\n    let settings = state.get_algorithm_settings();\n\n    c.bench_function(\"full_recalculation_karlsruhe\", |b| {\n        b.iter(|| {\n            let mut map = map.clone();\n            recalculate_map(black_box(settings), black_box(\u0026mut map))\n                .expect(\"failed to recalculate map\")\n        })\n    });\n}\n\ncriterion_group!(\n    name = full_recalculation_benches;\n    config = Criterion::default().measurement_time(Duration::from_secs(60)).sample_size(20);\n    targets = full_recalculation_simple_benchmark, full_recalculation_karlsruhe_benchmark\n);\ncriterion_group!(a_star_benches, a_star_benchmark);\ncriterion_main!(\n    a_star_benches,\n    full_recalculation_benches\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","a_star.rs"],"content":"//! Contains the A* algorithm implementation for quick and temporary path\n//! calculations.\n\nuse std::{\n    cmp::Ordering,\n    collections::BinaryHeap,\n};\n\nuse crate::models::GridNode;\n\n/// Holds the state for an item in the A* algorithm queue.\n#[derive(Clone)]\nstruct AStarState {\n    /// The cost the current path.\n    cost: f64,\n    /// The current node.\n    node: GridNode,\n    /// The length of the path so far.\n    path_length: f64,\n    /// The parent state of the current state.\n    parent: Option\u003cBox\u003cAStarState\u003e\u003e,\n}\n\nimpl AStarState {\n    /// Get the path that led to this state.\n    ///\n    /// Note: This method excludes the starting node of the path and the node of\n    /// the current state.\n    fn to_path(\u0026self) -\u003e Vec\u003cGridNode\u003e {\n        let mut path = Vec::new();\n\n        let mut current = Box::new(self.clone());\n        while let Some(state) = current.parent {\n            path.push(state.node);\n            current = state;\n        }\n\n        path.into_iter()\n            .rev()\n            .skip(1)\n            .collect()\n    }\n}\n\n// The priority queue depends on [`Ord`].\n// This implement the trait so the queue becomes a min-heap\n// instead of a max-heap, as a min-heap is needed for A*.\nimpl Ord for AStarState {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        other\n            .cost\n            .total_cmp(\u0026self.cost)\n            .then_with(|| {\n                other\n                    .path_length\n                    .total_cmp(\u0026self.path_length)\n            })\n    }\n}\n\n// [`PartialOrd`] needs to be implemented as well, as [`Ord`] requires it.\nimpl PartialOrd for AStarState {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\n// They should be equal if their nodes are equal, as they then represent the\n// same node.\nimpl PartialEq for AStarState {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.node == other.node\n    }\n}\n\n// [`Eq`] needs to be implemented as well, as [`Ord`] requires it.\nimpl Eq for AStarState {}\n\n/// Run the A* algorithm to get the shortest path from the given from node to\n/// the given to node.\npub fn run_a_star(from: GridNode, to: GridNode) -\u003e Vec\u003cGridNode\u003e {\n    let mut heap = BinaryHeap::with_capacity(from.diagonal_distance_to(to) as usize * 8);\n\n    let init = AStarState {\n        cost: 0.0,\n        path_length: 0.0,\n        node: from,\n        parent: None,\n    };\n    let mut last = init.clone();\n    heap.push(init);\n\n    while let Some(\n        current @ AStarState {\n            node,\n            path_length,\n            ..\n        },\n    ) = heap.pop()\n    {\n        if node == to {\n            last = current;\n            break;\n        }\n\n        last = current.clone();\n        for neighbor in node.get_neighbors() {\n            let next = AStarState {\n                path_length: path_length + 1.0,\n                cost: path_length + neighbor.diagonal_distance_to(to),\n                node: neighbor,\n                parent: Some(Box::new(current.clone())),\n            };\n\n            heap.push(next);\n        }\n    }\n\n    last.to_path()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_to_path() {\n        let states = AStarState {\n            path_length: 3.0,\n            cost: 0.0,\n            node: (3, 3).into(),\n            parent: Some(Box::new(AStarState {\n                cost: 0.0,\n                node: (2, 2).into(),\n                path_length: 2.0,\n                parent: Some(Box::new(AStarState {\n                    cost: 0.0,\n                    node: (1, 1).into(),\n                    path_length: 1.0,\n                    parent: Some(Box::new(AStarState {\n                        cost: 0.0,\n                        node: (0, 0).into(),\n                        path_length: 0.0,\n                        parent: None,\n                    })),\n                })),\n            })),\n        };\n\n        let path = states.to_path();\n\n        let expected = vec![(1, 1), (2, 2)];\n\n        assert_eq!(path, expected);\n    }\n\n    #[test]\n    fn test_a_star() {\n        // down\n        assert_eq!(\n            run_a_star((1, 1).into(), (1, 5).into()),\n            vec![(1, 2), (1, 3), (1, 4)]\n        );\n\n        // down diag left\n        assert_eq!(\n            run_a_star((5, 1).into(), (1, 5).into()),\n            vec![(4, 2), (3, 3), (2, 4)]\n        );\n\n        // left\n        assert_eq!(\n            run_a_star((5, 1).into(), (1, 1).into()),\n            vec![(4, 1), (3, 1), (2, 1)]\n        );\n\n        // up diag left\n        assert_eq!(\n            run_a_star((5, 5).into(), (1, 1).into()),\n            vec![(4, 4), (3, 3), (2, 2)]\n        );\n\n        // up\n        assert_eq!(\n            run_a_star((1, 5).into(), (1, 1).into()),\n            vec![(1, 4), (1, 3), (1, 2)]\n        );\n\n        // up diag right\n        assert_eq!(\n            run_a_star((1, 5).into(), (5, 1).into()),\n            vec![(2, 4), (3, 3), (4, 2)]\n        );\n\n        // right\n        assert_eq!(\n            run_a_star((1, 1).into(), (5, 1).into()),\n            vec![(2, 1), (3, 1), (4, 1)]\n        );\n\n        // down diag right\n        assert_eq!(\n            run_a_star((1, 1).into(), (5, 5).into()),\n            vec![(2, 2), (3, 3), (4, 4)]\n        );\n\n        // long with corner\n        assert_eq!(\n            run_a_star((1, 1).into(), (10, 5).into()),\n            vec![\n                (2, 2),\n                (3, 3),\n                (4, 4),\n                (5, 5),\n                (6, 5),\n                (7, 5),\n                (8, 5),\n                (9, 5)\n            ]\n        );\n    }\n}\n","traces":[{"line":29,"address":[8478839,8478629,8477856],"length":1,"stats":{"Line":1}},{"line":30,"address":[8477886],"length":1,"stats":{"Line":1}},{"line":32,"address":[8477942,8478154],"length":1,"stats":{"Line":2}},{"line":33,"address":[8478304,8478346,8478566,8478167],"length":1,"stats":{"Line":3}},{"line":34,"address":[8478372,8478316],"length":1,"stats":{"Line":2}},{"line":35,"address":[8478461],"length":1,"stats":{"Line":1}},{"line":38,"address":[8478235,8478660],"length":1,"stats":{"Line":2}},{"line":49,"address":[8478880],"length":1,"stats":{"Line":1}},{"line":50,"address":[8478915],"length":1,"stats":{"Line":1}},{"line":53,"address":[8894288],"length":1,"stats":{"Line":1}},{"line":54,"address":[8894320,8894302],"length":1,"stats":{"Line":2}},{"line":56,"address":[8894311],"length":1,"stats":{"Line":1}},{"line":63,"address":[8478944],"length":1,"stats":{"Line":1}},{"line":64,"address":[8478958],"length":1,"stats":{"Line":1}},{"line":71,"address":[8478992],"length":1,"stats":{"Line":0}},{"line":72,"address":[8479006],"length":1,"stats":{"Line":0}},{"line":81,"address":[8480662,8479040,8481004],"length":1,"stats":{"Line":1}},{"line":82,"address":[8479358,8479101],"length":1,"stats":{"Line":1}},{"line":90,"address":[8479351],"length":1,"stats":{"Line":1}},{"line":91,"address":[8479520,8479415],"length":1,"stats":{"Line":2}},{"line":93,"address":[9474941,9474177],"length":1,"stats":{"Line":2}},{"line":94,"address":[8479617],"length":1,"stats":{"Line":1}},{"line":95,"address":[9474188],"length":1,"stats":{"Line":1}},{"line":96,"address":[8479593],"length":1,"stats":{"Line":1}},{"line":99,"address":[9474162],"length":1,"stats":{"Line":1}},{"line":101,"address":[8479754,8479678],"length":1,"stats":{"Line":2}},{"line":102,"address":[8479783,8480671],"length":1,"stats":{"Line":1}},{"line":106,"address":[8479845,8479776],"length":1,"stats":{"Line":2}},{"line":107,"address":[8479987,8480240,8480202],"length":1,"stats":{"Line":3}},{"line":109,"address":[8480284],"length":1,"stats":{"Line":1}},{"line":110,"address":[8480371,8480294],"length":1,"stats":{"Line":2}},{"line":112,"address":[8480397,8480577],"length":1,"stats":{"Line":2}},{"line":115,"address":[8480633],"length":1,"stats":{"Line":1}},{"line":119,"address":[8480892],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":34},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","cost_calculation.rs"],"content":"//! Contains everything to calculate the cost of a node in the algorithm based\n//! on the previous nodes in its path.\n\nuse core::f64;\n\nuse super::{\n    calculate_angle,\n    debug_print,\n    node_outside_grid,\n    occupation::OccupiedNodes,\n    overlap_amount,\n    AlgorithmSettings,\n};\nuse crate::{\n    models::{\n        Edge,\n        EdgeID,\n        GridNode,\n        Map,\n        Station,\n    },\n    utils::Result,\n    Error,\n};\n\n/// Check if the station can be approached from the given node.\n/// Considers if the approach leaves enough open nodes on all sides for future\n/// connections on those sides.\nfn station_approach_available(\n    settings: AlgorithmSettings,\n    map: \u0026Map,\n    station: \u0026Station,\n    node: GridNode,\n    incoming_edge: EdgeID,\n) -\u003e Result\u003cbool\u003e {\n    let neighbor_nodes = station\n        .get_pos()\n        .get_neighbors();\n    let mut left_wards = Vec::new();\n    let mut right_wards = Vec::new();\n\n    // Get 2 lists of all edges connected to the station together with the angle\n    // with which they are connected to it. 1 rightwards and the other\n    // leftwards.\n    for edge_id in station.get_edges() {\n        if *edge_id == incoming_edge {\n            continue;\n        }\n\n        let edge = map\n            .get_edge(*edge_id)\n            .ok_or(Error::other(\n                \"edge connected to station not found\",\n            ))?;\n\n        for edge_node in edge.get_nodes() {\n            if neighbor_nodes.contains(edge_node) {\n                left_wards.push((\n                    edge.clone(),\n                    calculate_angle(node, station.get_pos(), *edge_node),\n                ));\n\n                right_wards.push((\n                    edge.clone(),\n                    (calculate_angle(node, station.get_pos(), *edge_node) - 360.0).abs(),\n                ));\n            }\n        }\n    }\n\n    // Sort the lists by angle, so we can check the edges in order of angle small to\n    // large.\n    left_wards.sort_by(|a, b| {\n        a.1.partial_cmp(\u0026b.1)\n            .unwrap()\n    });\n    right_wards.sort_by(|a, b| {\n        a.1.partial_cmp(\u0026b.1)\n            .unwrap()\n    });\n\n    let mut cost = 0;\n\n    let possible_angle = move |angle, cost| {\n        match angle {\n            315.0 =\u003e cost \u003c 7,\n            270.0 =\u003e cost \u003c 6,\n            225.0 =\u003e cost \u003c 5,\n            180.0 =\u003e cost \u003c 4,\n            135.0 =\u003e cost \u003c 3,\n            90.0 =\u003e cost \u003c 2,\n            45.0 =\u003e cost \u003c 1,\n            0.0 =\u003e false,\n            _ =\u003e panic!(\"found impossible angle of {angle}\"),\n        }\n    };\n\n    // For both the right and leftwards edges, we check if the angle between the\n    // incoming edge and the other edges already settled leaves enough room for the\n    // edges that still need to be settled.\n    for (edge, angle) in left_wards {\n        if edge.is_settled() {\n            if !possible_angle(angle, cost) {\n                debug_print(\n                    settings,\n                    \u0026format!(\n                        \"station approach to {}{} not available from {node}\\nsettled edge {} from {}\n                at angle {angle} with {cost} edges between.\",\n                        station.get_id(),\n                        station.get_pos(),\n                        edge.get_id(),\n                        edge.opposite(station.get_id())\n                            .unwrap(),\n                    ),\n                    true,\n                );\n                return Ok(false);\n            }\n            break;\n        }\n\n        cost += 1;\n    }\n\n    cost = 0;\n    for (edge, angle) in right_wards {\n        if edge.is_settled() {\n            if !possible_angle(angle, cost) {\n                debug_print(\n                    settings,\n                    \u0026format!(\n                        \"station approach to {}{} not available from {}\\nsettled edge {} from {}\n                at angle {} with {} edges between.\",\n                        station.get_id(),\n                        station.get_pos(),\n                        node,\n                        edge.get_id(),\n                        edge.opposite(station.get_id())\n                            .unwrap(),\n                        angle,\n                        cost\n                    ),\n                    true,\n                );\n                return Ok(false);\n            }\n            break;\n        }\n\n        cost += 1;\n    }\n\n    Ok(true)\n}\n\n/// Match the given angle to the cost of a bend of that angle\n#[inline]\nfn match_angle_cost(angle: f64) -\u003e Result\u003cf64\u003e {\n    Ok(match angle {\n        360.0 =\u003e f64::INFINITY,\n        315.0 =\u003e 5.0,\n        270.0 =\u003e 2.5,\n        225.0 =\u003e 0.5,\n        180.0 =\u003e 0.0,\n        135.0 =\u003e 0.5,\n        90.0 =\u003e 2.5,\n        45.0 =\u003e 5.0,\n        0.0 =\u003e f64::INFINITY,\n        _ =\u003e {\n            Err(Error::other(format!(\n                \"found impossible angle of {angle}\"\n            )))?\n        },\n    })\n}\n\n/// Calculate the cost of the angle between three nodes.\n/// The second point is assumed to be the middle node where the angle is\n/// located.\nfn calc_angle_cost(first: GridNode, second: GridNode, third: GridNode) -\u003e Result\u003cf64\u003e {\n    let angle = calculate_angle(first, second, third);\n\n    match_angle_cost(angle).map_err(|_| {\n        Error::other(format!(\n            \"found invalid angle of {angle} between {first}, {second}, {third}\",\n        ))\n    })\n}\n\n/// Returns if the diagonal squared described by the given two nodes is already\n/// occupied by an edge.\nfn diagonal_occupied(\n    map: \u0026Map,\n    first: GridNode,\n    second: GridNode,\n    occupied: \u0026OccupiedNodes,\n) -\u003e bool {\n    if let Some(diag_one) = occupied.get(\u0026GridNode::from((first.0, second.1))) {\n        if let Some(diag_two) = occupied.get(\u0026GridNode::from((second.0, first.1))) {\n            // if both diagonal nodes are occupied by same edge, the diagonal is occupied.\n            if diag_one == diag_two {\n                return true;\n            }\n\n            // if one of the diagonal nodes is a station, we check if the edge on the other\n            // diagonal node is connected to it, if so, the diagonal is occupied.\n            if let Some(station_id) = diag_one.get_station_id() {\n                return map\n                    .get_station(station_id)\n                    .zip(diag_two.get_edge_id())\n                    .map_or(false, |(s, edge_id)| {\n                        s.get_edges()\n                            .contains(\u0026edge_id)\n                    });\n            }\n\n            if let Some(station_id) = diag_two.get_station_id() {\n                return map\n                    .get_station(station_id)\n                    .zip(diag_one.get_edge_id())\n                    .map_or(false, |(s, edge_id)| {\n                        s.get_edges()\n                            .contains(\u0026edge_id)\n                    });\n            }\n        }\n    }\n    false\n}\n\n/// Calculate the cost of the node attached to the given station on the path\n/// going away from the station.\n///\n/// note: the angle cost is halved here to make it have a preference, but not\n/// have it force a double bend later on to compensate.\nfn calc_station_exit_cost(\n    map: \u0026Map,\n    current_edge: \u0026Edge,\n    station: \u0026Station,\n    node: GridNode,\n    previous_node: GridNode,\n    target_node: GridNode,\n) -\u003e Result\u003cf64\u003e {\n    if !station.is_settled()\n        || station\n            .get_edges()\n            .len()\n            == 1\n    {\n        return match_angle_cost(\n            (calculate_angle(previous_node, node, target_node) / 45.0).round() * 45.0,\n        )\n        .map(|c| c / 2.0);\n    }\n\n    let mut biggest_overlap = None;\n    let mut current = 0;\n\n    // find the edge with the most overlap in lines with the current edge, this is\n    // the opposite edge from our edge that's leaving the station.\n    for edge_id in station.get_edges() {\n        if *edge_id == current_edge.get_id() {\n            continue;\n        }\n\n        let edge = map\n            .get_edge(*edge_id)\n            .ok_or(Error::other(\n                \"edge connected to station not found\",\n            ))?;\n\n        let overlap = overlap_amount(\n            edge.get_lines(),\n            current_edge.get_lines(),\n        );\n        if overlap \u003e current {\n            biggest_overlap = Some(edge);\n            current = overlap;\n        }\n    }\n\n    // if we found an opposite edge, we can calculate the cost of the angle between\n    // the station and the node of the station.\n    if let Some(mut opposite_edge) = biggest_overlap.cloned() {\n        let neighbor_nodes = station\n            .get_pos()\n            .get_neighbors();\n\n        // If the station has been settled and moved, but the opposite edge might not\n        // have been settled, then there is likely a gap in the edge to the station and\n        // thus we need to recalculate the nodes in the edge to get a correct bordering\n        // edge.\n        if station.is_settled()\n            \u0026\u0026 !opposite_edge.is_settled()\n            \u0026\u0026 station.get_pos() != station.get_original_pos()\n        {\n            opposite_edge.calculate_nodes(map);\n        }\n\n        // If the ends of the opposite edge are in the neighbors of the station, we\n        // calculate the angle with that node.\n        for edge_node in opposite_edge.get_edge_ends() {\n            if neighbor_nodes.contains(\u0026edge_node) {\n                return calc_angle_cost(edge_node, station.get_pos(), node).map(|c| c / 2.0);\n            }\n        }\n\n        // Else we calculate the angle with the opposite station, this should only occur\n        // when the list of nodes in the edge is empty.\n        if let Some(opp_station_id) = opposite_edge.opposite(station.get_id()) {\n            if let Some(opp_station) = map.get_station(opp_station_id) {\n                // If the opposite edge is not\n                return calc_angle_cost(\n                    opp_station.get_pos(),\n                    station.get_pos(),\n                    node,\n                )\n                .map(|c| c / 2.0);\n            }\n        }\n    }\n\n    // If we didn't find an opposite edge, we can't calculate the angle and thus\n    // every exit angle is equally good and might as well be free.\n    Ok(0.0)\n}\n\n/// Calculate the cost of the node on the path between two stations.\n/// The cost is dependent on the angle between the previous two nodes and if the\n/// node is exiting or approaching a station. It also validates if the node can\n/// be used for a path, and else giving a cost of infinity.\n/// This is the Calculate Node Cost function from the paper.\npub fn calc_node_cost(\n    settings: AlgorithmSettings,\n    map: \u0026Map,\n    edge: \u0026Edge,\n    node: GridNode,\n    previous: \u0026[GridNode],\n    from_station: \u0026Station,\n    to_station: \u0026Station,\n    occupied: \u0026OccupiedNodes,\n) -\u003e Result\u003cf64\u003e {\n    if node_outside_grid(settings, node) {\n        return Ok(f64::INFINITY);\n    }\n\n    if to_station.is_settled() \u0026\u0026 node == to_station.get_pos() {\n        if !station_approach_available(\n            settings,\n            map,\n            to_station,\n            *previous\n                .last()\n                .unwrap(),\n            edge.get_id(),\n        )? {\n            return Ok(f64::INFINITY);\n        }\n    } else if occupied.contains_key(\u0026node) {\n        return Ok(f64::INFINITY);\n    }\n\n    if previous.len() \u003c 2 {\n        if previous[0].0 - node.0 != 0\n            \u0026\u0026 previous[0].1 - node.1 != 0\n            \u0026\u0026 diagonal_occupied(map, previous[0], node, occupied)\n        {\n            return Ok(f64::INFINITY);\n        }\n\n        return calc_station_exit_cost(\n            map,\n            edge,\n            from_station,\n            node,\n            previous[0],\n            to_station.get_pos(),\n        ) // cost of exiting station\n        .map(|c| c + settings.move_cost); // standard cost of a move\n    }\n\n    if previous[1].0 - node.0 != 0\n        \u0026\u0026 previous[1].1 - node.1 != 0\n        \u0026\u0026 diagonal_occupied(map, previous[1], node, occupied)\n    {\n        return Ok(f64::INFINITY);\n    }\n\n    calc_angle_cost(previous[0], previous[1], node) // cost of angle between previous nodes\n        .map(|c| c + settings.move_cost) // standard cost of a move\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_station_approach_available() {\n        let mut map = Map::new();\n\n        let mut approach_target = Station::new(GridNode::from((5, 5)), None);\n        map.add_station(approach_target.clone());\n\n        let above = Station::new(GridNode::from((5, 0)), None);\n        let top_right = Station::new(GridNode::from((10, 0)), None);\n        let top_right_2 = Station::new(GridNode::from((15, -5)), None);\n        let right = Station::new(GridNode::from((10, 5)), None);\n        let bottom = Station::new(GridNode::from((5, 10)), None);\n        let left = Station::new(GridNode::from((0, 5)), None);\n        let top_left = Station::new(GridNode::from((0, 0)), None);\n        let top_left_2 = Station::new(GridNode::from((-5, -5)), None);\n\n        map.add_station(above.clone());\n        println!(\"above: {:?}\", above.get_id());\n        map.add_station(top_right.clone());\n        println!(\"top_right: {:?}\", top_right.get_id());\n        map.add_station(right.clone());\n        println!(\"right: {:?}\", right.get_id());\n        map.add_station(bottom.clone());\n        println!(\"bottom: {:?}\", bottom.get_id());\n        map.add_station(left.clone());\n        println!(\"left: {:?}\", left.get_id());\n        map.add_station(top_left.clone());\n        println!(\"top_left: {:?}\", top_left.get_id());\n\n        let mut edge_above = Edge::new(\n            above.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n        edge_above.settle();\n\n        let mut edge_bottom = Edge::new(\n            bottom.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n        edge_bottom.settle();\n\n        let edge_top_right = Edge::new(\n            top_right.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n        let edge_top_right_2 = Edge::new(\n            top_right_2.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n\n        let edge_right = Edge::new(\n            right.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n\n        let edge_left = Edge::new(\n            left.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n        let edge_top_left = Edge::new(\n            top_left.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n        let edge_top_left_2 = Edge::new(\n            top_left_2.get_id(),\n            approach_target.get_id(),\n            None,\n        );\n\n        map.add_edge(edge_above.clone());\n        println!(\"edge_above: {:?}\", edge_above.get_id());\n        map.add_edge(edge_top_right.clone());\n        println!(\n            \"edge_top_right: {:?}\",\n            edge_top_right.get_id()\n        );\n        map.add_edge(edge_right.clone());\n        println!(\"edge_right: {:?}\", edge_right.get_id());\n        map.add_edge(edge_bottom.clone());\n        println!(\n            \"edge_bottom: {:?}\",\n            edge_bottom.get_id()\n        );\n        map.add_edge(edge_left.clone());\n        println!(\"edge_left: {:?}\", edge_left.get_id());\n        map.add_edge(edge_top_left.clone());\n        println!(\n            \"edge_top_left: {:?}\",\n            edge_top_left.get_id()\n        );\n\n        map.quickcalc_edges();\n\n        let mut incoming_node = GridNode::from((6, 5));\n\n        approach_target = map\n            .get_station(approach_target.get_id())\n            .cloned()\n            .unwrap();\n\n        let pos_result_1 = station_approach_available(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026approach_target,\n            incoming_node,\n            edge_right.get_id(),\n        )\n        .unwrap();\n        assert!(pos_result_1);\n\n        map.add_station(top_right_2.clone());\n        map.add_edge(edge_top_right_2.clone());\n        map.quickcalc_edges();\n        approach_target = map\n            .get_station(approach_target.get_id())\n            .cloned()\n            .unwrap();\n\n        let neg_result = station_approach_available(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026approach_target,\n            incoming_node,\n            edge_right.get_id(),\n        )\n        .unwrap();\n        assert!(!neg_result);\n\n        incoming_node = GridNode::from((6, 6));\n        let pos_result_2 = station_approach_available(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026approach_target,\n            incoming_node,\n            edge_right.get_id(),\n        )\n        .unwrap();\n        assert!(pos_result_2);\n\n        // mirrored\n\n        incoming_node = GridNode::from((4, 5));\n        let mirrored_pos_result_1 = station_approach_available(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026approach_target,\n            incoming_node,\n            edge_left.get_id(),\n        )\n        .unwrap();\n        assert!(mirrored_pos_result_1);\n\n        map.add_station(top_left_2.clone());\n        map.add_edge(edge_top_left_2.clone());\n        map.quickcalc_edges();\n        approach_target = map\n            .get_station(approach_target.get_id())\n            .cloned()\n            .unwrap();\n\n        let mirrored_neg_result = station_approach_available(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026approach_target,\n            incoming_node,\n            edge_left.get_id(),\n        )\n        .unwrap();\n        assert!(!mirrored_neg_result);\n\n        incoming_node = GridNode::from((4, 6));\n        let mirrored_pos_result_2 = station_approach_available(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026approach_target,\n            incoming_node,\n            edge_left.get_id(),\n        )\n        .unwrap();\n        assert!(mirrored_pos_result_2);\n    }\n\n    #[test]\n    fn test_calc_angle_cost() {\n        let first_180 = GridNode::from((0, 2));\n        let second_180 = GridNode::from((1, 1));\n        let third_180 = GridNode::from((2, 0));\n        let result_180 = calc_angle_cost(first_180, second_180, third_180);\n        assert_eq!(result_180, Ok(0.0));\n\n        let first_135 = GridNode::from((2, 2));\n        let second_135 = GridNode::from((1, 1));\n        let third_135 = GridNode::from((1, 0));\n        let result_135 = calc_angle_cost(first_135, second_135, third_135);\n        assert_eq!(result_135, Ok(0.5));\n\n        let first_90 = GridNode::from((0, 0));\n        let second_90 = GridNode::from((1, 1));\n        let third_90 = GridNode::from((2, 0));\n        let result_90 = calc_angle_cost(first_90, second_90, third_90);\n        assert_eq!(result_90, Ok(2.5));\n\n        let first_45 = GridNode::from((1, 0));\n        let second_45 = GridNode::from((1, 1));\n        let third_45 = GridNode::from((2, 0));\n        let result_45 = calc_angle_cost(first_45, second_45, third_45);\n        assert_eq!(result_45, Ok(5.0));\n    }\n\n    #[test]\n    fn test_diagonal_occupied() {\n        let mut map = Map::new();\n        let mut occupied = OccupiedNodes::new();\n\n        let top_left = GridNode::from((0, 0));\n        let top_right = GridNode::from((1, 0));\n        let bottom_left = GridNode::from((0, 1));\n        let bottom_right = GridNode::from((1, 1));\n\n        let edge = Edge::new(0.into(), 1.into(), None);\n        let edge_id = edge.get_id();\n        let mut station = Station::new(GridNode::from((0, 0)), None);\n        let station_id = station.get_id();\n        station.add_edge(edge_id);\n        map.add_station(station);\n\n        assert!(!diagonal_occupied(\n            \u0026map,\n            bottom_left,\n            top_right,\n            \u0026occupied\n        ));\n        assert!(!diagonal_occupied(\n            \u0026map,\n            top_left,\n            bottom_right,\n            \u0026occupied\n        ));\n        assert!(!diagonal_occupied(\n            \u0026map,\n            bottom_right,\n            top_left,\n            \u0026occupied\n        ));\n        assert!(!diagonal_occupied(\n            \u0026map,\n            top_right,\n            bottom_left,\n            \u0026occupied\n        ));\n\n        occupied.insert(top_left, edge_id.into());\n        occupied.insert(bottom_right, edge_id.into());\n\n        assert!(diagonal_occupied(\n            \u0026map,\n            bottom_left,\n            top_right,\n            \u0026occupied\n        ));\n        assert!(diagonal_occupied(\n            \u0026map,\n            top_right,\n            bottom_left,\n            \u0026occupied\n        ));\n\n        occupied.clear();\n        occupied.insert(top_right, edge_id.into());\n        occupied.insert(bottom_left, edge_id.into());\n\n        assert!(diagonal_occupied(\n            \u0026map,\n            bottom_right,\n            top_left,\n            \u0026occupied\n        ));\n        assert!(diagonal_occupied(\n            \u0026map,\n            top_left,\n            bottom_right,\n            \u0026occupied\n        ));\n\n        occupied.insert(top_left, edge_id.into());\n        occupied.insert(bottom_right, station_id.into());\n\n        assert!(diagonal_occupied(\n            \u0026map,\n            bottom_left,\n            top_right,\n            \u0026occupied\n        ));\n        assert!(diagonal_occupied(\n            \u0026map,\n            top_right,\n            bottom_left,\n            \u0026occupied\n        ));\n\n        occupied.clear();\n        occupied.insert(top_right, edge_id.into());\n        occupied.insert(bottom_left, station_id.into());\n\n        assert!(diagonal_occupied(\n            \u0026map,\n            bottom_right,\n            top_left,\n            \u0026occupied\n        ));\n        assert!(diagonal_occupied(\n            \u0026map,\n            top_left,\n            bottom_right,\n            \u0026occupied\n        ));\n\n        occupied.insert(top_left, station_id.into());\n        occupied.insert(bottom_right, edge_id.into());\n\n        assert!(diagonal_occupied(\n            \u0026map,\n            bottom_left,\n            top_right,\n            \u0026occupied\n        ));\n        assert!(diagonal_occupied(\n            \u0026map,\n            top_right,\n            bottom_left,\n            \u0026occupied\n        ));\n\n        occupied.clear();\n        occupied.insert(top_right, station_id.into());\n        occupied.insert(bottom_left, edge_id.into());\n\n        assert!(diagonal_occupied(\n            \u0026map,\n            bottom_right,\n            top_left,\n            \u0026occupied\n        ));\n        assert!(diagonal_occupied(\n            \u0026map,\n            top_left,\n            bottom_right,\n            \u0026occupied\n        ));\n    }\n\n    #[test]\n    fn test_calc_station_exit_cost() {\n        // TODO: implement test\n    }\n\n    #[test]\n    fn test_calc_node_cost() {\n        // TODO: implement test\n    }\n}\n","traces":[{"line":29,"address":[9906052,9899488,9902420],"length":1,"stats":{"Line":1}},{"line":36,"address":[8910322],"length":1,"stats":{"Line":1}},{"line":39,"address":[8910366],"length":1,"stats":{"Line":1}},{"line":40,"address":[9899689],"length":1,"stats":{"Line":1}},{"line":45,"address":[9900017,9899762,9899851],"length":1,"stats":{"Line":3}},{"line":46,"address":[9904785,9900049],"length":1,"stats":{"Line":2}},{"line":50,"address":[9905059,9905918,9904866,9904814],"length":1,"stats":{"Line":2}},{"line":51,"address":[9904811],"length":1,"stats":{"Line":1}},{"line":52,"address":[9904830],"length":1,"stats":{"Line":1}},{"line":56,"address":[9904966,9905098],"length":1,"stats":{"Line":2}},{"line":57,"address":[8915815],"length":1,"stats":{"Line":1}},{"line":58,"address":[9905448],"length":1,"stats":{"Line":1}},{"line":59,"address":[9905321],"length":1,"stats":{"Line":1}},{"line":60,"address":[8915967,8915899],"length":1,"stats":{"Line":2}},{"line":63,"address":[8916316],"length":1,"stats":{"Line":1}},{"line":64,"address":[8916164],"length":1,"stats":{"Line":1}},{"line":65,"address":[9905696,9905624],"length":1,"stats":{"Line":2}},{"line":73,"address":[9601856],"length":1,"stats":{"Line":3}},{"line":74,"address":[9601901],"length":1,"stats":{"Line":1}},{"line":77,"address":[8910801],"length":1,"stats":{"Line":2}},{"line":78,"address":[9602013],"length":1,"stats":{"Line":1}},{"line":82,"address":[9900155],"length":1,"stats":{"Line":1}},{"line":84,"address":[9602080],"length":1,"stats":{"Line":1}},{"line":86,"address":[9602150,9602106],"length":1,"stats":{"Line":1}},{"line":87,"address":[8966462,8966527],"length":1,"stats":{"Line":2}},{"line":88,"address":[9602167,9602232],"length":1,"stats":{"Line":2}},{"line":89,"address":[9602273,9602208],"length":1,"stats":{"Line":1}},{"line":90,"address":[8966585,8966650],"length":1,"stats":{"Line":2}},{"line":91,"address":[9602290,9602355],"length":1,"stats":{"Line":2}},{"line":92,"address":[9602394,9602331],"length":1,"stats":{"Line":2}},{"line":93,"address":[9602372,9602536],"length":1,"stats":{"Line":0}},{"line":94,"address":[9602476],"length":1,"stats":{"Line":0}},{"line":101,"address":[9900166,9900368,9900447],"length":1,"stats":{"Line":3}},{"line":102,"address":[8911326,8911265],"length":1,"stats":{"Line":2}},{"line":103,"address":[9900679,9900821],"length":1,"stats":{"Line":2}},{"line":106,"address":[9901453,9901923,9901547,9901829,9902148,9901359,9901735,9901641,9901153],"length":1,"stats":{"Line":9}},{"line":109,"address":[9900888,9900835],"length":1,"stats":{"Line":2}},{"line":110,"address":[8911564],"length":1,"stats":{"Line":1}},{"line":111,"address":[8911621],"length":1,"stats":{"Line":1}},{"line":112,"address":[9901145,9900992],"length":1,"stats":{"Line":2}},{"line":117,"address":[8912981],"length":1,"stats":{"Line":1}},{"line":122,"address":[9900656,9900750,9900724],"length":1,"stats":{"Line":2}},{"line":125,"address":[8913096],"length":1,"stats":{"Line":1}},{"line":126,"address":[8913297,8913376,8913107],"length":1,"stats":{"Line":3}},{"line":127,"address":[8913514,8913575],"length":1,"stats":{"Line":2}},{"line":128,"address":[9903115,9902972],"length":1,"stats":{"Line":2}},{"line":131,"address":[9904442,9904217],"length":1,"stats":{"Line":2}},{"line":134,"address":[9903129,9903174],"length":1,"stats":{"Line":2}},{"line":135,"address":[9903300],"length":1,"stats":{"Line":1}},{"line":137,"address":[9903577],"length":1,"stats":{"Line":1}},{"line":138,"address":[9903879,9903726],"length":1,"stats":{"Line":2}},{"line":145,"address":[9904615],"length":1,"stats":{"Line":1}},{"line":150,"address":[9902949,9903017,9903043],"length":1,"stats":{"Line":2}},{"line":153,"address":[8915329],"length":1,"stats":{"Line":1}},{"line":158,"address":[8916608],"length":1,"stats":{"Line":1}},{"line":159,"address":[9906839],"length":1,"stats":{"Line":1}},{"line":160,"address":[9906143,9906103],"length":1,"stats":{"Line":1}},{"line":161,"address":[9906123,9906182],"length":1,"stats":{"Line":2}},{"line":162,"address":[8916690,8916749],"length":1,"stats":{"Line":2}},{"line":163,"address":[8916729,8916788],"length":1,"stats":{"Line":2}},{"line":164,"address":[9906240,9906299],"length":1,"stats":{"Line":2}},{"line":165,"address":[9906279,9906333],"length":1,"stats":{"Line":2}},{"line":166,"address":[9906372,9906313],"length":1,"stats":{"Line":2}},{"line":167,"address":[9906409,9906352],"length":1,"stats":{"Line":2}},{"line":168,"address":[8917270,8916919],"length":1,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[9906760,9906529,9906659,9906811],"length":1,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[9906880],"length":1,"stats":{"Line":1}},{"line":181,"address":[8917441],"length":1,"stats":{"Line":1}},{"line":183,"address":[8917478],"length":1,"stats":{"Line":1}},{"line":184,"address":[9602912,9602817,9603149,9602586,9602722,9603002],"length":1,"stats":{"Line":0}},{"line":192,"address":[9907072],"length":1,"stats":{"Line":1}},{"line":198,"address":[9907163],"length":1,"stats":{"Line":1}},{"line":199,"address":[9907242,9907313],"length":1,"stats":{"Line":2}},{"line":201,"address":[9907323],"length":1,"stats":{"Line":1}},{"line":202,"address":[8917880],"length":1,"stats":{"Line":1}},{"line":207,"address":[9907343,9907385],"length":1,"stats":{"Line":2}},{"line":208,"address":[9907398,9907427],"length":1,"stats":{"Line":2}},{"line":210,"address":[9907409],"length":1,"stats":{"Line":1}},{"line":211,"address":[8967566,8967552],"length":1,"stats":{"Line":2}},{"line":212,"address":[8967575],"length":1,"stats":{"Line":1}},{"line":217,"address":[8917959,8918014],"length":1,"stats":{"Line":2}},{"line":218,"address":[8918030,8918056],"length":1,"stats":{"Line":2}},{"line":220,"address":[9907536],"length":1,"stats":{"Line":1}},{"line":221,"address":[8967630,8967616],"length":1,"stats":{"Line":2}},{"line":222,"address":[8967639],"length":1,"stats":{"Line":1}},{"line":228,"address":[9907303],"length":1,"stats":{"Line":1}},{"line":236,"address":[9907584,9909705],"length":1,"stats":{"Line":1}},{"line":244,"address":[9907788],"length":1,"stats":{"Line":1}},{"line":245,"address":[8918439],"length":1,"stats":{"Line":0}},{"line":250,"address":[8918395],"length":1,"stats":{"Line":1}},{"line":251,"address":[8918361],"length":1,"stats":{"Line":1}},{"line":253,"address":[9603344,9603350],"length":1,"stats":{"Line":2}},{"line":256,"address":[8918462],"length":1,"stats":{"Line":0}},{"line":257,"address":[9907964],"length":1,"stats":{"Line":0}},{"line":261,"address":[9907976,9908028,9908157],"length":1,"stats":{"Line":0}},{"line":262,"address":[9908181],"length":1,"stats":{"Line":0}},{"line":266,"address":[9909846,9910056,9909804],"length":1,"stats":{"Line":0}},{"line":267,"address":[9909801],"length":1,"stats":{"Line":0}},{"line":268,"address":[8920237],"length":1,"stats":{"Line":0}},{"line":273,"address":[9909936],"length":1,"stats":{"Line":0}},{"line":274,"address":[8920378],"length":1,"stats":{"Line":0}},{"line":276,"address":[9910007,9910124],"length":1,"stats":{"Line":0}},{"line":277,"address":[8920508],"length":1,"stats":{"Line":0}},{"line":278,"address":[8920532],"length":1,"stats":{"Line":0}},{"line":284,"address":[8918586,8918742],"length":1,"stats":{"Line":0}},{"line":285,"address":[8918862,8918989],"length":1,"stats":{"Line":0}},{"line":293,"address":[8919004,8919062],"length":1,"stats":{"Line":0}},{"line":294,"address":[8919102],"length":1,"stats":{"Line":0}},{"line":295,"address":[8919137],"length":1,"stats":{"Line":0}},{"line":297,"address":[8919305],"length":1,"stats":{"Line":0}},{"line":302,"address":[8919467,8919333,8919084,8919495],"length":1,"stats":{"Line":0}},{"line":303,"address":[8919531,8919968],"length":1,"stats":{"Line":0}},{"line":304,"address":[9909564],"length":1,"stats":{"Line":0}},{"line":310,"address":[8919565],"length":1,"stats":{"Line":0}},{"line":311,"address":[8919703,8919668],"length":1,"stats":{"Line":0}},{"line":313,"address":[9909392],"length":1,"stats":{"Line":0}},{"line":314,"address":[9909306],"length":1,"stats":{"Line":0}},{"line":315,"address":[9909345],"length":1,"stats":{"Line":0}},{"line":318,"address":[8967750,8967744],"length":1,"stats":{"Line":0}},{"line":325,"address":[8920177],"length":1,"stats":{"Line":0}},{"line":333,"address":[9910144],"length":1,"stats":{"Line":1}},{"line":343,"address":[8920734],"length":1,"stats":{"Line":1}},{"line":344,"address":[9910391],"length":1,"stats":{"Line":0}},{"line":347,"address":[8920791,8920867],"length":1,"stats":{"Line":1}},{"line":348,"address":[9910614,9910792,9910848],"length":1,"stats":{"Line":0}},{"line":352,"address":[8920929,8921000],"length":1,"stats":{"Line":0}},{"line":355,"address":[9910599],"length":1,"stats":{"Line":0}},{"line":357,"address":[8921288],"length":1,"stats":{"Line":0}},{"line":359,"address":[9910417],"length":1,"stats":{"Line":1}},{"line":360,"address":[8921175],"length":1,"stats":{"Line":0}},{"line":363,"address":[9910742],"length":1,"stats":{"Line":1}},{"line":364,"address":[8921334,8921880],"length":1,"stats":{"Line":2}},{"line":365,"address":[9911576],"length":1,"stats":{"Line":1}},{"line":366,"address":[9911675],"length":1,"stats":{"Line":1}},{"line":368,"address":[9911767],"length":1,"stats":{"Line":0}},{"line":371,"address":[9911846,9911906],"length":1,"stats":{"Line":2}},{"line":376,"address":[9911804,9911552,9911933],"length":1,"stats":{"Line":2}},{"line":377,"address":[8922224],"length":1,"stats":{"Line":1}},{"line":379,"address":[8967776,8967787],"length":1,"stats":{"Line":3}},{"line":382,"address":[9910946,9910902],"length":1,"stats":{"Line":2}},{"line":383,"address":[8921467],"length":1,"stats":{"Line":1}},{"line":384,"address":[9911158],"length":1,"stats":{"Line":1}},{"line":386,"address":[9911255],"length":1,"stats":{"Line":0}},{"line":389,"address":[9911413,9911292,9911031],"length":1,"stats":{"Line":3}},{"line":390,"address":[9603483,9603472],"length":1,"stats":{"Line":3}}],"covered":104,"coverable":147},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","drawing","calc_direction.rs"],"content":"//! Contains tools to determine the direction of an edge.\n\nuse crate::utils::equal_pixel;\n\n/// Represents the direction the edge is moving.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum EdgeDirection {\n    /// The edge is moving up.\n    Up,\n    /// The edge is moving diagonally up and to the right.\n    DiagUpRight,\n    /// The edge is moving right.\n    Right,\n    /// The edge is moving diagonally down and to the right.\n    DiagDownRight,\n    /// The edge is moving down.\n    Down,\n    /// The edge is moving diagonally down and to the left.\n    DiagDownLeft,\n    /// The edge is moving left.\n    Left,\n    /// The edge is moving diagonally up and to the left.\n    DiagUpLeft,\n    /// The edge is not moving.\n    Equal,\n}\n\n/// Calculates the direction the edge is moving.\npub fn calc_direction(from_x: f64, from_y: f64, to_x: f64, to_y: f64) -\u003e EdgeDirection {\n    if equal_pixel(from_x, to_x) \u0026\u0026 from_y \u003e to_y {\n        EdgeDirection::Up\n    } else if from_x \u003c to_x \u0026\u0026 from_y \u003e to_y {\n        EdgeDirection::DiagUpRight\n    } else if from_x \u003c to_x \u0026\u0026 equal_pixel(from_y, to_y) {\n        EdgeDirection::Right\n    } else if from_x \u003c to_x \u0026\u0026 from_y \u003c to_y {\n        EdgeDirection::DiagDownRight\n    } else if equal_pixel(from_x, to_x) \u0026\u0026 from_y \u003c to_y {\n        EdgeDirection::Down\n    } else if from_x \u003e to_x \u0026\u0026 from_y \u003c to_y {\n        EdgeDirection::DiagDownLeft\n    } else if from_x \u003e to_x \u0026\u0026 equal_pixel(from_y, to_y) {\n        EdgeDirection::Left\n    } else if from_x \u003e to_x \u0026\u0026 from_y \u003e to_y {\n        EdgeDirection::DiagUpLeft\n    } else {\n        EdgeDirection::Equal\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_calc_direction() {\n        assert_eq!(\n            calc_direction(0.0, 0.0, 0.0, -1.0),\n            EdgeDirection::Up\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, 1.0, -1.0),\n            EdgeDirection::DiagUpRight\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, 1.0, 0.0),\n            EdgeDirection::Right\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, 1.0, 1.0),\n            EdgeDirection::DiagDownRight\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, 0.0, 1.0),\n            EdgeDirection::Down\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, -1.0, 1.0),\n            EdgeDirection::DiagDownLeft\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, -1.0, 0.0),\n            EdgeDirection::Left\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, -1.0, -1.0),\n            EdgeDirection::DiagUpLeft\n        );\n        assert_eq!(\n            calc_direction(0.0, 0.0, 0.0, 0.0),\n            EdgeDirection::Equal\n        );\n    }\n}\n","traces":[{"line":29,"address":[7749744],"length":1,"stats":{"Line":1}},{"line":30,"address":[8483075,8483117,8483128],"length":1,"stats":{"Line":3}},{"line":31,"address":[8483123],"length":1,"stats":{"Line":1}},{"line":32,"address":[8483165,8483097,8483176],"length":1,"stats":{"Line":3}},{"line":33,"address":[8483171],"length":1,"stats":{"Line":1}},{"line":34,"address":[8483145,8483213,8483230],"length":1,"stats":{"Line":3}},{"line":35,"address":[8483225],"length":1,"stats":{"Line":1}},{"line":36,"address":[8483193,8483271,8483282],"length":1,"stats":{"Line":3}},{"line":37,"address":[8483277],"length":1,"stats":{"Line":1}},{"line":38,"address":[8483330,8483319,8483247],"length":1,"stats":{"Line":3}},{"line":39,"address":[8483325],"length":1,"stats":{"Line":1}},{"line":40,"address":[8483299,8483364,8483375],"length":1,"stats":{"Line":3}},{"line":41,"address":[8483370],"length":1,"stats":{"Line":1}},{"line":42,"address":[8483409,8483426,8483344],"length":1,"stats":{"Line":3}},{"line":43,"address":[8483421],"length":1,"stats":{"Line":1}},{"line":44,"address":[8483433,8483389],"length":1,"stats":{"Line":2}},{"line":45,"address":[8483453],"length":1,"stats":{"Line":1}},{"line":47,"address":[8483428],"length":1,"stats":{"Line":1}}],"covered":18,"coverable":18},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","drawing","canvas_context.rs"],"content":"//! Contains the [`CanvasContext`] struct and all its methods used for drawing\n//! to the html canvas.\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nuse std::{\n    borrow::Cow,\n    ops::Deref,\n};\n#[cfg(any(test, feature = \"benchmarking\"))]\nuse std::{\n    cell::RefCell,\n    collections::HashMap,\n    marker::PhantomData,\n};\n\n#[cfg(any(test, feature = \"benchmarking\"))]\nuse wasm_bindgen::JsValue;\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nuse wasm_bindgen::{\n    JsCast,\n    JsValue,\n};\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nuse web_sys::js_sys::Uint8Array;\nuse web_sys::HtmlCanvasElement;\n\n/// A wrapper around the [`web_sys::CanvasRenderingContext2d`]. This struct\n/// provides the ability to mock and unit-test the drawing functions.\npub struct CanvasContext\u003c'a\u003e {\n    /// The inner [`web_sys::CanvasRenderingContext2d`] object wrapped by this\n    /// struct.\n    #[cfg(all(not(test), not(feature = \"benchmarking\")))]\n    inner: Cow\u003c'a, web_sys::CanvasRenderingContext2d\u003e,\n    #[cfg(any(test, feature = \"benchmarking\"))]\n    inner: PhantomData\u003c\u0026'a ()\u003e,\n    #[cfg(any(test, feature = \"benchmarking\"))]\n    recorder: RefCell\u003cHashMap\u003cString, Vec\u003cString\u003e\u003e\u003e,\n}\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nimpl From\u003cweb_sys::CanvasRenderingContext2d\u003e for CanvasContext\u003c'static\u003e {\n    fn from(context: web_sys::CanvasRenderingContext2d) -\u003e Self {\n        Self {\n            inner: Cow::Owned(context),\n        }\n    }\n}\n\n#[cfg(any(test, feature = \"benchmarking\"))]\nimpl From\u003cweb_sys::CanvasRenderingContext2d\u003e for CanvasContext\u003c'static\u003e {\n    fn from(_: web_sys::CanvasRenderingContext2d) -\u003e Self {\n        Self {\n            inner: PhantomData,\n            recorder: RefCell::new(HashMap::new()),\n        }\n    }\n}\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nimpl\u003c'a\u003e From\u003c\u0026'a HtmlCanvasElement\u003e for CanvasContext\u003c'a\u003e {\n    fn from(canvas: \u0026'a HtmlCanvasElement) -\u003e Self {\n        let context = canvas\n            .get_context(\"2d\")\n            .expect(\"Failed to get 2d context\")\n            .expect(\"2d context is null\")\n            .dyn_into::\u003cweb_sys::CanvasRenderingContext2d\u003e()\n            .expect(\"Failed to convert to CanvasRenderingContext2d\");\n\n        Self {\n            inner: Cow::Owned(context),\n        }\n    }\n}\n\n#[cfg(any(test, feature = \"benchmarking\"))]\nimpl\u003c'a\u003e From\u003c\u0026'a HtmlCanvasElement\u003e for CanvasContext\u003c'a\u003e {\n    fn from(_: \u0026'a HtmlCanvasElement) -\u003e Self {\n        Self {\n            inner: PhantomData,\n            recorder: RefCell::new(HashMap::new()),\n        }\n    }\n}\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nimpl\u003c'a\u003e From\u003c\u0026'a web_sys::CanvasRenderingContext2d\u003e for CanvasContext\u003c'a\u003e {\n    fn from(context: \u0026'a web_sys::CanvasRenderingContext2d) -\u003e Self {\n        Self {\n            inner: Cow::Borrowed(context),\n        }\n    }\n}\n\n#[cfg(any(test, feature = \"benchmarking\"))]\nimpl\u003c'a\u003e From\u003c\u0026'a web_sys::CanvasRenderingContext2d\u003e for CanvasContext\u003c'a\u003e {\n    fn from(_: \u0026'a web_sys::CanvasRenderingContext2d) -\u003e Self {\n        Self {\n            inner: PhantomData,\n            recorder: RefCell::new(HashMap::new()),\n        }\n    }\n}\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nimpl AsRef\u003cweb_sys::CanvasRenderingContext2d\u003e for CanvasContext\u003c'_\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026web_sys::CanvasRenderingContext2d {\n        \u0026self.inner\n    }\n}\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nimpl Deref for CanvasContext\u003c'_\u003e {\n    type Target = web_sys::CanvasRenderingContext2d;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.inner\n    }\n}\n\n#[cfg(all(not(test), not(feature = \"benchmarking\")))]\nimpl CanvasContext\u003c'_\u003e {\n    pub fn set_line_dash(\u0026self, segments: \u0026[u8]) -\u003e Result\u003c(), JsValue\u003e {\n        self.inner\n            .set_line_dash(\u0026Uint8Array::from(segments))\n    }\n}\n\n#[cfg(any(test, feature = \"benchmarking\"))]\nimpl\u003c'a\u003e CanvasContext\u003c'a\u003e {\n    pub fn new() -\u003e Self {\n        Self {\n            inner: PhantomData,\n            recorder: RefCell::new(HashMap::new()),\n        }\n    }\n\n    pub fn move_to(\u0026self, x: f64, y: f64) {\n        self.record(\n            \"move_to\",\n            format!(\"{x:.1},{y:.1}\").as_str(),\n        );\n    }\n\n    pub fn line_to(\u0026self, x: f64, y: f64) {\n        self.record(\n            \"line_to\",\n            format!(\"{x:.1},{y:.1}\").as_str(),\n        );\n    }\n\n    pub fn stroke(\u0026self) {\n        self.record(\"stroke\", \"\");\n    }\n\n    pub fn begin_path(\u0026self) {\n        self.record(\"begin_path\", \"\");\n    }\n\n    pub fn set_line_width(\u0026self, f: f64) {\n        self.record(\n            \"set_line_width\",\n            format!(\"{f}\").as_str(),\n        );\n    }\n\n    pub fn set_stroke_style_str(\u0026self, _: \u0026str) {}\n\n    pub fn set_global_alpha(\u0026self, _: f64) {}\n\n    pub fn arc(\n        \u0026self,\n        x: f64,\n        y: f64,\n        radius: f64,\n        start_angle: f64,\n        end_angle: f64,\n    ) -\u003e Result\u003c(), JsValue\u003e {\n        self.record(\n            \"arc\",\n            format!(\"{x:.1},{y:.1},{radius},{start_angle},{end_angle}\").as_str(),\n        );\n        Ok(())\n    }\n\n    pub fn set_line_dash(\u0026self, _: \u0026[u8]) -\u003e Result\u003c(), JsValue\u003e {\n        Ok(())\n    }\n\n    pub fn fill(\u0026self) {\n        self.record(\"fill\", \"\");\n    }\n\n    pub fn set_fill_style_str(\u0026self, style: \u0026str) {\n        self.record(\"set_fill_style\", style);\n    }\n\n    fn record(\u0026self, name: \u0026str, value: \u0026str) {\n        self.recorder\n            .borrow_mut()\n            .entry(name.to_string())\n            .or_insert_with(Vec::new)\n            .push(value.to_string());\n    }\n\n    pub fn get_record(\u0026self, name: \u0026str) -\u003e Option\u003cVec\u003cString\u003e\u003e {\n        self.recorder\n            .borrow()\n            .get(name)\n            .cloned()\n    }\n}\n","traces":[{"line":42,"address":[8475632],"length":1,"stats":{"Line":0}},{"line":44,"address":[8475639],"length":1,"stats":{"Line":0}},{"line":51,"address":[9075524,9075392],"length":1,"stats":{"Line":0}},{"line":54,"address":[9075473,9075418],"length":1,"stats":{"Line":0}},{"line":61,"address":[8475680],"length":1,"stats":{"Line":0}},{"line":62,"address":[8475712],"length":1,"stats":{"Line":0}},{"line":70,"address":[8475867],"length":1,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[9075577],"length":1,"stats":{"Line":0}},{"line":87,"address":[8475904],"length":1,"stats":{"Line":0}},{"line":89,"address":[8475912],"length":1,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[9075673],"length":1,"stats":{"Line":0}},{"line":106,"address":[8475952],"length":1,"stats":{"Line":0}},{"line":107,"address":[8475957],"length":1,"stats":{"Line":0}},{"line":115,"address":[8475968],"length":1,"stats":{"Line":0}},{"line":116,"address":[8475973],"length":1,"stats":{"Line":0}},{"line":122,"address":[8476168,8475984],"length":1,"stats":{"Line":0}},{"line":123,"address":[8476013,8476122],"length":1,"stats":{"Line":0}},{"line":124,"address":[8476100,8476037],"length":1,"stats":{"Line":0}},{"line":130,"address":[9075744],"length":1,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[9076814,9075824],"length":1,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":16}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":16}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[9077877],"length":1,"stats":{"Line":1}},{"line":155,"address":[9077920],"length":1,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[9078303,9078288],"length":1,"stats":{"Line":3}},{"line":168,"address":[9078304,9078315],"length":1,"stats":{"Line":2}},{"line":170,"address":[9078320,9080441],"length":1,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[9080544],"length":1,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":12}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":55},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","drawing","closest_corner.rs"],"content":"//! Contains the function for calculating the closest corner of a station to\n//! another.\n\nuse std::f64::consts::PI;\n\nuse crate::{\n    components::CanvasState,\n    utils::equal_pixel,\n};\n\n/// Calculates the coordinate of the corner (on an octilinear grid) of a station\n/// closest to the given neigbor. An offset is provided for, if the corner is\n/// further from the middle of the station coordinate.\npub fn calc_closest_corner(\n    from: (f64, f64),\n    to: (f64, f64),\n    state: CanvasState,\n    height_offset: f64,\n) -\u003e (f64, f64) {\n    let cardinal_offset = state.drawn_square_size() / PI;\n    let corner_offset = state.drawn_square_size() / PI * 0.8;\n\n    let (from_x, from_y) = from;\n    let (to_x, to_y) = to;\n\n    if equal_pixel(from_x, to_x) {\n        if from_y \u003e to_y {\n            (\n                from_x + height_offset,\n                from_y - cardinal_offset,\n            ) // below\n        } else {\n            (\n                from_x - height_offset,\n                from_y + cardinal_offset,\n            ) // above\n        }\n    } else if from_x \u003e to_x {\n        if equal_pixel(from_y, to_y) {\n            (\n                from_x - cardinal_offset,\n                from_y - height_offset,\n            ) // left\n        } else if from_y \u003e to_y {\n            (\n                from_x - corner_offset + height_offset,\n                from_y - corner_offset - height_offset,\n            ) // below left\n        } else {\n            (\n                from_x - corner_offset - height_offset,\n                from_y + corner_offset - height_offset,\n            ) // above left\n        }\n    } else if equal_pixel(from_y, to_y) {\n        (\n            from_x + cardinal_offset,\n            from_y + height_offset,\n        ) // right\n    } else if from_y \u003e to_y {\n        (\n            from_x + corner_offset + height_offset,\n            from_y - corner_offset + height_offset,\n        ) // below right\n    } else {\n        (\n            from_x + corner_offset - height_offset,\n            from_y + corner_offset + height_offset,\n        ) // above right\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn run_closest_corner_test(from: (f64, f64), to: (f64, f64), expected: (f64, f64)) {\n        let mut state = CanvasState::new();\n        state.set_square_size(3);\n\n        let result = calc_closest_corner(from, to, state, 0.0);\n        let (result_x, result_y) = result;\n        let (expected_x, expected_y) = expected;\n\n        assert!(\n            equal_pixel(result_x, expected_x),\n            \"expected {expected:?} got ({}, {})\",\n            result_x.round(),\n            result_y.round()\n        );\n        assert!(\n            equal_pixel(result_y, expected_y),\n            \"expected {expected:?} got ({}, {})\",\n            result_x.round(),\n            result_y.round()\n        );\n    }\n\n    #[test]\n    fn test_calc_closest_corner() {\n        // Bottom right\n        run_closest_corner_test((15.0, 15.0), (20.0, 20.0), (16.0, 16.0));\n        run_closest_corner_test((15.0, 15.0), (16.0, 20.0), (16.0, 16.0));\n        run_closest_corner_test((15.0, 15.0), (20.0, 16.0), (16.0, 16.0));\n\n        // Top right\n        run_closest_corner_test((15.0, 15.0), (20.0, 10.0), (16.0, 14.0));\n        run_closest_corner_test((15.0, 15.0), (16.0, 10.0), (16.0, 14.0));\n        run_closest_corner_test((15.0, 15.0), (20.0, 14.0), (16.0, 14.0));\n\n        // Top left\n        run_closest_corner_test((15.0, 15.0), (10.0, 10.0), (14.0, 14.0));\n        run_closest_corner_test((15.0, 15.0), (14.0, 10.0), (14.0, 14.0));\n        run_closest_corner_test((15.0, 15.0), (10.0, 14.0), (14.0, 14.0));\n\n        // Bottom left\n        run_closest_corner_test((15.0, 15.0), (10.0, 20.0), (14.0, 16.0));\n        run_closest_corner_test((15.0, 15.0), (14.0, 20.0), (14.0, 16.0));\n        run_closest_corner_test((15.0, 15.0), (10.0, 16.0), (14.0, 16.0));\n\n        // same x-axis\n        run_closest_corner_test((15.0, 15.0), (15.0, 20.0), (15.0, 16.0));\n        run_closest_corner_test((15.0, 15.0), (15.0, 10.0), (15.0, 14.0));\n\n        // same y-axis\n        run_closest_corner_test((15.0, 15.0), (20.0, 15.0), (16.0, 15.0));\n        run_closest_corner_test((15.0, 15.0), (10.0, 15.0), (14.0, 15.0));\n    }\n}\n","traces":[{"line":14,"address":[9732400],"length":1,"stats":{"Line":1}},{"line":20,"address":[9732471],"length":1,"stats":{"Line":1}},{"line":21,"address":[9732506],"length":1,"stats":{"Line":1}},{"line":23,"address":[9732578],"length":1,"stats":{"Line":1}},{"line":24,"address":[7984450],"length":1,"stats":{"Line":1}},{"line":26,"address":[9732614],"length":1,"stats":{"Line":1}},{"line":27,"address":[9733183,9733135,9732656],"length":1,"stats":{"Line":3}},{"line":29,"address":[9733163],"length":1,"stats":{"Line":1}},{"line":30,"address":[9733167],"length":1,"stats":{"Line":1}},{"line":34,"address":[9733115],"length":1,"stats":{"Line":1}},{"line":35,"address":[9733119],"length":1,"stats":{"Line":1}},{"line":38,"address":[9732636],"length":1,"stats":{"Line":1}},{"line":39,"address":[9732707,9732978],"length":1,"stats":{"Line":2}},{"line":41,"address":[9732958],"length":1,"stats":{"Line":1}},{"line":42,"address":[7984813],"length":1,"stats":{"Line":1}},{"line":44,"address":[9732927,9733031,9733087],"length":1,"stats":{"Line":3}},{"line":46,"address":[7984910],"length":1,"stats":{"Line":1}},{"line":47,"address":[9733067],"length":1,"stats":{"Line":1}},{"line":51,"address":[7984854],"length":1,"stats":{"Line":1}},{"line":52,"address":[9733011],"length":1,"stats":{"Line":1}},{"line":55,"address":[9732789,9732683],"length":1,"stats":{"Line":2}},{"line":57,"address":[9732769],"length":1,"stats":{"Line":1}},{"line":58,"address":[9732773],"length":1,"stats":{"Line":1}},{"line":60,"address":[9732738,9732842],"length":1,"stats":{"Line":2}},{"line":62,"address":[9732867],"length":1,"stats":{"Line":1}},{"line":63,"address":[9732875],"length":1,"stats":{"Line":1}},{"line":67,"address":[9732814],"length":1,"stats":{"Line":1}},{"line":68,"address":[9732822],"length":1,"stats":{"Line":1}}],"covered":28,"coverable":28},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","drawing","draw_edge.rs"],"content":"//! Contains the function for drawing an edge onto the map.\n\nuse super::{\n    calc_closest_corner,\n    calc_direction::{\n        calc_direction,\n        EdgeDirection,\n    },\n    canvas_context::CanvasContext,\n};\nuse crate::{\n    components::CanvasState,\n    models::GridNode,\n};\n\n/// Adds an offset to the given coordinates based on the given direction of the\n/// edge.\npub fn add_offset(offset: f64, x: f64, y: f64, direction: EdgeDirection) -\u003e (f64, f64) {\n    match direction {\n        EdgeDirection::Up =\u003e (x + offset, y),\n        EdgeDirection::DiagUpRight =\u003e (x + offset, y + offset),\n        EdgeDirection::Right =\u003e (x, y + offset),\n        EdgeDirection::DiagDownRight =\u003e (x - offset, y + offset),\n        EdgeDirection::Down =\u003e (x - offset, y),\n        EdgeDirection::DiagDownLeft =\u003e (x - offset, y - offset),\n        EdgeDirection::Left =\u003e (x, y - offset),\n        EdgeDirection::DiagUpLeft =\u003e (x + offset, y - offset),\n        EdgeDirection::Equal =\u003e (x, y),\n    }\n}\n\n/// Draws an edge between two nodes with, optionally, the given step nodes in\n/// between. An offset can be given to draw the edge higher or lower.\npub fn draw_edge(\n    from: GridNode,\n    to: GridNode,\n    steps: \u0026[GridNode],\n    canvas: \u0026CanvasContext\u003c'_\u003e,\n    state: CanvasState,\n    height_offset: f64,\n) {\n    let from_pos = from.to_canvas_pos(state);\n    let to_pos = to.to_canvas_pos(state);\n    let has_offset = height_offset.abs() \u003e f64::EPSILON;\n\n    // The position of the start node on the canvas, based on the direction it is\n    // leaving the station from\n    let (from_x, from_y) = calc_closest_corner(\n        from_pos,\n        steps\n            .first()\n            .map_or(to_pos, |s| s.to_canvas_pos(state)),\n        state,\n        height_offset,\n    );\n    canvas.move_to(from_x, from_y);\n\n    // The position of the last node on the canvas and if it is on the canvas\n    let mut last_pos = (from_x, from_y);\n    let mut last_is = state.is_on_canvas(from);\n\n    for step in steps {\n        let (mut step_x, mut step_y) = step.to_canvas_pos(state);\n\n        if has_offset {\n            // Add a potential offset to the step based on the direction the edge is going\n            let direction = calc_direction(last_pos.0, last_pos.1, step_x, step_y);\n            last_pos = (step_x, step_y);\n            (step_x, step_y) = add_offset(height_offset, step_x, step_y, direction);\n        }\n\n        // If the last step was off the canvas and the current step is off the canvas,\n        // then don't draw this edge\n        let step_is = state.is_on_canvas(*step);\n        if !last_is \u0026\u0026 !step_is {\n            canvas.move_to(step_x, step_y);\n            continue;\n        }\n        last_is = step_is;\n\n        canvas.line_to(step_x, step_y);\n    }\n\n    // The position of the target node on the canvas, based on the direction it is\n    // coming into the station from\n    let (to_x, to_y) = calc_closest_corner(\n        to_pos,\n        steps\n            .last()\n            .map_or(from_pos, |s| s.to_canvas_pos(state)),\n        state,\n        -height_offset,\n    );\n    canvas.line_to(to_x, to_y);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_draw_edge_diag() {\n        let canvas = CanvasContext::new();\n        let mut state = CanvasState::new();\n        state.set_square_size(5);\n        state.set_size((100, 100));\n\n        let from = GridNode::from((0, 0));\n        let to = GridNode::from((3, 3));\n        let steps = vec![\n            GridNode::from((1, 1)),\n            GridNode::from((2, 2)),\n        ];\n\n        draw_edge(from, to, \u0026steps, \u0026canvas, state, 0.0);\n\n        assert_eq!(\n            canvas.get_record(\"move_to\"),\n            Some(vec![\"1.3,1.3\".to_owned(),])\n        );\n\n        assert_eq!(\n            canvas.get_record(\"line_to\"),\n            Some(vec![\n                \"5.0,5.0\".to_owned(),\n                \"10.0,10.0\".to_owned(),\n                \"13.7,13.7\".to_owned()\n            ])\n        );\n    }\n\n    #[test]\n    fn test_draw_edge_wiggly() {\n        let canvas = CanvasContext::new();\n        let mut state = CanvasState::new();\n        state.set_square_size(5);\n        state.set_size((100, 100));\n\n        let from = GridNode::from((0, 0));\n        let to = GridNode::from((3, 3));\n        let steps = vec![\n            GridNode::from((1, 1)),\n            GridNode::from((1, 2)),\n            GridNode::from((2, 2)),\n            GridNode::from((2, 3)),\n            GridNode::from((2, 4)),\n            GridNode::from((3, 4)),\n        ];\n\n        draw_edge(from, to, \u0026steps, \u0026canvas, state, 0.0);\n\n        assert_eq!(\n            canvas.get_record(\"move_to\"),\n            Some(vec![\"1.3,1.3\".to_owned(),])\n        );\n\n        assert_eq!(\n            canvas.get_record(\"line_to\"),\n            Some(vec![\n                \"5.0,5.0\".to_owned(),\n                \"5.0,10.0\".to_owned(),\n                \"10.0,10.0\".to_owned(),\n                \"10.0,15.0\".to_owned(),\n                \"10.0,20.0\".to_owned(),\n                \"15.0,20.0\".to_owned(),\n                \"15.0,16.6\".to_owned()\n            ])\n        );\n    }\n\n    #[test]\n    fn test_draw_edge_on_off_canvas() {\n        let canvas = CanvasContext::new();\n        let mut state = CanvasState::new();\n        state.set_square_size(5);\n        state.set_size((16, 16));\n\n        let from = GridNode::from((0, 0));\n        let to = GridNode::from((3, 3));\n        let steps = vec![\n            GridNode::from((1, 1)),\n            GridNode::from((1, 2)),\n            GridNode::from((2, 2)),\n            GridNode::from((2, 3)),\n            GridNode::from((2, 4)),\n            GridNode::from((3, 4)),\n            GridNode::from((4, 4)),\n            GridNode::from((4, 5)),\n            GridNode::from((3, 4)),\n        ];\n\n        draw_edge(from, to, \u0026steps, \u0026canvas, state, 0.0);\n\n        assert_eq!(\n            canvas.get_record(\"move_to\"),\n            Some(vec![\n                \"1.3,1.3\".to_owned(),\n                \"15.0,20.0\".to_owned(),\n                \"20.0,20.0\".to_owned(),\n                \"20.0,25.0\".to_owned(),\n                \"15.0,20.0\".to_owned(),\n            ])\n        );\n\n        assert_eq!(\n            canvas.get_record(\"line_to\"),\n            Some(vec![\n                \"5.0,5.0\".to_owned(),\n                \"5.0,10.0\".to_owned(),\n                \"10.0,10.0\".to_owned(),\n                \"10.0,15.0\".to_owned(),\n                \"10.0,20.0\".to_owned(),\n                \"15.0,16.6\".to_owned()\n            ])\n        );\n    }\n\n    #[test]\n    fn test_draw_edge_with_offset() {\n        let canvas = CanvasContext::new();\n        let mut state = CanvasState::new();\n        state.set_square_size(5);\n        state.set_size((100, 100));\n\n        let from = GridNode::from((0, 0));\n        let to = GridNode::from((3, 3));\n        let steps = vec![\n            GridNode::from((1, 1)),\n            GridNode::from((2, 2)),\n        ];\n\n        draw_edge(from, to, \u0026steps, \u0026canvas, state, 1.0);\n\n        assert_eq!(\n            canvas.get_record(\"move_to\"),\n            Some(vec![\"0.3,2.3\".to_owned(),])\n        );\n\n        assert_eq!(\n            canvas.get_record(\"line_to\"),\n            Some(vec![\n                \"4.0,6.0\".to_owned(),\n                \"9.0,11.0\".to_owned(),\n                \"12.7,14.7\".to_owned()\n            ])\n        );\n    }\n}\n","traces":[{"line":18,"address":[9724960],"length":1,"stats":{"Line":1}},{"line":19,"address":[8481211],"length":1,"stats":{"Line":1}},{"line":20,"address":[8481262],"length":1,"stats":{"Line":0}},{"line":21,"address":[8481301],"length":1,"stats":{"Line":0}},{"line":22,"address":[9725136],"length":1,"stats":{"Line":0}},{"line":23,"address":[8481383],"length":1,"stats":{"Line":1}},{"line":24,"address":[8481426],"length":1,"stats":{"Line":0}},{"line":25,"address":[8481465],"length":1,"stats":{"Line":0}},{"line":26,"address":[8481505],"length":1,"stats":{"Line":0}},{"line":27,"address":[8481541],"length":1,"stats":{"Line":0}},{"line":28,"address":[8481575],"length":1,"stats":{"Line":0}},{"line":34,"address":[8481600],"length":1,"stats":{"Line":4}},{"line":42,"address":[8481741],"length":1,"stats":{"Line":4}},{"line":43,"address":[8481825],"length":1,"stats":{"Line":4}},{"line":44,"address":[8481907],"length":1,"stats":{"Line":4}},{"line":50,"address":[8481956],"length":1,"stats":{"Line":4}},{"line":52,"address":[9516350,9516336],"length":1,"stats":{"Line":8}},{"line":56,"address":[8482119],"length":1,"stats":{"Line":4}},{"line":59,"address":[9725937],"length":1,"stats":{"Line":4}},{"line":60,"address":[8482210],"length":1,"stats":{"Line":4}},{"line":62,"address":[8482241,8482572],"length":1,"stats":{"Line":8}},{"line":63,"address":[8482593],"length":1,"stats":{"Line":4}},{"line":65,"address":[9726367,9726578],"length":1,"stats":{"Line":5}},{"line":67,"address":[8482728],"length":1,"stats":{"Line":1}},{"line":68,"address":[9726480],"length":1,"stats":{"Line":1}},{"line":69,"address":[8482821],"length":1,"stats":{"Line":1}},{"line":74,"address":[8482685],"length":1,"stats":{"Line":3}},{"line":75,"address":[8482709,8482892],"length":1,"stats":{"Line":6}},{"line":76,"address":[9726644],"length":1,"stats":{"Line":1}},{"line":79,"address":[8482910],"length":1,"stats":{"Line":3}},{"line":81,"address":[8482919],"length":1,"stats":{"Line":4}},{"line":88,"address":[8482334],"length":1,"stats":{"Line":3}},{"line":90,"address":[9516416,9516430],"length":1,"stats":{"Line":8}},{"line":92,"address":[8482401],"length":1,"stats":{"Line":4}},{"line":94,"address":[8482529],"length":1,"stats":{"Line":4}}],"covered":27,"coverable":35},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","drawing","grid.rs"],"content":"//! Contains everything for depicting the grid onto the canvas.\n\nuse super::CanvasContext;\nuse crate::components::CanvasState;\n\n/// Draws the grid onto the canvas based on the given screen size and grid\n/// square size. This should be called before anything else is drawn, so the\n/// grid is in the background.\npub fn draw_grid(canvas: \u0026CanvasContext, state: CanvasState) {\n    canvas.begin_path();\n    canvas.set_line_width(0.3);\n    canvas.set_stroke_style_str(\"grey\");\n\n    let (height, width) = state.get_size();\n    let drawn_square_size = state.drawn_square_size();\n\n    draw_vertical_lines(\n        canvas,\n        height,\n        drawn_square_size,\n        f64::from(width) / drawn_square_size,\n    );\n    draw_horizontal_lines(\n        canvas,\n        width,\n        drawn_square_size,\n        f64::from(height) / drawn_square_size,\n    );\n\n    canvas.stroke();\n}\n\n/// Draw all vertical grid lines\nfn draw_vertical_lines(canvas: \u0026CanvasContext, length: u32, square_size: f64, count: f64) {\n    for i in 0..(count\n        .round()\n        .abs() as u32)\n    {\n        let x = f64::from(i) * square_size + square_size;\n        canvas.move_to(x, 0.0);\n        canvas.line_to(x, f64::from(length));\n    }\n}\n\n/// Draw all horizontal grid lines\nfn draw_horizontal_lines(canvas: \u0026CanvasContext, length: u32, square_size: f64, count: f64) {\n    for i in 0..(count\n        .round()\n        .abs() as u32)\n    {\n        let y = f64::from(i) * square_size + square_size;\n        canvas.move_to(0.0, y);\n        canvas.line_to(f64::from(length), y);\n    }\n}\n","traces":[{"line":9,"address":[7378384],"length":1,"stats":{"Line":0}},{"line":10,"address":[10215491],"length":1,"stats":{"Line":0}},{"line":11,"address":[10215527],"length":1,"stats":{"Line":0}},{"line":12,"address":[10215559],"length":1,"stats":{"Line":0}},{"line":14,"address":[10215590],"length":1,"stats":{"Line":0}},{"line":15,"address":[10215626],"length":1,"stats":{"Line":0}},{"line":21,"address":[10215674],"length":1,"stats":{"Line":0}},{"line":27,"address":[10215713],"length":1,"stats":{"Line":0}},{"line":30,"address":[10215727],"length":1,"stats":{"Line":0}},{"line":34,"address":[10215760],"length":1,"stats":{"Line":0}},{"line":35,"address":[7378647,7378744],"length":1,"stats":{"Line":0}},{"line":39,"address":[10215931],"length":1,"stats":{"Line":0}},{"line":40,"address":[10215951],"length":1,"stats":{"Line":0}},{"line":41,"address":[10215994,10216020],"length":1,"stats":{"Line":0}},{"line":46,"address":[10216032],"length":1,"stats":{"Line":0}},{"line":47,"address":[10216184,10216087],"length":1,"stats":{"Line":0}},{"line":51,"address":[10216203],"length":1,"stats":{"Line":0}},{"line":52,"address":[10216223],"length":1,"stats":{"Line":0}},{"line":53,"address":[10216266,10216292],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","drawing","mod.rs"],"content":"//! This module contains all functions for drawing the [`crate::models::Map`] to\n//! the canvas.\n\nmod canvas_context;\nmod closest_corner;\nmod draw_edge;\nmod grid;\nmod calc_direction;\n\npub use canvas_context::CanvasContext;\nuse closest_corner::calc_closest_corner;\npub use draw_edge::draw_edge;\nuse grid::draw_grid;\n\nuse crate::components::MapState;\n\n/// Redraws the given canvas based on the given state\npub fn redraw_canvas\u003c'a, C\u003e(canvas: C, state: \u0026MapState)\nwhere\n    C: Into\u003cCanvasContext\u003c'a\u003e\u003e,\n{\n    // Get a 2d canvas rendering context\n    let context: CanvasContext = canvas.into();\n\n    draw_grid(\u0026context, state.get_canvas_state());\n\n    let map = state.get_map();\n\n    map.draw(\u0026context, state.get_canvas_state());\n\n    state\n        .get_selected_station()\n        .inspect(|d| d.draw(map, \u0026context, state.get_canvas_state()));\n\n    state\n        .get_selected_line()\n        .inspect(|d| d.draw(map, \u0026context, state.get_canvas_state()));\n}\n","traces":[{"line":18,"address":[8485772,8485376],"length":1,"stats":{"Line":0}},{"line":23,"address":[8485410],"length":1,"stats":{"Line":0}},{"line":25,"address":[8485441,8485489],"length":1,"stats":{"Line":0}},{"line":27,"address":[8485515],"length":1,"stats":{"Line":0}},{"line":29,"address":[8485554],"length":1,"stats":{"Line":0}},{"line":31,"address":[8485592,8485652],"length":1,"stats":{"Line":0}},{"line":33,"address":[8485623,8485808,8485817],"length":1,"stats":{"Line":0}},{"line":35,"address":[8485734,8485676],"length":1,"stats":{"Line":0}},{"line":37,"address":[8485897,8485888,8485705],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","edge_dijkstra.rs"],"content":"//! Contains the implementation of the Dijkstra algorithm for tracing an edge\n//! between two sets of possible station locations.\n\nuse std::{\n    cmp::Reverse,\n    collections::{\n        HashMap,\n        HashSet,\n    },\n    hash::{\n        Hash,\n        Hasher,\n    },\n};\n\nuse ordered_float::NotNan;\nuse priority_queue::PriorityQueue;\n\nuse super::{\n    cost_calculation::calc_node_cost,\n    occupation::OccupiedNodes,\n    AlgorithmSettings,\n};\nuse crate::{\n    models::{\n        Edge,\n        GridNode,\n        Map,\n        Station,\n    },\n    utils::Result,\n    Error,\n};\n\n/// Holds the state for an item in the Dijkstra algorithm queue.\n#[derive(Clone, Debug)]\nstruct QueueItem {\n    /// The current node.\n    node: GridNode,\n    /// The path to the current node.\n    path: Vec\u003cGridNode\u003e,\n    /// The cost of the path so far.\n    cost: NotNan\u003cf64\u003e,\n}\n\nimpl QueueItem {\n    /// Create a new [`QueueItem`] with the given node as the start of the path.\n    fn new(node: GridNode, cost: NotNan\u003cf64\u003e) -\u003e Self {\n        Self {\n            node,\n            path: Vec::new(),\n            cost,\n        }\n    }\n\n    /// Create a new [`QueueItem`] that grows from the given previous item.\n    fn from_parent(parent: \u0026QueueItem, node: GridNode, cost: NotNan\u003cf64\u003e) -\u003e Self {\n        let mut new = Self {\n            node,\n            path: parent\n                .path\n                .clone(),\n            cost: parent.cost + cost,\n        };\n        new.path\n            .push(parent.node);\n        new\n    }\n}\n\n/// The equality only depends on the current node.\nimpl PartialEq for QueueItem {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.node == other.node\n    }\n}\n\nimpl Eq for QueueItem {}\n\n/// The hash only depends on the current node.\nimpl Hash for QueueItem {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.node\n            .hash(state);\n    }\n}\n\n/// A Dijkstra implementation that finds the shortest path between two start and\n/// end node sets. This is the Edge Dijkstra algorithm in the paper.\npub fn edge_dijkstra(\n    settings: AlgorithmSettings,\n    map: \u0026Map,\n    edge: \u0026Edge,\n    from: \u0026[(GridNode, f64)],\n    from_station: \u0026Station,\n    to: \u0026[(GridNode, f64)],\n    to_station: \u0026Station,\n    occupied: \u0026OccupiedNodes,\n) -\u003e Result\u003c(\n    GridNode,\n    Vec\u003cGridNode\u003e,\n    GridNode,\n    NotNan\u003cf64\u003e,\n)\u003e {\n    let mut queue = PriorityQueue::new();\n    let mut visited = HashSet::new();\n    let mut to_visited = Vec::new();\n    let to_nodes = to\n        .iter()\n        .copied()\n        .collect::\u003cHashMap\u003cGridNode, f64\u003e\u003e();\n\n    for (node, cost) in from {\n        // FIXME: the cost is dependent upon the distance from the original station\n        // location.\n        queue.push(\n            QueueItem::new(*node, NotNan::new(*cost)?),\n            Reverse(NotNan::new(*cost)?),\n        );\n    }\n\n    while let Some((current, current_cost)) = queue.pop() {\n        visited.insert(current.node);\n\n        if current_cost\n            .0\n            .is_infinite()\n        {\n            break;\n        }\n\n        // Check if the current node is in the to_nodes set and if so, add it to the\n        // list of to_nodes we have visited so far. We are done once we have visited all\n        // to_nodes.\n        if let Some(to_cost) = to_nodes.get(\u0026current.node) {\n            to_visited.push((current.clone(), current.cost + to_cost));\n            if to_visited.len() == to_nodes.len() {\n                break;\n            }\n        }\n\n        // The up-to two last nodes in the path so far.\n        let previous = \u0026current\n            .path\n            .last()\n            .map_or(vec![current.node], |p| {\n                vec![*p, current.node]\n            });\n\n        for neighbor in current\n            .node\n            .get_neighbors()\n        {\n            if visited.contains(\u0026neighbor) {\n                continue;\n            }\n\n            // Calculate the cost of the node and enforce it's not NaN.\n            let cost = NotNan::new(calc_node_cost(\n                settings,\n                map,\n                edge,\n                neighbor,\n                previous,\n                from_station,\n                to_station,\n                occupied,\n            )?)?;\n\n            // Don't even look at nodes that have infinite cost.\n            // CHECKME: this is a bit of a hack, we should probably add them to the queue\n            // and handle the break when we encounter the first, but this causes\n            // a bug?\n            if cost.is_infinite() {\n                continue;\n            }\n\n            // Add the heuristic cost to the cost for the queue.\n            let cost_with_heuristic = cost + neighbor.diagonal_distance_to(from_station.get_pos());\n\n            let neighbor_item = QueueItem::from_parent(\u0026current, neighbor, cost);\n            if let Some((_, old_cost)) = queue.get(\u0026neighbor_item) {\n                if old_cost.0 \u003e cost_with_heuristic {\n                    queue.push(\n                        neighbor_item,\n                        Reverse(cost_with_heuristic),\n                    );\n                }\n            } else {\n                queue.push(\n                    neighbor_item,\n                    Reverse(cost_with_heuristic),\n                );\n            }\n        }\n    }\n\n    if to_visited.is_empty() {\n        return Err(Error::other(format!(\n            \"No path found between {} and {}.\",\n            from_station.get_id(),\n            to_station.get_id()\n        )));\n    }\n\n    // Get the cheapest path found.\n    let mut best = to_visited\n        .into_iter()\n        .min_by_key(|(_, c)| *c)\n        .unwrap()\n        .0;\n\n    // Removes the first node from the path as this is the starting station location\n    let start = if best\n        .path\n        .is_empty()\n    {\n        return Err(Error::other(format!(\n            \"Path is empty, start and end are equal on edge {} from {} to {}\",\n            edge.get_id(),\n            from_station.get_id(),\n            to_station.get_id()\n        )));\n    } else {\n        best.path\n            .drain(..1)\n            .next()\n            .expect(\"path is empty\")\n    };\n\n    Ok((start, best.path, best.node, best.cost))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // More of a sanity check for the algorithm\n    #[test]\n    fn test_edge_dijkstra() {\n        let mut map = Map::new();\n        let occupied = HashMap::new();\n        let from_station = Station::new(GridNode::from((0, 0)), None);\n        let from_nodes = vec![(from_station.get_pos(), 0.0)];\n        let to_station = Station::new(GridNode::from((8, 4)), None);\n        let to_nodes = vec![\n            (GridNode::from((7, 4)), 1.0),\n            (to_station.get_pos(), 0.0),\n            (GridNode::from((9, 4)), 1.0),\n        ];\n        let edge = Edge::new(\n            from_station.get_id(),\n            to_station.get_id(),\n            None,\n        );\n\n        map.add_station(from_station.clone());\n        map.add_station(to_station.clone());\n        map.add_edge(edge.clone());\n        map.quickcalc_edges();\n\n        let result = edge_dijkstra(\n            AlgorithmSettings::default(),\n            \u0026map,\n            \u0026edge,\n            \u0026from_nodes,\n            \u0026from_station,\n            \u0026to_nodes,\n            \u0026to_station,\n            \u0026occupied,\n        )\n        .unwrap();\n\n        assert_eq!(\n            (result.0, result.1, result.2),\n            (\n                GridNode::from((0, 0)),\n                vec![\n                    GridNode::from((1, 0)),\n                    GridNode::from((2, 0)),\n                    GridNode::from((3, 0)),\n                    GridNode::from((4, 1)),\n                    GridNode::from((5, 2)),\n                    GridNode::from((6, 3))\n                ],\n                GridNode::from((7, 4))\n            )\n        );\n    }\n}\n","traces":[{"line":48,"address":[9463472],"length":1,"stats":{"Line":1}},{"line":51,"address":[9463513],"length":1,"stats":{"Line":1}},{"line":57,"address":[8986160,8986450],"length":1,"stats":{"Line":1}},{"line":60,"address":[8986217],"length":1,"stats":{"Line":1}},{"line":63,"address":[8986242],"length":1,"stats":{"Line":1}},{"line":65,"address":[8986363],"length":1,"stats":{"Line":1}},{"line":66,"address":[8986357],"length":1,"stats":{"Line":1}},{"line":67,"address":[8986422],"length":1,"stats":{"Line":1}},{"line":73,"address":[9463904],"length":1,"stats":{"Line":1}},{"line":74,"address":[9463918],"length":1,"stats":{"Line":1}},{"line":82,"address":[9138208],"length":1,"stats":{"Line":1}},{"line":83,"address":[7702638],"length":1,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[8988150,8992774,8986528],"length":1,"stats":{"Line":1}},{"line":105,"address":[8986742],"length":1,"stats":{"Line":1}},{"line":106,"address":[9464219],"length":1,"stats":{"Line":1}},{"line":107,"address":[9464274],"length":1,"stats":{"Line":1}},{"line":108,"address":[9464334,9464419],"length":1,"stats":{"Line":2}},{"line":113,"address":[8992605,8987184,8987097,8987299],"length":1,"stats":{"Line":4}},{"line":116,"address":[8992536],"length":1,"stats":{"Line":1}},{"line":117,"address":[8992226,8987346],"length":1,"stats":{"Line":2}},{"line":118,"address":[8992457,8992379,8992579],"length":1,"stats":{"Line":2}},{"line":122,"address":[9464668,9464777,9466067],"length":1,"stats":{"Line":3}},{"line":123,"address":[8987518],"length":1,"stats":{"Line":1}},{"line":125,"address":[8987639],"length":1,"stats":{"Line":1}},{"line":135,"address":[8987770,8987705],"length":1,"stats":{"Line":2}},{"line":136,"address":[8987847,8987900],"length":1,"stats":{"Line":2}},{"line":137,"address":[8988066],"length":1,"stats":{"Line":1}},{"line":143,"address":[8988175,8988361,8987854],"length":1,"stats":{"Line":3}},{"line":146,"address":[9138240],"length":1,"stats":{"Line":2}},{"line":147,"address":[9138269,9138400],"length":1,"stats":{"Line":1}},{"line":150,"address":[8988404,8988481,8988643,8990055,8988675],"length":1,"stats":{"Line":5}},{"line":154,"address":[8988703,8988795],"length":1,"stats":{"Line":2}},{"line":159,"address":[9467329,9466624,9466184,9466446,9467346],"length":1,"stats":{"Line":1}},{"line":164,"address":[8988805],"length":1,"stats":{"Line":1}},{"line":174,"address":[9466649,9466601],"length":1,"stats":{"Line":2}},{"line":179,"address":[8989432],"length":1,"stats":{"Line":1}},{"line":181,"address":[8989575],"length":1,"stats":{"Line":1}},{"line":182,"address":[8989747,8989647],"length":1,"stats":{"Line":2}},{"line":183,"address":[8989808,8989933],"length":1,"stats":{"Line":2}},{"line":184,"address":[8990016],"length":1,"stats":{"Line":1}},{"line":185,"address":[8989951],"length":1,"stats":{"Line":1}},{"line":186,"address":[9467247],"length":1,"stats":{"Line":1}},{"line":190,"address":[8989899,8990045],"length":1,"stats":{"Line":2}},{"line":191,"address":[8989834],"length":1,"stats":{"Line":1}},{"line":192,"address":[9467134],"length":1,"stats":{"Line":1}},{"line":198,"address":[8990210,8990262],"length":1,"stats":{"Line":2}},{"line":199,"address":[8992014,8992151],"length":1,"stats":{"Line":0}},{"line":201,"address":[8990343,8991753],"length":1,"stats":{"Line":0}},{"line":202,"address":[9469030],"length":1,"stats":{"Line":0}},{"line":207,"address":[9467657,9467472,9467577],"length":1,"stats":{"Line":3}},{"line":209,"address":[9138442,9138432],"length":1,"stats":{"Line":2}},{"line":214,"address":[9467774,9467713],"length":1,"stats":{"Line":2}},{"line":218,"address":[8991488,8991641],"length":1,"stats":{"Line":0}},{"line":220,"address":[8991084,8990632],"length":1,"stats":{"Line":0}},{"line":221,"address":[8991210],"length":1,"stats":{"Line":0}},{"line":222,"address":[8991353],"length":1,"stats":{"Line":0}},{"line":225,"address":[8990721,8990592,8990650],"length":1,"stats":{"Line":3}},{"line":231,"address":[8990836],"length":1,"stats":{"Line":1}}],"covered":51,"coverable":59},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","local_search.rs"],"content":"//! Contains the local search algorithm for optimising the location of a\n//! station.\n\nuse ordered_float::NotNan;\n\nuse super::{\n    debug_print,\n    edge_dijkstra::edge_dijkstra,\n    occupation::OccupiedNodes,\n    AlgorithmSettings,\n};\nuse crate::{\n    models::{\n        Edge,\n        GridNode,\n        Map,\n        Station,\n    },\n    utils::Result,\n    Error,\n};\n\n/// Represents a station position with its edges and cost.\nstruct StationPos {\n    /// The station at this position.\n    station: Station,\n    /// The edges connected to the station.\n    edges: Vec\u003cEdge\u003e,\n    /// The nodes occupied by map once this station and its edges have been\n    /// taken into account.\n    occupied: OccupiedNodes,\n    /// The total cost of the station and its edges.\n    cost: NotNan\u003cf64\u003e,\n}\n\nimpl StationPos {\n    /// Create a new [`StationPos`] with the given data.\n    fn new(station: Station, edges: Vec\u003cEdge\u003e, occupied: OccupiedNodes, cost: NotNan\u003cf64\u003e) -\u003e Self {\n        Self {\n            station,\n            edges,\n            occupied,\n            cost,\n        }\n    }\n}\n\n/// Calculate the total manhattan distance of a point to all neighboring\n/// stations of the given station.\nfn total_distance(map: \u0026Map, node: GridNode, station: \u0026Station) -\u003e i32 {\n    station\n        .get_edges()\n        .iter()\n        .map(|id| {\n            map.get_edge(*id)\n                .expect(\"edge attached to station does not exist\")\n                .opposite(station.get_id())\n                .expect(\"station does not have opposite\")\n        })\n        .map(|id| {\n            let neighbor = map\n                .get_station(id)\n                .expect(\"opposite station does not exist\");\n            node.manhattan_distance_to(neighbor.get_pos())\n        })\n        .sum()\n}\n\n/// Try a new position for the given station and return data on the result.\nfn try_station_pos(\n    settings: AlgorithmSettings,\n    map: \u0026Map,\n    mut target_station: Station,\n    station_pos: GridNode,\n    mut occupied: OccupiedNodes,\n) -\u003e Result\u003cStationPos\u003e {\n    if occupied.contains_key(\u0026station_pos) {\n        return Err(Error::EarlyAbort);\n    }\n\n    let mut map = map.clone();\n\n    occupied.remove(\u0026target_station.get_pos());\n    target_station.set_pos(station_pos);\n    occupied.insert(\n        station_pos,\n        target_station\n            .get_id()\n            .into(),\n    );\n    map.add_station(target_station.clone());\n\n    let mut total_cost = NotNan::new(0.0).unwrap();\n    let mut edges_before = Vec::new();\n    let mut edges_after = Vec::new();\n\n    for edge_id in target_station.get_edges() {\n        let edge = map\n            .get_mut_edge(*edge_id)\n            .ok_or(Error::other(\n                \"edge of station not found\",\n            ))?;\n        for node in edge.get_nodes() {\n            occupied.remove(node);\n        }\n        edge.unsettle();\n        edges_before.push(edge.clone());\n    }\n\n    for mut edge in edges_before {\n        let from_station = map\n            .get_station(edge.get_from())\n            .ok_or(Error::other(\n                \"from-station of edge not found\",\n            ))?;\n        let to_station = map\n            .get_station(edge.get_to())\n            .ok_or(Error::other(\n                \"to-station of edge not found\",\n            ))?;\n\n        let from = vec![(from_station.get_pos(), 0.0)];\n        let to = vec![(to_station.get_pos(), 0.0)];\n\n        let (_, nodes, _, cost) = edge_dijkstra(\n            settings,\n            \u0026map,\n            \u0026edge,\n            \u0026from,\n            from_station,\n            \u0026to,\n            to_station,\n            \u0026occupied,\n        )?;\n\n        occupied.extend(\n            nodes\n                .iter()\n                .map(|n| {\n                    (\n                        *n,\n                        edge.get_id()\n                            .into(),\n                    )\n                }),\n        );\n        edge.set_nodes(nodes);\n        map.add_edge(edge.clone());\n        edges_after.push(edge);\n\n        total_cost += cost;\n        if *total_cost \u003e= target_station.get_cost() {\n            return Err(Error::EarlyAbort);\n        }\n    }\n\n    Ok(StationPos::new(\n        target_station,\n        edges_after,\n        occupied,\n        total_cost,\n    ))\n}\n\n/// Perform a local search on the map.\n/// This will try to find a better position for each station.\n/// This is the Local Search algorithm in the paper.\n/// FIXME: This implementation is very slow\npub fn local_search(settings: AlgorithmSettings, map: \u0026mut Map, occupied: \u0026mut OccupiedNodes) {\n    let all_stations = map\n        .get_stations()\n        .into_iter()\n        .cloned()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    for station in all_stations {\n        if station\n            .get_edges()\n            .is_empty()\n        {\n            continue;\n        }\n        if station.is_locked() {\n            continue;\n        }\n\n        let mut neighborhood = station\n            .get_pos()\n            .get_neighbors();\n\n        neighborhood.sort_by(|a, b| {\n            total_distance(map, *a, \u0026station).cmp(\u0026total_distance(map, *b, \u0026station))\n        });\n\n        let mut best = None;\n\n        'neighborhood: for node in neighborhood\n            .into_iter()\n            .take(4)\n        {\n            if let Ok(station_pos) = try_station_pos(\n                settings,\n                map,\n                station.clone(),\n                node,\n                occupied.clone(),\n            ) {\n                if *station_pos.cost \u003c station.get_cost() {\n                    best = Some(station_pos);\n                    break 'neighborhood;\n                }\n            }\n        }\n\n        if best.is_none() {\n            continue; // CHECKME: we should implement an iterative checking\n                      // maybe\n        }\n\n        debug_print(\n            settings,\n            \u0026format!(\n                \"Moving station {} from {} to {}\",\n                station.get_id(),\n                station.get_pos(),\n                best.as_ref()\n                    .unwrap()\n                    .station\n                    .get_pos()\n            ),\n            false,\n        );\n\n        let best = best.unwrap();\n        map.add_station(best.station);\n        for edge in best.edges {\n            map.add_edge(edge);\n        }\n        *occupied = best.occupied;\n    }\n}\n","traces":[{"line":38,"address":[10145888],"length":1,"stats":{"Line":0}},{"line":50,"address":[8975312],"length":1,"stats":{"Line":0}},{"line":51,"address":[8975363],"length":1,"stats":{"Line":0}},{"line":54,"address":[8168208],"length":1,"stats":{"Line":0}},{"line":55,"address":[8168294,8168227],"length":1,"stats":{"Line":0}},{"line":57,"address":[8168277],"length":1,"stats":{"Line":0}},{"line":60,"address":[8168336],"length":1,"stats":{"Line":0}},{"line":61,"address":[8168355],"length":1,"stats":{"Line":0}},{"line":64,"address":[9736243],"length":1,"stats":{"Line":0}},{"line":70,"address":[8975456,8979908,8980740],"length":1,"stats":{"Line":0}},{"line":77,"address":[8975543,8975681],"length":1,"stats":{"Line":0}},{"line":78,"address":[8975718],"length":1,"stats":{"Line":0}},{"line":81,"address":[10146419],"length":1,"stats":{"Line":0}},{"line":83,"address":[8975782,8975901],"length":1,"stats":{"Line":0}},{"line":84,"address":[8975942],"length":1,"stats":{"Line":0}},{"line":85,"address":[8976056],"length":1,"stats":{"Line":0}},{"line":87,"address":[8975975],"length":1,"stats":{"Line":0}},{"line":91,"address":[8976097],"length":1,"stats":{"Line":0}},{"line":93,"address":[8976131,8976345],"length":1,"stats":{"Line":0}},{"line":94,"address":[8976354],"length":1,"stats":{"Line":0}},{"line":95,"address":[8976373],"length":1,"stats":{"Line":0}},{"line":97,"address":[8976736,8976449,8976538],"length":1,"stats":{"Line":0}},{"line":98,"address":[8980536,8976755,8980083,8980276],"length":1,"stats":{"Line":0}},{"line":99,"address":[8976752],"length":1,"stats":{"Line":0}},{"line":100,"address":[8980044],"length":1,"stats":{"Line":0}},{"line":103,"address":[8980315,8980452,8980183],"length":1,"stats":{"Line":0}},{"line":104,"address":[8980468,8980531],"length":1,"stats":{"Line":0}},{"line":106,"address":[8980433],"length":1,"stats":{"Line":0}},{"line":107,"address":[8980492],"length":1,"stats":{"Line":0}},{"line":110,"address":[8976920,8976785,8976669,8979862,8976977],"length":1,"stats":{"Line":0}},{"line":111,"address":[8977479,8977743,8977545,8979952],"length":1,"stats":{"Line":0}},{"line":112,"address":[8977105],"length":1,"stats":{"Line":0}},{"line":113,"address":[8977506],"length":1,"stats":{"Line":0}},{"line":116,"address":[8978046,8977846,8979950,8977780],"length":1,"stats":{"Line":0}},{"line":117,"address":[8977656],"length":1,"stats":{"Line":0}},{"line":118,"address":[8977807],"length":1,"stats":{"Line":0}},{"line":122,"address":[8977959,8978091],"length":1,"stats":{"Line":0}},{"line":123,"address":[8978320,8978395],"length":1,"stats":{"Line":0}},{"line":129,"address":[8978611],"length":1,"stats":{"Line":0}},{"line":131,"address":[8978722],"length":1,"stats":{"Line":0}},{"line":136,"address":[8979350],"length":1,"stats":{"Line":0}},{"line":137,"address":[8979284,8979088],"length":1,"stats":{"Line":0}},{"line":139,"address":[8168464],"length":1,"stats":{"Line":0}},{"line":141,"address":[9736328],"length":1,"stats":{"Line":0}},{"line":142,"address":[9736340],"length":1,"stats":{"Line":0}},{"line":147,"address":[10149921],"length":1,"stats":{"Line":0}},{"line":148,"address":[10150000],"length":1,"stats":{"Line":0}},{"line":149,"address":[8979486],"length":1,"stats":{"Line":0}},{"line":151,"address":[10150190],"length":1,"stats":{"Line":0}},{"line":152,"address":[8979661],"length":1,"stats":{"Line":0}},{"line":153,"address":[8979774],"length":1,"stats":{"Line":0}},{"line":157,"address":[8977342],"length":1,"stats":{"Line":0}},{"line":158,"address":[10147791],"length":1,"stats":{"Line":0}},{"line":159,"address":[10147870],"length":1,"stats":{"Line":0}},{"line":160,"address":[10147910],"length":1,"stats":{"Line":0}},{"line":161,"address":[8977301],"length":1,"stats":{"Line":0}},{"line":169,"address":[10155196,10154973,10151200],"length":1,"stats":{"Line":0}},{"line":170,"address":[8980831],"length":1,"stats":{"Line":0}},{"line":176,"address":[10151379,10151527,10151583],"length":1,"stats":{"Line":0}},{"line":177,"address":[8981277,8981372],"length":1,"stats":{"Line":0}},{"line":183,"address":[10151840,10151801],"length":1,"stats":{"Line":0}},{"line":187,"address":[8981468],"length":1,"stats":{"Line":0}},{"line":191,"address":[8981630,8981530],"length":1,"stats":{"Line":0}},{"line":192,"address":[9736451],"length":1,"stats":{"Line":0}},{"line":195,"address":[8981649],"length":1,"stats":{"Line":0}},{"line":197,"address":[8981675,8981783,8984856,8981974,8981939],"length":1,"stats":{"Line":0}},{"line":204,"address":[8982026],"length":1,"stats":{"Line":0}},{"line":206,"address":[8982049],"length":1,"stats":{"Line":0}},{"line":208,"address":[8982434,8982320],"length":1,"stats":{"Line":0}},{"line":209,"address":[8982684,8982505],"length":1,"stats":{"Line":0}},{"line":215,"address":[8982854],"length":1,"stats":{"Line":0}},{"line":222,"address":[10153937,10153776],"length":1,"stats":{"Line":0}},{"line":224,"address":[8982895,8982934],"length":1,"stats":{"Line":0}},{"line":225,"address":[10153382],"length":1,"stats":{"Line":0}},{"line":226,"address":[8983207,8983311],"length":1,"stats":{"Line":0}},{"line":234,"address":[8983769,8983884],"length":1,"stats":{"Line":0}},{"line":235,"address":[8983900],"length":1,"stats":{"Line":0}},{"line":236,"address":[8984323,8984258,8984056],"length":1,"stats":{"Line":0}},{"line":237,"address":[8984435,8984682],"length":1,"stats":{"Line":0}},{"line":239,"address":[8984465],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":80},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","mod.rs"],"content":"//! Contains all methods involving the map algorithm itself and drawing the map\n//! to the canvas.\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nmod a_star;\nmod cost_calculation;\npub mod drawing;\nmod edge_dijkstra;\nmod local_search;\nmod occupation;\nmod order_edges;\nmod recalculate_map;\nmod route_edges;\nmod station_contraction;\nmod utils;\n\npub use a_star::run_a_star;\npub use recalculate_map::recalculate_map;\nuse utils::*;\n\n/// Stores the settings for the algorithm.\n#[derive(Clone, Copy, Debug, Serialize, Deserialize)]\npub struct AlgorithmSettings {\n    /// The size of the radius around a station to possibly route edges to for\n    /// the possible new station location.\n    /// Default: 3\n    pub node_set_radius: i32,\n    /// Max amount of attempts allowed of routing edges before erroring out.\n    /// Default: 5\n    pub edge_routing_attempts: usize,\n    /// The cost of moving from one node to another.\n    pub move_cost: f64,\n    /// The highest and lowest possible x values of the grid.\n    pub grid_x_limits: (i32, i32),\n    /// The highest and lowest possible y values of the grid.\n    pub grid_y_limits: (i32, i32),\n    /// Whether to print debug information.\n    pub debug: bool,\n    /// Whether to run the local search algorithm.\n    pub local_search: bool,\n    /// Whether to allow stations to move (off is the same as nose_set_radius\n    /// being 0).\n    pub allow_station_relocation: bool,\n}\n\nimpl AlgorithmSettings {\n    /// Set the highest and lowest possible x values of the grid.\n    pub fn set_grid_x_limits(mut self, x_limits: (i32, i32)) -\u003e Self {\n        self.grid_x_limits = x_limits;\n        self\n    }\n\n    /// Set the highest and lowest possible y values of the grid.\n    pub fn set_grid_y_limits(mut self, y_limits: (i32, i32)) -\u003e Self {\n        self.grid_y_limits = y_limits;\n        self\n    }\n\n    /// Toggle the debug mode.\n    pub fn toggle_debug(mut self) -\u003e Self {\n        self.debug = !self.debug;\n        self\n    }\n}\n\nimpl Default for AlgorithmSettings {\n    fn default() -\u003e Self {\n        Self {\n            node_set_radius: 3,\n            edge_routing_attempts: 3,\n            move_cost: 1.0,\n            debug: false,\n            grid_x_limits: (i32::MIN, i32::MAX),\n            grid_y_limits: (i32::MIN, i32::MAX),\n            local_search: true,\n            allow_station_relocation: true,\n        }\n    }\n}\n","traces":[{"line":51,"address":[8483840],"length":1,"stats":{"Line":0}},{"line":52,"address":[8483860],"length":1,"stats":{"Line":0}},{"line":53,"address":[8483866],"length":1,"stats":{"Line":0}},{"line":57,"address":[8483888],"length":1,"stats":{"Line":0}},{"line":58,"address":[8483908],"length":1,"stats":{"Line":0}},{"line":59,"address":[8483914],"length":1,"stats":{"Line":0}},{"line":63,"address":[8483936],"length":1,"stats":{"Line":0}},{"line":64,"address":[8483944],"length":1,"stats":{"Line":0}},{"line":65,"address":[8483954],"length":1,"stats":{"Line":0}},{"line":70,"address":[8483984],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":10},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","occupation.rs"],"content":"//! Contains the data structure for specifying what is currently occupying a\n//! node on the map.\n\nuse std::collections::HashMap;\n\nuse crate::models::{\n    EdgeID,\n    GridNode,\n    StationID,\n};\n\n/// A map of grid nodes to the contents of the node, listing all nodes currently\n/// occupied on the map.\npub type OccupiedNodes = HashMap\u003cGridNode, OccupiedNode\u003e;\n\n/// Describes the contents of an occupied node of the map grid.\n/// Either shows the node occupied by a station or by an edge.\n#[derive(Debug, Clone, Copy)]\npub enum OccupiedNode {\n    /// The node is occupied by a station.\n    Station(StationID),\n    /// The node is occupied by an edge.\n    Edge(EdgeID),\n}\n\nimpl OccupiedNode {\n    /// Get the ID of the edge if the node is occupied by an edge, else returns\n    /// None.\n    pub fn get_edge_id(\u0026self) -\u003e Option\u003cEdgeID\u003e {\n        match self {\n            Self::Edge(e) =\u003e Some(*e),\n            Self::Station(_) =\u003e None,\n        }\n    }\n\n    /// Get the ID of the station if the node is occupied by a station, else\n    /// returns None.\n    pub fn get_station_id(\u0026self) -\u003e Option\u003cStationID\u003e {\n        match self {\n            Self::Station(s) =\u003e Some(*s),\n            Self::Edge(_) =\u003e None,\n        }\n    }\n}\n\nimpl PartialEq for OccupiedNode {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Self::Station(a), Self::Station(b)) =\u003e a == b,\n            (Self::Edge(a), Self::Edge(b)) =\u003e a == b,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl From\u003cStationID\u003e for OccupiedNode {\n    fn from(id: StationID) -\u003e Self {\n        Self::Station(id)\n    }\n}\n\nimpl From\u003cEdgeID\u003e for OccupiedNode {\n    fn from(id: EdgeID) -\u003e Self {\n        Self::Edge(id)\n    }\n}\n","traces":[{"line":29,"address":[9561776],"length":1,"stats":{"Line":1}},{"line":30,"address":[9734154],"length":1,"stats":{"Line":1}},{"line":31,"address":[9734176],"length":1,"stats":{"Line":1}},{"line":32,"address":[9734160],"length":1,"stats":{"Line":0}},{"line":38,"address":[9734224],"length":1,"stats":{"Line":1}},{"line":39,"address":[9734234],"length":1,"stats":{"Line":1}},{"line":40,"address":[9734245],"length":1,"stats":{"Line":1}},{"line":41,"address":[9734277],"length":1,"stats":{"Line":1}},{"line":47,"address":[9734304],"length":1,"stats":{"Line":1}},{"line":48,"address":[9734318],"length":1,"stats":{"Line":1}},{"line":49,"address":[9734365],"length":1,"stats":{"Line":0}},{"line":50,"address":[9734433],"length":1,"stats":{"Line":1}},{"line":51,"address":[9734417],"length":1,"stats":{"Line":1}},{"line":57,"address":[9734496],"length":1,"stats":{"Line":1}},{"line":58,"address":[9734501],"length":1,"stats":{"Line":1}},{"line":63,"address":[9734528],"length":1,"stats":{"Line":1}},{"line":64,"address":[9734533],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":17},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","order_edges.rs"],"content":"//! This module contains the implementation of the Order Edges algorithm and the\n//! tools to calculate the degree of a line used for it.\n\nuse std::collections::{\n    BinaryHeap,\n    HashMap,\n};\n\nuse crate::{\n    models::{\n        Edge,\n        Map,\n        Station,\n        StationID,\n    },\n    utils::Result,\n    Error,\n};\n\n/// Calculate the line degree of the given station.\n/// This is the Line Degree algorithm in the paper.\nfn line_degree(map: \u0026Map, station_id: StationID) -\u003e Result\u003cusize\u003e {\n    let mut degree = 0;\n\n    let station = map\n        .get_station(station_id)\n        .ok_or(Error::other(format!(\n            \"station {station_id} not found when calculating line degree\"\n        )))?;\n\n    for edge_id in station.get_edges() {\n        let edge = map\n            .get_edge(*edge_id)\n            .ok_or(Error::other(\n                \"edge connected to station not found\",\n            ))?;\n\n        degree += edge\n            .get_lines()\n            .len();\n    }\n\n    Ok(degree)\n}\n\n/// The id of a station together with its degree, used in the binary heap.\n#[derive(Clone, Copy, Eq, PartialEq)]\nstruct HeapStation {\n    /// The id of the station.\n    station: StationID,\n    /// The line degree of the station.\n    degree: usize,\n}\n\nimpl HeapStation {\n    /// Create a new [`HeapStation`] with the given station id and degree.\n    fn new(station: StationID, degree: usize) -\u003e Self {\n        Self {\n            station,\n            degree,\n        }\n    }\n}\n\nimpl PartialOrd for HeapStation {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        Some(\n            self.degree\n                .cmp(\u0026other.degree),\n        )\n    }\n}\n\nimpl Ord for HeapStation {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        other\n            .degree\n            .cmp(\u0026self.degree)\n    }\n}\n\n/// Calculate the line degree of all stations and return them in a hashmap, also\n/// return the station with the highest degree.\nfn calc_all_degrees(\n    map: \u0026Map,\n) -\u003e Result\u003c(\n    HashMap\u003cStationID, HeapStation\u003e,\n    HeapStation,\n)\u003e {\n    let mut stations = HashMap::new();\n    let mut highest = HeapStation::new(0.into(), usize::MIN);\n\n    for station_id in map\n        .get_stations()\n        .into_iter()\n        .map(Station::get_id)\n    {\n        let degree = line_degree(map, station_id)?;\n        stations.insert(\n            station_id,\n            HeapStation::new(station_id, degree),\n        );\n\n        if degree \u003e highest.degree {\n            highest = HeapStation::new(station_id, degree);\n        }\n    }\n\n    Ok((stations, highest))\n}\n\n/// Order the edges in the map by the line degree of the stations they are\n/// connected to. This is the Order Edges algorithm in the paper.\npub fn order_edges(map: \u0026Map) -\u003e Result\u003cVec\u003cEdge\u003e\u003e {\n    let (mut line_degree_map, mut highest) = calc_all_degrees(map)?;\n\n    let mut edges = Vec::new();\n    while map\n        .get_edges()\n        .len()\n        \u003e edges.len()\n    {\n        edges.append(\u0026mut order_edges_alg(\n            map,\n            \u0026line_degree_map,\n            highest,\n        )?);\n\n        // If there are still edges left, then there are disjoint parts of the map\n        if map\n            .get_edges()\n            .len()\n            \u003e edges.len()\n        {\n            // Remove the stations that are connected to edges that were already dealt with\n            // and calculate the new highest among the remaining stations\n            for edge in \u0026edges {\n                line_degree_map.remove(\u0026edge.get_from());\n                line_degree_map.remove(\u0026edge.get_to());\n            }\n            highest = HeapStation::new(0.into(), usize::MIN);\n            for station in line_degree_map.values() {\n                if station.degree \u003e highest.degree {\n                    highest = *station;\n                }\n            }\n        }\n    }\n\n    Ok(edges)\n}\n\n/// The underlying algorithm for ordering the edges.\nfn order_edges_alg(\n    map: \u0026Map,\n    line_degree_map: \u0026HashMap\u003cStationID, HeapStation\u003e,\n    start: HeapStation,\n) -\u003e Result\u003cVec\u003cEdge\u003e\u003e {\n    let mut edges = Vec::new();\n    let mut queue = BinaryHeap::new();\n\n    queue.push(start);\n\n    while let Some(station_with_degree) = queue.pop() {\n        let station = map\n            .get_station(station_with_degree.station)\n            .ok_or(Error::other(\n                \"station not found when ordering edges\",\n            ))?;\n\n        let mut station_edges = Vec::new();\n\n        for edge_id in station.get_edges() {\n            let edge = map\n                .get_edge(*edge_id)\n                .ok_or(Error::other(\n                    \"edge connected to station not found\",\n                ))?;\n\n            if !edges.contains(edge) {\n                let opposite_id = edge\n                    .opposite(station.get_id())\n                    .ok_or(Error::other(\n                        \"station not found on edge that it thought it was on\",\n                    ))?;\n\n                let neighbor = line_degree_map\n                    .get(\u0026opposite_id)\n                    .ok_or(Error::other(\n                        \"station not found in line degree map\",\n                    ))?;\n\n                station_edges.push((edge.clone(), neighbor));\n                queue.push(*neighbor);\n            }\n        }\n\n        // Sort the edges by the degree of the opposite in descending order\n        station_edges.sort_unstable_by(|a, b| {\n            b.1.degree\n                .cmp(\u0026a.1.degree)\n        });\n\n        edges.append(\n            \u0026mut station_edges\n                .into_iter()\n                .map(|(edge, _)| edge)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n        );\n    }\n\n    Ok(edges)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        models::EdgeID,\n        utils::json,\n        CanvasState,\n    };\n\n    #[test]\n    fn test_order_edges() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let test_file_content = std::fs::read_to_string(\"existing_maps/routing_test.json\")\n            .expect(\"test data file does not exist\");\n        let map = json::decode_map(\u0026test_file_content, canvas).expect(\"failed to decode graphml\");\n\n        let edge1_id = map\n            .get_edge_id_between_if_exists(5.into(), 4.into())\n            .unwrap();\n        let edge2_id = map\n            .get_edge_id_between_if_exists(5.into(), 9.into())\n            .unwrap();\n        let edge3_id = map\n            .get_edge_id_between_if_exists(5.into(), 3.into())\n            .unwrap();\n        let edge4_id = map\n            .get_edge_id_between_if_exists(5.into(), 6.into())\n            .unwrap();\n        let edge5_id = map\n            .get_edge_id_between_if_exists(4.into(), 8.into())\n            .unwrap();\n        let edge6_id = map\n            .get_edge_id_between_if_exists(4.into(), 3.into())\n            .unwrap();\n        let edge7_id = map\n            .get_edge_id_between_if_exists(4.into(), 2.into())\n            .unwrap();\n        let edge8_id = map\n            .get_edge_id_between_if_exists(8.into(), 9.into())\n            .unwrap();\n        let edge9_id = map\n            .get_edge_id_between_if_exists(9.into(), 10.into())\n            .unwrap();\n        let edge10_id = map\n            .get_edge_id_between_if_exists(8.into(), 7.into())\n            .unwrap();\n        let edge11_id = map\n            .get_edge_id_between_if_exists(3.into(), 1.into())\n            .unwrap();\n\n        let sorted = order_edges(\u0026map).unwrap();\n        let sorted_ids: Vec\u003cEdgeID\u003e = sorted\n            .iter()\n            .map(|edge| edge.get_id())\n            .collect();\n\n        assert_eq!(\n            sorted_ids,\n            vec![\n                edge1_id, edge2_id, edge3_id, edge4_id, edge5_id, edge6_id, edge7_id, edge8_id,\n                edge9_id, edge10_id, edge11_id\n            ]\n        );\n\n        let disjoint_file_content = std::fs::read_to_string(\"existing_maps/disjointed_test.json\")\n            .expect(\"test data file does not exist\");\n        let disjoint_map =\n            json::decode_map(\u0026disjoint_file_content, canvas).expect(\"failed to decode graphml\");\n\n        let edge1_id = disjoint_map\n            .get_edge_id_between_if_exists(1.into(), 2.into())\n            .unwrap();\n        let edge2_id = disjoint_map\n            .get_edge_id_between_if_exists(2.into(), 3.into())\n            .unwrap();\n        let edge3_id = disjoint_map\n            .get_edge_id_between_if_exists(4.into(), 5.into())\n            .unwrap();\n        let edge4_id = disjoint_map\n            .get_edge_id_between_if_exists(5.into(), 6.into())\n            .unwrap();\n\n        let disjoint_sorted = order_edges(\u0026disjoint_map).unwrap();\n        let disjoint_sorted_ids: Vec\u003cEdgeID\u003e = disjoint_sorted\n            .iter()\n            .map(|edge| edge.get_id())\n            .collect();\n\n        assert!(\n            disjoint_sorted_ids == vec![edge3_id, edge4_id, edge1_id, edge2_id]\n                || disjoint_sorted_ids == vec![edge1_id, edge2_id, edge3_id, edge4_id]\n        );\n    }\n\n    #[test]\n    fn test_calc_all_degrees() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let test_file_content = std::fs::read_to_string(\"existing_maps/routing_test.json\")\n            .expect(\"test data file does not exist\");\n        let map = json::decode_map(\u0026test_file_content, canvas).expect(\"failed to decode graphml\");\n\n        let (line_degree_map, highest) = calc_all_degrees(\u0026map).unwrap();\n\n        assert_eq!(line_degree_map.len(), 10);\n        assert_eq!(highest.station, 5.into());\n        assert_eq!(highest.degree, 6);\n    }\n}\n","traces":[{"line":22,"address":[9859712],"length":1,"stats":{"Line":2}},{"line":23,"address":[8190411],"length":1,"stats":{"Line":2}},{"line":25,"address":[9859764,9860178,9860038],"length":1,"stats":{"Line":4}},{"line":27,"address":[9860011,9859881],"length":1,"stats":{"Line":4}},{"line":31,"address":[9860114,9860204,9860282,9860530],"length":1,"stats":{"Line":8}},{"line":32,"address":[9860301,9860497,9860343,9860427],"length":1,"stats":{"Line":6}},{"line":33,"address":[9860298],"length":1,"stats":{"Line":2}},{"line":34,"address":[9860312],"length":1,"stats":{"Line":2}},{"line":38,"address":[9860443,9860535,9860525],"length":1,"stats":{"Line":4}},{"line":43,"address":[9860260],"length":1,"stats":{"Line":2}},{"line":57,"address":[9860560],"length":1,"stats":{"Line":2}},{"line":66,"address":[8191232],"length":1,"stats":{"Line":1}},{"line":68,"address":[9860614,9860606],"length":1,"stats":{"Line":2}},{"line":69,"address":[9860610],"length":1,"stats":{"Line":1}},{"line":75,"address":[9860640],"length":1,"stats":{"Line":0}},{"line":76,"address":[9860665,9860673],"length":1,"stats":{"Line":0}},{"line":78,"address":[9860669],"length":1,"stats":{"Line":0}},{"line":84,"address":[9861693,9860688],"length":1,"stats":{"Line":1}},{"line":90,"address":[9860718],"length":1,"stats":{"Line":1}},{"line":91,"address":[9860821,9860735],"length":1,"stats":{"Line":4}},{"line":93,"address":[9860869,9861167,9861116],"length":1,"stats":{"Line":6}},{"line":98,"address":[9861196,9861346,9861446],"length":1,"stats":{"Line":4}},{"line":99,"address":[9861551],"length":1,"stats":{"Line":2}},{"line":101,"address":[9861424],"length":1,"stats":{"Line":2}},{"line":104,"address":[9861583,9861650],"length":1,"stats":{"Line":4}},{"line":105,"address":[9861607],"length":1,"stats":{"Line":2}},{"line":109,"address":[9861206],"length":1,"stats":{"Line":2}},{"line":114,"address":[8192304,8193994,8194036],"length":1,"stats":{"Line":1}},{"line":115,"address":[9861995,9861764],"length":1,"stats":{"Line":1}},{"line":117,"address":[9861976,9862103],"length":1,"stats":{"Line":2}},{"line":118,"address":[9862170,9862110,9862269],"length":1,"stats":{"Line":3}},{"line":121,"address":[9862194,9862274],"length":1,"stats":{"Line":1}},{"line":123,"address":[9862474,9862699],"length":1,"stats":{"Line":1}},{"line":126,"address":[9862442],"length":1,"stats":{"Line":1}},{"line":130,"address":[9862796,9862917],"length":1,"stats":{"Line":2}},{"line":133,"address":[9862922,9862839],"length":1,"stats":{"Line":1}},{"line":137,"address":[9863111,9862963],"length":1,"stats":{"Line":2}},{"line":138,"address":[9863422,9863132],"length":1,"stats":{"Line":2}},{"line":139,"address":[9863470],"length":1,"stats":{"Line":1}},{"line":141,"address":[9863084,9863156],"length":1,"stats":{"Line":2}},{"line":142,"address":[9863199],"length":1,"stats":{"Line":1}},{"line":143,"address":[9863370,9863412],"length":1,"stats":{"Line":2}},{"line":144,"address":[8193858],"length":1,"stats":{"Line":1}},{"line":150,"address":[8192858],"length":1,"stats":{"Line":1}},{"line":154,"address":[9866103,9863600,9864867],"length":1,"stats":{"Line":1}},{"line":159,"address":[9863687],"length":1,"stats":{"Line":1}},{"line":160,"address":[8194196],"length":1,"stats":{"Line":1}},{"line":162,"address":[8194268,8194312],"length":1,"stats":{"Line":2}},{"line":164,"address":[9864862,9863866],"length":1,"stats":{"Line":2}},{"line":165,"address":[9864293,9866053,9864099,9863944],"length":1,"stats":{"Line":2}},{"line":167,"address":[8194496],"length":1,"stats":{"Line":1}},{"line":171,"address":[9864202],"length":1,"stats":{"Line":1}},{"line":173,"address":[8194834,8194984,8194746],"length":1,"stats":{"Line":3}},{"line":174,"address":[9866002,9864912,9865113,9864603],"length":1,"stats":{"Line":2}},{"line":175,"address":[8195000],"length":1,"stats":{"Line":1}},{"line":176,"address":[9864876],"length":1,"stats":{"Line":1}},{"line":180,"address":[9865012,9865157],"length":1,"stats":{"Line":2}},{"line":181,"address":[9865216,9866000,9865505,9865298],"length":1,"stats":{"Line":2}},{"line":182,"address":[9865194],"length":1,"stats":{"Line":1}},{"line":183,"address":[9865257],"length":1,"stats":{"Line":1}},{"line":187,"address":[9865409,9865762,9865570,9865979],"length":1,"stats":{"Line":2}},{"line":189,"address":[9865534],"length":1,"stats":{"Line":1}},{"line":193,"address":[9865683,9865796],"length":1,"stats":{"Line":2}},{"line":194,"address":[9865948],"length":1,"stats":{"Line":1}},{"line":199,"address":[9881472],"length":1,"stats":{"Line":3}},{"line":200,"address":[9881490,9881506],"length":1,"stats":{"Line":2}},{"line":201,"address":[9881498],"length":1,"stats":{"Line":1}},{"line":204,"address":[9864764],"length":1,"stats":{"Line":1}},{"line":205,"address":[9864643],"length":1,"stats":{"Line":1}},{"line":207,"address":[9881520,9881548],"length":1,"stats":{"Line":2}},{"line":212,"address":[9863971],"length":1,"stats":{"Line":1}}],"covered":68,"coverable":71},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","recalculate_map.rs"],"content":"//! This module contains the Recalculate Map algorithm, which is the main\n//! function to run the map algorithm.\n\nuse std::collections::HashMap;\n\nuse leptos::logging;\n\nuse super::{\n    local_search::local_search,\n    order_edges::order_edges,\n    randomize_edges,\n    route_edges::route_edges,\n    station_contraction::{\n        contract_stations,\n        expand_stations,\n    },\n    unsettle_map,\n    AlgorithmSettings,\n};\nuse crate::{\n    algorithm::debug_print,\n    models::Map,\n    utils::Result,\n    Error,\n};\n\n/// Recalculate the map, all the positions of the stations and the edges between\n/// them, as a whole. This is the Recalculate Map algorithm in the paper.\npub fn recalculate_map(settings: AlgorithmSettings, map: \u0026mut Map) -\u003e Result\u003c()\u003e {\n    if map\n        .get_edges()\n        .is_empty()\n    {\n        logging::warn!(\"Recalculate map called on an empty map\");\n        return Ok(());\n    }\n\n    debug_print(\n        settings,\n        \u0026format!(\n            \"Recalculating map with {} edges and {} stations\",\n            map.get_edges()\n                .len(),\n            map.get_stations()\n                .len()\n        ),\n        false,\n    );\n\n    let contracted_stations = contract_stations(settings, map);\n\n    debug_print(\n        settings,\n        \u0026format!(\n            \"Contracted stations, {} edges and {} stations left\",\n            map.get_edges()\n                .len(),\n            map.get_stations()\n                .len()\n        ),\n        false,\n    );\n\n    map.quickcalc_edges();\n    unsettle_map(map);\n\n    let mut edges = order_edges(map)?;\n    let mut attempt = 0;\n    let mut found = false;\n    let mut occupied = HashMap::new();\n\n    debug_print(\n        settings,\n        \u0026format!(\"Ordered {} edges\", edges.len()),\n        false,\n    );\n\n    while !found {\n        let mut alg_map = map.clone();\n\n        attempt += 1;\n        let res = route_edges(settings, \u0026mut alg_map, edges.clone());\n\n        if let Err(e) = res {\n            logging::error!(\"Failed to route edges: {e}\");\n\n            if attempt \u003e= settings.edge_routing_attempts {\n                *map = alg_map;\n                return Err(Error::other(\n                    \"Reached max amount of retries when routing edges.\",\n                ));\n            }\n\n            randomize_edges(\u0026mut edges);\n        } else {\n            found = true;\n            *map = alg_map;\n            occupied = res.unwrap();\n        }\n    }\n\n    debug_print(\n        settings,\n        \"Routed edges, commencing local search\",\n        false,\n    );\n\n    if settings.local_search {\n        local_search(settings, map, \u0026mut occupied);\n    }\n\n    debug_print(\n        settings,\n        \"Finished local search, re-adding contracted stations\",\n        false,\n    );\n\n    expand_stations(settings, map, \u0026contracted_stations)?;\n\n    logging::log!(\"Recalculated map\");\n\n    Ok(())\n}\n/*\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        algorithm::occupation::OccupiedNodes,\n        models::GridNode,\n        utils::{\n            graphml,\n            json,\n        },\n        CanvasState,\n        MapState,\n    };\n\n    #[test]\n    fn test_recalculate_map_no_overlap_check() {\n        let map_file = \"existing_maps/wien.graphml\";\n\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(7);\n        canvas.set_size((674, 1648));\n\n        let test_file_content = std::fs::read_to_string(map_file).expect(\u0026format!(\n            \"test data file {map_file} does not exist\"\n        ));\n\n        let mut map = if map_file.ends_with(\".json\") {\n            json::decode_map(\u0026test_file_content, canvas).expect(\u0026format!(\n                \"failed to decode json of {map_file}\"\n            ))\n        } else {\n            graphml::decode_map(\u0026test_file_content, canvas).expect(\u0026format!(\n                \"failed to decode graphml of {map_file}\"\n            ))\n        };\n\n        let mut state = MapState::new(map.clone());\n        state.calculate_algorithm_settings();\n        let settings = state.get_algorithm_settings();\n\n        println!(\n            \"testing on map {map_file} with {} stations and {} edges\",\n            map.get_stations()\n                .len(),\n            map.get_edges()\n                .len()\n        );\n\n        recalculate_map(settings, \u0026mut map).expect(\u0026format!(\n            \"failed to recalculate map {map_file}\"\n        ));\n\n        let mut occupied: OccupiedNodes = HashMap::new();\n        for station in map.get_stations() {\n            if let Some(existing) = occupied.insert(\n                station.get_pos(),\n                station\n                    .get_id()\n                    .into(),\n            ) {\n                panic!(\n                    \"station {:?} and {} have the same position\",\n                    existing,\n                    station.get_id()\n                );\n            }\n        }\n        for edge in map.get_edges() {\n            for node in edge.get_nodes() {\n                if let Some(existing) = occupied.insert(\n                    *node,\n                    edge.get_id()\n                        .into(),\n                ) {\n                    panic!(\n                        \"edge node {} of edge {} is already occupied by {:?}\",\n                        node,\n                        edge.get_id(),\n                        existing\n                    );\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_recalculate_map() {\n        let map_files = vec![\n            \"existing_maps/disjointed_test.json\",\n            \"existing_maps/routing_test.json\",\n            \"existing_maps/montreal.graphml\",\n            \"existing_maps/wien.graphml\",\n            \"existing_maps/washington.graphml\",\n            \"existing_maps/karlsruhe.graphml\",\n            // \"existing_maps/sydney.graphml\", // TODO: Get this map working\n            // \"existing_maps/berlin.graphml\", // TODO: Get this map working\n        ];\n\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(7);\n        canvas.set_size((800, 1700));\n\n        for map_file in \u0026map_files {\n            let test_file_content = std::fs::read_to_string(map_file).expect(\u0026format!(\n                \"test data file {map_file} does not exist\"\n            ));\n\n            let mut map = if map_file.ends_with(\".json\") {\n                json::decode_map(\u0026test_file_content, canvas).expect(\u0026format!(\n                    \"failed to decode json of {map_file}\"\n                ))\n            } else {\n                graphml::decode_map(\u0026test_file_content, canvas).expect(\u0026format!(\n                    \"failed to decode graphml of {map_file}\"\n                ))\n            };\n\n            let mut state = MapState::new(map.clone());\n            state.calculate_algorithm_settings();\n            let settings = state.get_algorithm_settings();\n\n            println!(\n                \"testing on map {map_file} with {} stations and {} edges\",\n                map.get_stations()\n                    .len(),\n                map.get_edges()\n                    .len()\n            );\n\n            recalculate_map(settings, \u0026mut map).expect(\u0026format!(\n                \"failed to recalculate map {map_file}\"\n            ));\n        }\n    }\n}\n*/\n","traces":[{"line":29,"address":[9296720,9301108,9302475],"length":1,"stats":{"Line":0}},{"line":30,"address":[9296778,9296904],"length":1,"stats":{"Line":0}},{"line":34,"address":[9302488,9297007],"length":1,"stats":{"Line":0}},{"line":35,"address":[9302578],"length":1,"stats":{"Line":0}},{"line":40,"address":[9297326,9297102,9297780,9297496],"length":1,"stats":{"Line":0}},{"line":42,"address":[9296935,9297154],"length":1,"stats":{"Line":0}},{"line":44,"address":[9297280,9297378],"length":1,"stats":{"Line":0}},{"line":50,"address":[9297956],"length":1,"stats":{"Line":0}},{"line":54,"address":[9298110,9298328,9298811,9298495],"length":1,"stats":{"Line":0}},{"line":56,"address":[9298020,9298083,9298159],"length":1,"stats":{"Line":0}},{"line":58,"address":[9298377,9298285],"length":1,"stats":{"Line":0}},{"line":64,"address":[9298969],"length":1,"stats":{"Line":0}},{"line":65,"address":[9298988],"length":1,"stats":{"Line":0}},{"line":67,"address":[9299184,9299011,9302473],"length":1,"stats":{"Line":0}},{"line":68,"address":[9299134],"length":1,"stats":{"Line":0}},{"line":69,"address":[9299146],"length":1,"stats":{"Line":0}},{"line":70,"address":[9299154],"length":1,"stats":{"Line":0}},{"line":74,"address":[9299509,9299391,9299321,9299638],"length":1,"stats":{"Line":0}},{"line":78,"address":[9301666,9299788],"length":1,"stats":{"Line":0}},{"line":79,"address":[9299814,9299896],"length":1,"stats":{"Line":0}},{"line":81,"address":[8902526,8902468],"length":1,"stats":{"Line":0}},{"line":82,"address":[9299939,9300035],"length":1,"stats":{"Line":0}},{"line":84,"address":[8902685],"length":1,"stats":{"Line":0}},{"line":85,"address":[9300412],"length":1,"stats":{"Line":0}},{"line":87,"address":[8903154],"length":1,"stats":{"Line":0}},{"line":88,"address":[9300644,9300828],"length":1,"stats":{"Line":0}},{"line":89,"address":[8903443],"length":1,"stats":{"Line":0}},{"line":94,"address":[9300714,9300615],"length":1,"stats":{"Line":0}},{"line":96,"address":[8902860],"length":1,"stats":{"Line":0}},{"line":97,"address":[9301125,9300308],"length":1,"stats":{"Line":0}},{"line":98,"address":[9301196,9301475],"length":1,"stats":{"Line":0}},{"line":108,"address":[9301804],"length":1,"stats":{"Line":0}},{"line":109,"address":[9301898],"length":1,"stats":{"Line":0}},{"line":118,"address":[9301977,9302129,9302433],"length":1,"stats":{"Line":0}},{"line":120,"address":[9302238,9302095],"length":1,"stats":{"Line":0}},{"line":122,"address":[9302362],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","route_edges.rs"],"content":"//! This module contains the Route Edges algorithm and the functions for\n//! determining the to and from node-sets that it needs.\n\nuse std::collections::HashMap;\n\nuse super::{\n    debug_print,\n    edge_dijkstra::edge_dijkstra,\n    occupation::OccupiedNodes,\n    AlgorithmSettings,\n};\nuse crate::{\n    models::{\n        Edge,\n        GridNode,\n        Map,\n        Station,\n    },\n    utils::Result,\n    Error,\n};\n\n/// Get a set of nodes in the radius around the given station.\nfn get_node_set(\n    settings: AlgorithmSettings,\n    station: \u0026Station,\n    occupied: \u0026OccupiedNodes,\n) -\u003e Vec\u003c(GridNode, f64)\u003e {\n    if station.is_settled() {\n        return vec![(station.get_pos(), 0.0)];\n    }\n\n    let radius = settings.node_set_radius;\n    let original_station_pos = station.get_original_pos();\n    let station_pos = station.get_pos();\n    let mut nodes = Vec::new();\n\n    // Add all nodes in the radius around the station\n    for x in (station_pos.0 - radius)..=(station_pos.0 + radius) {\n        for y in (station_pos.1 - radius)..=(station_pos.1 + radius) {\n            let node = GridNode::from((x, y));\n            if occupied.contains_key(\u0026node) {\n                continue;\n            }\n\n            let distance = node.manhattan_distance_to(original_station_pos);\n            if distance \u003c= radius {\n                nodes.push((\n                    node,\n                    f64::from(distance) * settings.move_cost,\n                ));\n            }\n        }\n    }\n\n    nodes\n}\n\n/// Check if two slices of grid nodes have any overlap.\nfn have_overlap(left: \u0026[(GridNode, f64)], right: \u0026[(GridNode, f64)]) -\u003e bool {\n    for (node, _) in left {\n        if right\n            .iter()\n            .any(|(n, _)| n == node)\n        {\n            return true;\n        }\n    }\n    false\n}\n\n/// Split the overlap between the two node sets based on the distance to their\n/// source.\n#[allow(clippy::type_complexity)] // the return type is complex but makes sense here\nfn split_overlap(\n    mut from_set: Vec\u003c(GridNode, f64)\u003e,\n    from: \u0026Station,\n    mut to_set: Vec\u003c(GridNode, f64)\u003e,\n    to: \u0026Station,\n) -\u003e (\n    Vec\u003c(GridNode, f64)\u003e,\n    Vec\u003c(GridNode, f64)\u003e,\n) {\n    for (node, _) in \u0026from_set.clone() {\n        // Ensure the station is always in their own set\n        if *node == to.get_pos() {\n            from_set.retain(|(n, _)| n != node);\n            continue;\n        } else if *node == from.get_pos() {\n            to_set.retain(|(n, _)| n != node);\n            continue;\n        }\n\n        if to_set\n            .iter()\n            .any(|(n, _)| n == node)\n        {\n            // If the node is in both sets, remove it from the set that it's furthest from\n            // the station from.\n            if node.diagonal_distance_to(from.get_original_pos())\n                \u003e node.diagonal_distance_to(to.get_original_pos())\n            {\n                from_set.retain(|(n, _)| n != node);\n            } else {\n                to_set.retain(|(n, _)| n != node);\n            }\n        }\n    }\n\n    (from_set, to_set)\n}\n\n/// Route all the edges on the map (as given by the input list of edges) and\n/// return them. This is the Route Edges algorithm in the paper.\npub fn route_edges(\n    settings: AlgorithmSettings,\n    map: \u0026mut Map,\n    mut edges: Vec\u003cEdge\u003e,\n) -\u003e Result\u003cOccupiedNodes\u003e {\n    let mut occupied = HashMap::new();\n\n    for edge in \u0026mut edges {\n        let from_station = map\n            .get_station(edge.get_from())\n            .ok_or(Error::other(\n                \"from station on edge not found\",\n            ))?;\n        let to_station = map\n            .get_station(edge.get_to())\n            .ok_or(Error::other(\n                \"to station on edge not found\",\n            ))?;\n\n        let mut from_nodes = if settings.allow_station_relocation {\n            get_node_set(settings, from_station, \u0026occupied)\n        } else {\n            vec![(from_station.get_pos(), 0.0)]\n        };\n        let mut to_nodes = if settings.allow_station_relocation {\n            get_node_set(settings, to_station, \u0026occupied)\n        } else {\n            vec![(to_station.get_pos(), 0.0)]\n        };\n\n        if settings.allow_station_relocation {\n            if have_overlap(\u0026from_nodes, \u0026to_nodes) {\n                (from_nodes, to_nodes) = split_overlap(\n                    from_nodes,\n                    from_station,\n                    to_nodes,\n                    to_station,\n                );\n            }\n\n            if from_nodes.is_empty() {\n                from_nodes.push((from_station.get_pos(), 0.0));\n            }\n            if to_nodes.is_empty() {\n                to_nodes.push((to_station.get_pos(), 0.0));\n            }\n        }\n\n        debug_print(\n            settings,\n            \u0026format!(\n                \"routing edge from {}{} to {}{}, sets:\\nfrom: {:?}\\nto: {:?}\",\n                from_station.get_id(),\n                from_station.get_pos(),\n                to_station.get_id(),\n                to_station.get_pos(),\n                from_nodes,\n                to_nodes\n            ),\n            false,\n        );\n\n        let (start, nodes, end, cost) = edge_dijkstra(\n            settings,\n            map,\n            edge,\n            \u0026from_nodes,\n            from_station,\n            \u0026to_nodes,\n            to_station,\n            \u0026occupied,\n        )?;\n\n        debug_print(\n            settings,\n            \u0026format!(\n                \"routed edge {} from {start} to {end}\\nOriginally from {} to {}\",\n                edge.get_id(),\n                from_station.get_pos(),\n                to_station.get_pos(),\n            ),\n            false,\n        );\n\n        occupied.extend(\n            nodes\n                .iter()\n                .map(|n| {\n                    (\n                        *n,\n                        edge.get_id()\n                            .into(),\n                    )\n                }),\n        );\n        edge.set_nodes(nodes);\n        edge.settle();\n\n        occupied.insert(\n            start,\n            from_station\n                .get_id()\n                .into(),\n        );\n        occupied.insert(\n            end,\n            to_station\n                .get_id()\n                .into(),\n        );\n\n        if let Some(start_station) = map.get_mut_station(edge.get_from()) {\n            start_station.settle(start);\n            start_station.add_cost(*cost);\n        }\n        if let Some(end_station) = map.get_mut_station(edge.get_to()) {\n            end_station.settle(end);\n            end_station.add_cost(*cost);\n        }\n        map.add_edge(edge.clone());\n    }\n    Ok(occupied)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::models::Station;\n\n    #[test]\n    fn test_get_node_set() {\n        let mut map = Map::new();\n        let station = Station::new((0, 0).into(), None);\n        map.add_station(station.clone());\n\n        let result = get_node_set(\n            AlgorithmSettings::default(),\n            \u0026station,\n            \u0026mut HashMap::new(),\n        );\n\n        assert_eq!(\n            result,\n            vec![\n                (GridNode::from((-3, 0)), 3.0),\n                (GridNode::from((-2, -1)), 3.0),\n                (GridNode::from((-2, 0)), 2.0),\n                (GridNode::from((-2, 1)), 3.0),\n                (GridNode::from((-1, -2)), 3.0),\n                (GridNode::from((-1, -1)), 2.0),\n                (GridNode::from((-1, 0)), 1.0),\n                (GridNode::from((-1, 1)), 2.0),\n                (GridNode::from((-1, 2)), 3.0),\n                (GridNode::from((0, -3)), 3.0),\n                (GridNode::from((0, -2)), 2.0),\n                (GridNode::from((0, -1)), 1.0),\n                (GridNode::from((0, 0)), 0.0),\n                (GridNode::from((0, 1)), 1.0),\n                (GridNode::from((0, 2)), 2.0),\n                (GridNode::from((0, 3)), 3.0),\n                (GridNode::from((1, -2)), 3.0),\n                (GridNode::from((1, -1)), 2.0),\n                (GridNode::from((1, 0)), 1.0),\n                (GridNode::from((1, 1)), 2.0),\n                (GridNode::from((1, 2)), 3.0),\n                (GridNode::from((2, -1)), 3.0),\n                (GridNode::from((2, 0)), 2.0),\n                (GridNode::from((2, 1)), 3.0),\n                (GridNode::from((3, 0)), 3.0),\n            ]\n        );\n    }\n\n    #[test]\n    fn test_split_overlap() {\n        let from = Station::new((0, 0).into(), None);\n        let from_set = vec![\n            (GridNode::from((0, 0)), 0.0),\n            (GridNode::from((1, 1)), 0.0),\n            (GridNode::from((1, 2)), 0.0),\n            (GridNode::from((2, 2)), 0.0),\n            (GridNode::from((3, 3)), 0.0),\n            (GridNode::from((3, 4)), 0.0),\n            (GridNode::from((4, 4)), 0.0),\n            (GridNode::from((4, 5)), 0.0),\n        ];\n        let to = Station::new((5, 5).into(), None);\n        let to_set = vec![\n            (GridNode::from((1, 1)), 0.0),\n            (GridNode::from((1, 2)), 0.0),\n            (GridNode::from((2, 2)), 0.0),\n            (GridNode::from((3, 3)), 0.0),\n            (GridNode::from((3, 4)), 0.0),\n            (GridNode::from((4, 4)), 0.0),\n            (GridNode::from((4, 5)), 0.0),\n            (GridNode::from((5, 5)), 0.0),\n        ];\n\n        let (from_set, to_set) = split_overlap(from_set, \u0026from, to_set, \u0026to);\n\n        assert_eq!(\n            from_set,\n            vec![\n                (GridNode::from((0, 0)), 0.0),\n                (GridNode::from((1, 1)), 0.0),\n                (GridNode::from((1, 2)), 0.0),\n                (GridNode::from((2, 2)), 0.0),\n            ]\n        );\n        assert_eq!(\n            to_set,\n            vec![\n                (GridNode::from((3, 3)), 0.0),\n                (GridNode::from((3, 4)), 0.0),\n                (GridNode::from((4, 4)), 0.0),\n                (GridNode::from((4, 5)), 0.0),\n                (GridNode::from((5, 5)), 0.0),\n            ]\n        );\n    }\n\n    #[test]\n    fn test_route_edges() {\n        let mut map = Map::new();\n        let edges = vec![];\n\n        let result = route_edges(\n            AlgorithmSettings::default(),\n            \u0026mut map,\n            edges,\n        )\n        .unwrap();\n\n        assert_eq!(result, HashMap::new());\n    }\n}\n","traces":[{"line":24,"address":[9784192,9785215],"length":1,"stats":{"Line":1}},{"line":29,"address":[9302654],"length":1,"stats":{"Line":1}},{"line":30,"address":[9303682,9302791],"length":1,"stats":{"Line":0}},{"line":33,"address":[9302673],"length":1,"stats":{"Line":1}},{"line":34,"address":[9302687],"length":1,"stats":{"Line":1}},{"line":35,"address":[9302719],"length":1,"stats":{"Line":1}},{"line":36,"address":[9302746],"length":1,"stats":{"Line":1}},{"line":39,"address":[9302835,9302920,9302768,9303129],"length":1,"stats":{"Line":4}},{"line":40,"address":[9784767,9784730],"length":1,"stats":{"Line":2}},{"line":41,"address":[9303407],"length":1,"stats":{"Line":1}},{"line":42,"address":[9303453],"length":1,"stats":{"Line":1}},{"line":46,"address":[9303498],"length":1,"stats":{"Line":1}},{"line":47,"address":[9303542],"length":1,"stats":{"Line":1}},{"line":48,"address":[9303591],"length":1,"stats":{"Line":1}},{"line":50,"address":[9785141],"length":1,"stats":{"Line":1}},{"line":56,"address":[9303084],"length":1,"stats":{"Line":1}},{"line":60,"address":[9303872],"length":1,"stats":{"Line":0}},{"line":61,"address":[9303979,9303905],"length":1,"stats":{"Line":0}},{"line":62,"address":[9303989],"length":1,"stats":{"Line":0}},{"line":64,"address":[9370270,9370256],"length":1,"stats":{"Line":0}},{"line":66,"address":[9785586],"length":1,"stats":{"Line":0}},{"line":69,"address":[9303963],"length":1,"stats":{"Line":0}},{"line":75,"address":[9304048,9305203,9305175],"length":1,"stats":{"Line":1}},{"line":84,"address":[9304182,9304274,9304383,9304119],"length":1,"stats":{"Line":4}},{"line":86,"address":[9304399,9304606],"length":1,"stats":{"Line":2}},{"line":87,"address":[9370318,9370304],"length":1,"stats":{"Line":0}},{"line":89,"address":[9304718,9304665],"length":1,"stats":{"Line":2}},{"line":90,"address":[9176816,9176830],"length":1,"stats":{"Line":4}},{"line":94,"address":[9304838,9304777],"length":1,"stats":{"Line":2}},{"line":96,"address":[9176878,9176864],"length":1,"stats":{"Line":2}},{"line":100,"address":[9305095,9304937],"length":1,"stats":{"Line":2}},{"line":101,"address":[9305014],"length":1,"stats":{"Line":1}},{"line":103,"address":[9176926,9176912],"length":1,"stats":{"Line":4}},{"line":105,"address":[9305109,9305155],"length":1,"stats":{"Line":4}},{"line":110,"address":[9304449],"length":1,"stats":{"Line":1}},{"line":115,"address":[9311915,9305216,9306646],"length":1,"stats":{"Line":1}},{"line":120,"address":[9305272],"length":1,"stats":{"Line":1}},{"line":122,"address":[9305451,9305622,9311748,9305367],"length":1,"stats":{"Line":2}},{"line":123,"address":[9305694,9305950,9305752,9311894],"length":1,"stats":{"Line":0}},{"line":124,"address":[9787113],"length":1,"stats":{"Line":0}},{"line":125,"address":[9787176],"length":1,"stats":{"Line":0}},{"line":128,"address":[9787442,9787675,9787508,9793147],"length":1,"stats":{"Line":0}},{"line":129,"address":[9787314],"length":1,"stats":{"Line":0}},{"line":130,"address":[9306014],"length":1,"stats":{"Line":0}},{"line":134,"address":[9788078,9787595],"length":1,"stats":{"Line":0}},{"line":135,"address":[9306655,9306318],"length":1,"stats":{"Line":0}},{"line":137,"address":[9787826,9787710],"length":1,"stats":{"Line":0}},{"line":139,"address":[9307080,9306638],"length":1,"stats":{"Line":0}},{"line":140,"address":[9306706,9307072],"length":1,"stats":{"Line":0}},{"line":142,"address":[9306832,9306675],"length":1,"stats":{"Line":0}},{"line":145,"address":[9307064],"length":1,"stats":{"Line":0}},{"line":146,"address":[9307216,9307108,9307674],"length":1,"stats":{"Line":0}},{"line":147,"address":[9788854],"length":1,"stats":{"Line":0}},{"line":148,"address":[9307355],"length":1,"stats":{"Line":0}},{"line":150,"address":[9307395],"length":1,"stats":{"Line":0}},{"line":155,"address":[9307686,9307310],"length":1,"stats":{"Line":0}},{"line":156,"address":[9789117],"length":1,"stats":{"Line":0}},{"line":158,"address":[9789210,9789095],"length":1,"stats":{"Line":0}},{"line":159,"address":[9307840],"length":1,"stats":{"Line":0}},{"line":165,"address":[9790145,9790350],"length":1,"stats":{"Line":0}},{"line":167,"address":[9788497,9789324],"length":1,"stats":{"Line":0}},{"line":168,"address":[9308067],"length":1,"stats":{"Line":0}},{"line":169,"address":[9789617],"length":1,"stats":{"Line":0}},{"line":170,"address":[9789766],"length":1,"stats":{"Line":0}},{"line":181,"address":[9309133],"length":1,"stats":{"Line":0}},{"line":183,"address":[9309200],"length":1,"stats":{"Line":0}},{"line":190,"address":[9791448,9791636,9791824,9791730,9792017,9791274,9791542],"length":1,"stats":{"Line":0}},{"line":192,"address":[9791160,9790988],"length":1,"stats":{"Line":0}},{"line":193,"address":[9791168],"length":1,"stats":{"Line":0}},{"line":194,"address":[9791225],"length":1,"stats":{"Line":0}},{"line":199,"address":[9310937],"length":1,"stats":{"Line":0}},{"line":200,"address":[9310816],"length":1,"stats":{"Line":0}},{"line":202,"address":[9177008],"length":1,"stats":{"Line":0}},{"line":204,"address":[9177032],"length":1,"stats":{"Line":0}},{"line":205,"address":[9177044],"length":1,"stats":{"Line":0}},{"line":210,"address":[9310972],"length":1,"stats":{"Line":0}},{"line":211,"address":[9311039],"length":1,"stats":{"Line":0}},{"line":213,"address":[9311131],"length":1,"stats":{"Line":0}},{"line":215,"address":[9792397],"length":1,"stats":{"Line":0}},{"line":219,"address":[9311227],"length":1,"stats":{"Line":0}},{"line":221,"address":[9311172],"length":1,"stats":{"Line":0}},{"line":226,"address":[9311268],"length":1,"stats":{"Line":0}},{"line":227,"address":[9792691],"length":1,"stats":{"Line":0}},{"line":228,"address":[9311417],"length":1,"stats":{"Line":0}},{"line":230,"address":[9311405,9311481],"length":1,"stats":{"Line":0}},{"line":231,"address":[9311560],"length":1,"stats":{"Line":0}},{"line":232,"address":[9311608],"length":1,"stats":{"Line":0}},{"line":234,"address":[9311601,9311667],"length":1,"stats":{"Line":0}},{"line":236,"address":[9305539],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":89},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","station_contraction.rs"],"content":"//! Contains the functions for contracting all degree two stations into edges\n//! and expanding those edges back out again.\n\nuse std::collections::HashMap;\n\nuse itertools::Itertools;\nuse leptos::logging;\n\nuse super::{\n    debug_print,\n    AlgorithmSettings,\n};\nuse crate::{\n    models::{\n        Edge,\n        Map,\n        Station,\n        StationID,\n    },\n    utils::Result,\n    Error,\n};\n\n/// Check if the station has degree two and the edges are part of the same\n/// lines.\nfn station_has_degree_two(map: \u0026Map, station: \u0026Station) -\u003e bool {\n    if station\n        .get_edges()\n        .len()\n        != 2\n    {\n        return false;\n    }\n\n    station\n        .get_edges()\n        .iter()\n        .map(|id| {\n            map.get_edge(*id)\n                .unwrap_or_else(|| {\n                    panic!(\n                        \"Station {} cannot find its edge {}.\",\n                        station.get_id(),\n                        id\n                    )\n                })\n        })\n        .map(Edge::get_lines)\n        .all_equal()\n}\n\n/// Check if the station can be contracted into an edge between its neighboring\n/// stations given by start and end.\nfn can_contract_into(\n    settings: AlgorithmSettings,\n    map: \u0026Map,\n    start: StationID,\n    end: StationID,\n) -\u003e bool {\n    if map\n        .get_edge_id_between_if_exists(start, end)\n        .is_some()\n    {\n        // Edge already exists, so we can't contract into it, skip.\n        return false;\n    }\n\n    let start_station = map\n        .get_station(start)\n        .unwrap();\n    let end_station = map\n        .get_station(end)\n        .unwrap();\n\n    // Check if the stations are far enough apart. If they are too close, the\n    // stations might become too close for the contracted station to be re-inserted\n    // after the algorithm has ran its course.\n    start_station\n        .get_pos()\n        .manhattan_distance_to(end_station.get_pos())\n        \u003e settings.node_set_radius * 2 + 1\n}\n\n/// Contract all stations with degree two into an edge between their neighboring\n/// stations. Skips if there is already an edge between the neighboring\n/// stations. Returns a hashmap of the contracted stations.\npub fn contract_stations(\n    settings: AlgorithmSettings,\n    map: \u0026mut Map,\n) -\u003e HashMap\u003cStationID, Station\u003e {\n    let mut contracted_stations = HashMap::new();\n\n    let station_ids = map\n        .get_stations()\n        .into_iter()\n        .map(Station::get_id)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    for station_id in station_ids {\n        let station = map\n            .get_station(station_id)\n            .unwrap()\n            .clone();\n        if station.is_locked() {\n            continue;\n        }\n\n        if !station_has_degree_two(map, \u0026station) {\n            continue;\n        }\n\n        let edges = station\n            .get_edges()\n            .iter()\n            .map(|id| {\n                map.get_edge(*id)\n                    .unwrap()\n            })\n            .cloned()\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // The start and end of the new edge the station will be contracted into.\n        let start = edges[0]\n            .opposite(station_id)\n            .unwrap_or_else(|| {\n                panic!(\n                    \"Station {} cannot find its opposite node on edge {}.\\n{:?}\",\n                    station.get_id(),\n                    edges[0].get_id(),\n                    edges[0]\n                )\n            });\n        let end = edges[1]\n            .opposite(station_id)\n            .unwrap_or_else(|| {\n                panic!(\n                    \"Station {} cannot find its opposite node on edge {}.\",\n                    station.get_id(),\n                    edges[1].get_id()\n                )\n            });\n\n        if !can_contract_into(settings, map, start, end) {\n            continue;\n        }\n\n        // Create the new edge and retrieve it so we have a mutable reference to the\n        // station object.\n        let new_edge_id = map.get_edge_id_between(start, end);\n        let new_edge = map\n            .get_mut_edge(new_edge_id)\n            .unwrap();\n\n        new_edge.extend_contracted_stations(edges[0].get_contracted_stations());\n        new_edge.extend_contracted_stations(edges[1].get_contracted_stations());\n        new_edge.add_contracted_station(station_id);\n\n        map.remove_station(station_id);\n        contracted_stations.insert(station.get_id(), station);\n    }\n\n    contracted_stations\n}\n\n/// Reinsert all contracted stations into the map.\n/// The stations in `expand_stations` are reinserted into the map at the\n/// locations given by `station_locs`.\nfn reinsert_stations(\n    map: \u0026mut Map,\n    edge: \u0026Edge,\n    to_expand: \u0026mut [Station],\n    station_locs: \u0026[usize],\n) {\n    // Reinsert the contracted stations into the map at the given locations.\n    for (station, loc) in to_expand\n        .iter_mut()\n        .zip(station_locs)\n    {\n        let node = edge\n            .get_nodes()\n            .get(*loc)\n            .unwrap();\n\n        station.set_pos(*node);\n        station.clear_edges();\n        map.add_station(station.clone());\n    }\n\n    // To get a vec of all station IDs that we need to add a new edge between, also\n    // add the start and end station IDs of the edge to expand.\n    let mut expand_station_ids = to_expand\n        .iter()\n        .map(Station::get_id)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    expand_station_ids.insert(0, edge.get_from());\n    expand_station_ids.push(edge.get_to());\n\n    // Add in an edge for every pair of station ids. We also keep track of the\n    // location of the end station and the index of that location.\n    for ((start, end), (i, loc)) in expand_station_ids\n        .iter()\n        .zip(\u0026expand_station_ids[1..])\n        .zip(\n            station_locs\n                .iter()\n                .enumerate(),\n        )\n    {\n        let new_edge_id = map.get_edge_id_between(*start, *end);\n\n        // Add the edge to the lines of the old edge.\n        for line_id in edge.get_lines() {\n            let mut line = map\n                .get_line(*line_id)\n                .unwrap()\n                .clone();\n            line.add_edge(new_edge_id, map);\n            map.add_line(line);\n        }\n\n        if *loc == 0 {\n            // end station location is 0, the amount of nodes on the new edge is thus 0 and\n            // we can skip the rest.\n            continue;\n        }\n\n        // Calculate the nodes to take from the old edge and set them on the new edge.\n        let to_skip = if i == 0 { 0 } else { station_locs[i - 1] + 1 };\n        let to_take = if *loc\n            \u003e= edge\n                .get_nodes()\n                .len()\n        {\n            // If the end station is the last contracted station, can take all nodes from\n            // the start station up to the end of the nodes list.\n            loc - station_locs[i - 1]\n        } else if i == 0 {\n            // If the end station is the first contracted station, can take all nodes up to\n            // the location of this station.\n            *loc\n        } else {\n            // Otherwise, take all nodes between the previous contracted station and the\n            // current one.\n            loc - station_locs[i - 1] - 1\n        };\n\n        map.get_mut_edge(new_edge_id)\n            .unwrap()\n            .set_nodes(\n                edge.get_nodes()\n                    .iter()\n                    .copied()\n                    .skip(to_skip)\n                    .take(to_take)\n                    .collect(),\n            );\n    }\n}\n\n/// Expand all contracted stations into new stations and edges.\n/// The contracted stations are returned equidistantly between the two ends of\n/// the edge they were contracted into.\npub fn expand_stations(\n    settings: AlgorithmSettings,\n    map: \u0026mut Map,\n    contracted_stations: \u0026HashMap\u003cStationID, Station\u003e,\n) -\u003e Result\u003c()\u003e {\n    let edges = map\n        .get_edges()\n        .into_iter()\n        .cloned()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    for edge in edges {\n        // Get all stations that were contracted into the edge.\n        let mut to_expand = edge\n            .get_contracted_stations()\n            .iter()\n            .map(|id| {\n                contracted_stations\n                    .get(id)\n                    .unwrap()\n            })\n            .cloned()\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        if to_expand.is_empty() {\n            continue;\n        }\n\n        if to_expand.len()\n            \u003e edge\n                .get_nodes()\n                .len()\n        {\n            return Err(Error::other(format!(\n                \"Contracted edge {} has {} nodes while having {} contracted stations\",\n                edge.get_id(),\n                edge.get_nodes()\n                    .len(),\n                to_expand.len()\n            )));\n        }\n\n        let start_station = map\n            .get_station(edge.get_from())\n            .ok_or(Error::other(\n                \"Edge with contracted stations has no start station\",\n            ))?\n            .clone();\n        let end_station = map\n            .get_station(edge.get_to())\n            .ok_or(Error::other(\n                \"Edge with contracted stations has no end station\",\n            ))?\n            .clone();\n\n        // Sort the stations by distance to starting station of the edge. This ensures\n        // that they will be added back in in the correct order.\n        to_expand.sort_by(|a, b| {\n            a.get_pos()\n                .diagonal_distance_to(start_station.get_pos())\n                .partial_cmp(\n                    \u0026b.get_pos()\n                        .diagonal_distance_to(start_station.get_pos()),\n                )\n                .unwrap()\n        });\n\n        // Calculate the new locations of the contracted stations on the edge, these are\n        // equi-distance between the start and end stations of the edge they were\n        // contracted into.\n        let step = (edge\n            .get_nodes()\n            .len() as f64)\n            / (to_expand.len() as f64 + 1.0);\n        let station_locs = (0..(to_expand.len() + 2))\n            .map(|i| ((i as f64) * step) as usize)\n            .collect::\u003cVec\u003c_\u003e\u003e()[1..]\n            .to_vec();\n\n        debug_print(\n            settings,\n            \u0026format!(\n                \"expand_len: {}, nodes_len: {}, station_locs: {:?}\",\n                to_expand.len(),\n                edge.get_nodes()\n                    .len(),\n                station_locs\n            ),\n            false,\n        );\n\n        reinsert_stations(\n            map,\n            \u0026edge,\n            \u0026mut to_expand,\n            \u0026station_locs,\n        );\n\n        map.remove_edge(edge.get_id());\n    }\n\n    Ok(())\n}\n","traces":[{"line":26,"address":[9278752],"length":1,"stats":{"Line":0}},{"line":27,"address":[10173445],"length":1,"stats":{"Line":0}},{"line":32,"address":[10173539],"length":1,"stats":{"Line":0}},{"line":35,"address":[10173462],"length":1,"stats":{"Line":0}},{"line":38,"address":[9878976],"length":1,"stats":{"Line":0}},{"line":39,"address":[9879022,9878994],"length":1,"stats":{"Line":0}},{"line":40,"address":[9879056,9879018],"length":1,"stats":{"Line":0}},{"line":41,"address":[9879227,9879159],"length":1,"stats":{"Line":0}},{"line":43,"address":[9879073],"length":1,"stats":{"Line":0}},{"line":54,"address":[10173568],"length":1,"stats":{"Line":0}},{"line":60,"address":[9278986],"length":1,"stats":{"Line":0}},{"line":65,"address":[10173954],"length":1,"stats":{"Line":0}},{"line":68,"address":[9279110,9279029],"length":1,"stats":{"Line":0}},{"line":71,"address":[10173870,10173793],"length":1,"stats":{"Line":0}},{"line":78,"address":[10174002,10173878,10173919],"length":1,"stats":{"Line":0}},{"line":80,"address":[10173896],"length":1,"stats":{"Line":0}},{"line":81,"address":[9279257,9279338,9279288],"length":1,"stats":{"Line":0}},{"line":87,"address":[10176055,10176099,10174048],"length":1,"stats":{"Line":0}},{"line":91,"address":[10174095],"length":1,"stats":{"Line":0}},{"line":93,"address":[10174191,10174128],"length":1,"stats":{"Line":0}},{"line":99,"address":[9279800,9281226,9279592,9279750],"length":1,"stats":{"Line":0}},{"line":100,"address":[10174694,10174536],"length":1,"stats":{"Line":0}},{"line":104,"address":[10174717,10174779],"length":1,"stats":{"Line":0}},{"line":108,"address":[10174801,10174844],"length":1,"stats":{"Line":0}},{"line":112,"address":[10174850],"length":1,"stats":{"Line":0}},{"line":115,"address":[9879312],"length":1,"stats":{"Line":0}},{"line":116,"address":[7971790],"length":1,"stats":{"Line":0}},{"line":123,"address":[10175025,10175123],"length":1,"stats":{"Line":0}},{"line":125,"address":[7971856],"length":1,"stats":{"Line":0}},{"line":126,"address":[9879713],"length":1,"stats":{"Line":0}},{"line":128,"address":[9879409],"length":1,"stats":{"Line":0}},{"line":129,"address":[9879498],"length":1,"stats":{"Line":0}},{"line":130,"address":[7972078],"length":1,"stats":{"Line":0}},{"line":133,"address":[10175218],"length":1,"stats":{"Line":0}},{"line":135,"address":[9879808],"length":1,"stats":{"Line":0}},{"line":136,"address":[9880024],"length":1,"stats":{"Line":0}},{"line":138,"address":[9879825],"length":1,"stats":{"Line":0}},{"line":139,"address":[9879911],"length":1,"stats":{"Line":0}},{"line":143,"address":[10175371],"length":1,"stats":{"Line":0}},{"line":149,"address":[10175475],"length":1,"stats":{"Line":0}},{"line":150,"address":[10175608,10175512],"length":1,"stats":{"Line":0}},{"line":154,"address":[10175616],"length":1,"stats":{"Line":0}},{"line":155,"address":[10175703],"length":1,"stats":{"Line":0}},{"line":156,"address":[10175804],"length":1,"stats":{"Line":0}},{"line":158,"address":[10175831],"length":1,"stats":{"Line":0}},{"line":159,"address":[10175850],"length":1,"stats":{"Line":0}},{"line":162,"address":[10174563],"length":1,"stats":{"Line":0}},{"line":168,"address":[10176112,10179058],"length":1,"stats":{"Line":0}},{"line":175,"address":[10176501,10176253],"length":1,"stats":{"Line":0}},{"line":179,"address":[10176549,10176647,10176572],"length":1,"stats":{"Line":0}},{"line":181,"address":[9281736],"length":1,"stats":{"Line":0}},{"line":184,"address":[10176655],"length":1,"stats":{"Line":0}},{"line":185,"address":[9281839],"length":1,"stats":{"Line":0}},{"line":186,"address":[10176688],"length":1,"stats":{"Line":0}},{"line":191,"address":[10176423],"length":1,"stats":{"Line":0}},{"line":195,"address":[10176780,10176475],"length":1,"stats":{"Line":0}},{"line":196,"address":[10176811],"length":1,"stats":{"Line":0}},{"line":200,"address":[10176853,10177042,10177313,10177139],"length":1,"stats":{"Line":0}},{"line":202,"address":[9282106],"length":1,"stats":{"Line":0}},{"line":204,"address":[10177077],"length":1,"stats":{"Line":0}},{"line":209,"address":[9282515],"length":1,"stats":{"Line":0}},{"line":212,"address":[10179031,10177442,10177644],"length":1,"stats":{"Line":0}},{"line":213,"address":[10177663,10178801],"length":1,"stats":{"Line":0}},{"line":214,"address":[9282766],"length":1,"stats":{"Line":0}},{"line":217,"address":[9283906],"length":1,"stats":{"Line":0}},{"line":218,"address":[10178900],"length":1,"stats":{"Line":0}},{"line":221,"address":[10177624],"length":1,"stats":{"Line":0}},{"line":228,"address":[9282795,9282907],"length":1,"stats":{"Line":0}},{"line":229,"address":[9283056,9282862],"length":1,"stats":{"Line":0}},{"line":230,"address":[10177771],"length":1,"stats":{"Line":0}},{"line":236,"address":[9283386,9283085],"length":1,"stats":{"Line":0}},{"line":237,"address":[10178033,10178253,10177971],"length":1,"stats":{"Line":0}},{"line":240,"address":[10178022],"length":1,"stats":{"Line":0}},{"line":244,"address":[10178043,10178111,10178258],"length":1,"stats":{"Line":0}},{"line":247,"address":[10178686,10178079],"length":1,"stats":{"Line":0}},{"line":250,"address":[10178499,10178627,10178600],"length":1,"stats":{"Line":0}},{"line":253,"address":[10178592],"length":1,"stats":{"Line":0}},{"line":254,"address":[9283697],"length":1,"stats":{"Line":0}},{"line":263,"address":[10182269,10179088,10183010],"length":1,"stats":{"Line":0}},{"line":268,"address":[10179162],"length":1,"stats":{"Line":0}},{"line":274,"address":[9284506,9284442,9284294],"length":1,"stats":{"Line":0}},{"line":276,"address":[9284626,9284721],"length":1,"stats":{"Line":0}},{"line":279,"address":[7972544],"length":1,"stats":{"Line":0}},{"line":280,"address":[7972558],"length":1,"stats":{"Line":0}},{"line":287,"address":[10179811,10179888],"length":1,"stats":{"Line":0}},{"line":291,"address":[10179894,10179986],"length":1,"stats":{"Line":0}},{"line":292,"address":[9284953],"length":1,"stats":{"Line":0}},{"line":296,"address":[9287605,9287774],"length":1,"stats":{"Line":0}},{"line":298,"address":[9285020,9287203],"length":1,"stats":{"Line":0}},{"line":299,"address":[9287329],"length":1,"stats":{"Line":0}},{"line":301,"address":[10182594],"length":1,"stats":{"Line":0}},{"line":305,"address":[9285120,9285278,9287193,9285054],"length":1,"stats":{"Line":0}},{"line":306,"address":[10179999],"length":1,"stats":{"Line":0}},{"line":307,"address":[10180075],"length":1,"stats":{"Line":0}},{"line":311,"address":[10180466,10180648,10180408],"length":1,"stats":{"Line":0}},{"line":312,"address":[10180333],"length":1,"stats":{"Line":0}},{"line":313,"address":[10180427],"length":1,"stats":{"Line":0}},{"line":320,"address":[9880192],"length":1,"stats":{"Line":0}},{"line":321,"address":[9880232,9880349,9880276],"length":1,"stats":{"Line":0}},{"line":322,"address":[9880250],"length":1,"stats":{"Line":0}},{"line":324,"address":[9880337,9880293],"length":1,"stats":{"Line":0}},{"line":325,"address":[7972742],"length":1,"stats":{"Line":0}},{"line":333,"address":[10180791,10180969],"length":1,"stats":{"Line":0}},{"line":336,"address":[10180874],"length":1,"stats":{"Line":0}},{"line":337,"address":[10180982,10181209],"length":1,"stats":{"Line":0}},{"line":338,"address":[9880426,9880416],"length":1,"stats":{"Line":0}},{"line":339,"address":[9286036],"length":1,"stats":{"Line":0}},{"line":344,"address":[9286601,9286762],"length":1,"stats":{"Line":0}},{"line":346,"address":[10181291],"length":1,"stats":{"Line":0}},{"line":347,"address":[10181438],"length":1,"stats":{"Line":0}},{"line":357,"address":[10182006],"length":1,"stats":{"Line":0}},{"line":358,"address":[10182055],"length":1,"stats":{"Line":0}},{"line":361,"address":[10182135],"length":1,"stats":{"Line":0}},{"line":364,"address":[10179456],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":114},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","algorithm","utils.rs"],"content":"//! Utility functions specifically for the algorithm module.\n\nuse leptos::logging;\nuse rand::{\n    seq::SliceRandom,\n    thread_rng,\n};\n\nuse super::AlgorithmSettings;\nuse crate::models::{\n    Edge,\n    GridNode,\n    Map,\n};\n\n/// Marks all stations and edges on the map as unsettled, freeing their location\n/// for moving in the algorithm.\npub fn unsettle_map(map: \u0026mut Map) {\n    for station in map.get_mut_stations() {\n        station.unsettle();\n    }\n    for edge in map.get_mut_edges() {\n        edge.unsettle();\n    }\n}\n\n/// Randomizes the order of the edges in the given vector.\npub fn randomize_edges(edges: \u0026mut [Edge]) {\n    let mut rng = thread_rng();\n    edges.shuffle(\u0026mut rng);\n}\n\n/// Returns true if the given node is outside the grid limits.\npub fn node_outside_grid(settings: AlgorithmSettings, node: GridNode) -\u003e bool {\n    node.0\n        \u003c settings\n            .grid_x_limits\n            .0\n        || node.0\n            \u003e settings\n                .grid_x_limits\n                .1\n        || node.1\n            \u003c settings\n                .grid_y_limits\n                .0\n        || node.1\n            \u003e settings\n                .grid_y_limits\n                .1\n}\n\n/// Returns the amount of overlap between two slices.\npub fn overlap_amount\u003cT: PartialEq\u003e(left: \u0026[T], right: \u0026[T]) -\u003e usize {\n    left.iter()\n        .filter(|\u0026l| right.contains(l))\n        .count()\n}\n\n/// Calculates the angle formed by three grid nodes and returns it in rounded\n/// degrees. The second point is assumed to be the middle node where the angle\n/// is located.\npub fn calculate_angle(first: GridNode, second: GridNode, third: GridNode) -\u003e f64 {\n    let l = (f64::from(first.1 - second.1)).atan2(f64::from(first.0 - second.0));\n    let r = (f64::from(third.1 - second.1)).atan2(f64::from(third.0 - second.0));\n    (l - r)\n        .abs()\n        .to_degrees()\n        .round()\n}\n\n/// Prints a debug message if the settings allow it.\npub fn debug_print(settings: AlgorithmSettings, msg: \u0026str, warn: bool) {\n    if settings.debug \u0026\u0026 warn {\n        logging::debug_warn!(\"{}\", msg);\n    } else if settings.debug {\n        logging::log!(\"{}\", msg);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_node_outside_grid() {\n        let mut settings = AlgorithmSettings::default();\n        settings.grid_x_limits = (0, 10);\n        settings.grid_y_limits = (0, 10);\n\n        assert!(node_outside_grid(\n            settings,\n            GridNode::from((-1, 0))\n        ));\n        assert!(node_outside_grid(\n            settings,\n            GridNode::from((0, -1))\n        ));\n        assert!(node_outside_grid(\n            settings,\n            GridNode::from((11, 0))\n        ));\n        assert!(node_outside_grid(\n            settings,\n            GridNode::from((0, 11))\n        ));\n        assert!(!node_outside_grid(\n            settings,\n            GridNode::from((0, 0))\n        ));\n        assert!(!node_outside_grid(\n            settings,\n            GridNode::from((10, 10))\n        ));\n    }\n\n    #[test]\n    fn test_overlap_amount() {\n        let left = vec![1, 2, 3, 0, 4, 5, 2];\n        let right = vec![8, 3, 4, 10, 5, 6, 7];\n        assert_eq!(overlap_amount(\u0026left, \u0026right), 3);\n    }\n\n    #[test]\n    fn test_calculate_angle() {\n        let first = GridNode::from((0, 0));\n        let second = GridNode::from((1, 1));\n        let third = GridNode::from((2, 0));\n        assert_eq!(\n            calculate_angle(first, second, third),\n            90.0\n        );\n    }\n}\n","traces":[{"line":18,"address":[9353184,9353648],"length":1,"stats":{"Line":0}},{"line":19,"address":[9606119,9606253,9606402],"length":1,"stats":{"Line":0}},{"line":20,"address":[9606415,9606612],"length":1,"stats":{"Line":0}},{"line":22,"address":[9606558,9606429,9606300,9606499],"length":1,"stats":{"Line":0}},{"line":23,"address":[9606574],"length":1,"stats":{"Line":0}},{"line":28,"address":[9606624,9606734],"length":1,"stats":{"Line":0}},{"line":29,"address":[9606647],"length":1,"stats":{"Line":0}},{"line":30,"address":[9606670],"length":1,"stats":{"Line":0}},{"line":34,"address":[9606768],"length":1,"stats":{"Line":1}},{"line":35,"address":[9606808,9606789],"length":1,"stats":{"Line":2}},{"line":39,"address":[9606803],"length":1,"stats":{"Line":1}},{"line":43,"address":[9606824],"length":1,"stats":{"Line":1}},{"line":47,"address":[9353878],"length":1,"stats":{"Line":1}},{"line":54,"address":[8840720],"length":1,"stats":{"Line":1}},{"line":55,"address":[8840754],"length":1,"stats":{"Line":1}},{"line":56,"address":[8840800,8840816],"length":1,"stats":{"Line":2}},{"line":63,"address":[9606864],"length":1,"stats":{"Line":1}},{"line":64,"address":[9607047,9606919,9606959,9607009],"length":1,"stats":{"Line":3}},{"line":65,"address":[9354074,9354223,9354176,9354129],"length":1,"stats":{"Line":6}},{"line":66,"address":[9607156],"length":1,"stats":{"Line":2}},{"line":73,"address":[9607200,9607694],"length":1,"stats":{"Line":1}},{"line":74,"address":[9607267,9607237],"length":1,"stats":{"Line":1}},{"line":75,"address":[9607716,9607341],"length":1,"stats":{"Line":0}},{"line":76,"address":[9607248],"length":1,"stats":{"Line":1}},{"line":77,"address":[9607515],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":25},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","atoms","button.rs"],"content":"//! Contains the [`Button`] component.\n\nuse leptos::{\n    ev::MouseEvent,\n    *,\n};\nuse leptos_dom::Text;\n\n/// The type of the on click event handler.\ntype OnButtonClick = Box\u003cdyn Fn(MouseEvent) + 'static\u003e;\n\n/// A clickable button html element.\n#[component]\npub fn Button(\n    /// The text displayed on the button.\n    text: \u0026'static str,\n    /// Gets called when the button is clicked.\n    on_click: OnButtonClick,\n    /// If false the button is filled-in with one color, else just the border\n    /// outline is shown.\n    #[prop(optional)]\n    outlined: bool,\n    /// If the button should be colored red (is blue otherwise).\n    #[prop(optional)]\n    danger: bool,\n    /// If the button is an overlay button.\n    #[prop(optional)]\n    overlay: bool,\n    /// If the button should be bigger, especially useful when having larger\n    /// text or icons.\n    #[prop(optional)]\n    bigger: bool,\n    /// If the button has been selected.\n    #[prop(optional)]\n    #[prop(into)]\n    active: Signal\u003cbool\u003e,\n    /// If focus can be held on the button.\n    #[prop(default = true)]\n    can_focus: bool,\n    /// The children of the button, if any.\n    /// If present, the button will show the text on hover.\n    #[prop(optional)]\n    children: Option\u003cChildren\u003e,\n) -\u003e impl IntoView {\n    let color = if danger {\n        \"red\"\n    } else if overlay {\n        \"gray\"\n    } else {\n        \"blue\"\n    };\n\n    let base = if danger { 600 } else { 400 };\n    let base_hover = base + 100;\n    let base_active = base + 200;\n    let dark = base + 200;\n    let dark_hover = dark + 100;\n    let dark_active = if dark \u003e= 800 { 950 } else { dark + 200 };\n\n    let class_func = move || {\n        let mut class = \"inline-block group px-4 \\\n        py-1.5 text-center uppercase \\\n        leading-snug shadow-neutral-800 \\\n        dark:shadow-neutral-950 hover:shadow-blue-900 \\\n        dark:hover:shadow-neutral-900\"\n            .to_owned();\n\n        if overlay \u0026\u0026 bigger {\n            class += \" rounded-full text-xl font-bold h-16 w-16\";\n        } else if overlay {\n            class += \" rounded-full text-xl font-bold h-11 w-11\";\n        } else {\n            class += \" rounded text-sm font-semibold\";\n        }\n\n        if outlined {\n            class += \u0026format!(\n                \" border-solid border-4 text-{color}-{base} \\\n            border-{color}-{base} hover:text-{color}-{base_hover} \\\n            hover:border-{color}-{base_hover} \\\n            active:text-{color}-{base_active} \\\n            active:border-{color}-{base_active} \\\n            dark:text-{color}-{dark} \\\n            dark:border-{color}-{dark} \\\n            dark:hover:text-{color}-{dark_hover} \\\n            dark:hover:border-{color}-{dark_hover} \\\n            dark:active:text-{color}-{dark_active} \\\n            dark:active:border-{color}-{dark_active}\"\n            );\n\n            if active.get() {\n                class += \u0026format!(\n                    \" text-{color}-{base_active} \\\n            border-{color}-{base_active} \\\n            dark:text-{color}-{dark_active} \\\n            dark:border-{color}-{dark_active}\"\n                );\n            } else if can_focus {\n                class += \u0026format!(\n                    \" focus:text-{color}-{base_active} \\\n            focus:border-{color}-{base_active} \\\n            dark:focus:text-{color}-{dark_active} \\\n            dark:focus:border-{color}-{dark_active}\"\n                );\n            }\n        } else {\n            class += \u0026format!(\n                \" text-white bg-{color}-{base} \\\n            hover:bg-{color}-{base_hover} \\\n            active:bg-{color}-{base_active} \\\n            dark:bg-{color}-{dark} \\\n            dark:hover:bg-{color}-{dark_hover} \\\n            dark:active:bg-{color}-{dark_active}\"\n            );\n\n            if active.get() {\n                class += \u0026format!(\" bg-{color}-{base_active} dark:bg-{color}-{dark_active}\");\n            } else if can_focus {\n                class +=\n                    \u0026format!(\" focus:bg-{color}-{base_active} dark:focus:bg-{color}-{dark_active}\");\n            }\n        }\n        class\n    };\n\n    let has_children = children.is_some();\n\n    let mut hover_class = \"hidden group-hover:block text-xs absolute z-10 \".to_owned();\n    if bigger {\n        hover_class += \"-top-8 -left-2.5\";\n    } else {\n        hover_class += \"-top-7 left-0.5\";\n    }\n\n    view! {\n        \u003cbutton\n            type=\"button\"\n            class=class_func\n            focus=active\n            on:click=on_click\u003e\n            \u003c\u003e\n                {children.map_or(Fragment::from(Text::new(text.into()).into_view()), |c| c())}\n                \u003cdiv class=hover_class\u003e\n                    {has_children.then_some(text)}\n                \u003c/div\u003e\n            \u003c/\u003e\n        \u003c/button\u003e\n    }\n}\n","traces":[{"line":14,"address":[8030004,8027360,8029946],"length":1,"stats":{"Line":0}},{"line":45,"address":[8027686,8027594],"length":1,"stats":{"Line":0}},{"line":46,"address":[8425995],"length":1,"stats":{"Line":0}},{"line":47,"address":[8426080,8426051,8425989],"length":1,"stats":{"Line":0}},{"line":48,"address":[8426053],"length":1,"stats":{"Line":0}},{"line":50,"address":[8426024],"length":1,"stats":{"Line":0}},{"line":53,"address":[8027783],"length":1,"stats":{"Line":0}},{"line":54,"address":[8426202,8426149],"length":1,"stats":{"Line":0}},{"line":55,"address":[8426267,8426297,8426179],"length":1,"stats":{"Line":0}},{"line":56,"address":[8426274,8426319,8426340],"length":1,"stats":{"Line":0}},{"line":57,"address":[8027990,8028046,8028030],"length":1,"stats":{"Line":0}},{"line":58,"address":[8028071,8028037],"length":1,"stats":{"Line":0}},{"line":60,"address":[8426517],"length":1,"stats":{"Line":0}},{"line":61,"address":[8131076],"length":1,"stats":{"Line":0}},{"line":68,"address":[9218693,9218723],"length":1,"stats":{"Line":0}},{"line":69,"address":[8131290,8131145],"length":1,"stats":{"Line":0}},{"line":70,"address":[8131123],"length":1,"stats":{"Line":0}},{"line":71,"address":[8131199,8131288],"length":1,"stats":{"Line":0}},{"line":73,"address":[8131172,8131270],"length":1,"stats":{"Line":0}},{"line":76,"address":[8131280],"length":1,"stats":{"Line":0}},{"line":77,"address":[8143528,8140668,8142868,8140008,8131400,8141988,8143748,8139082,8140228,8139564,8141328,8142648,8141108,8142208,8145068,8143968,8140888,8143308,8144188,8144848,8144408,8139278,8139376,8145985,8139474,8144628,8146064,8141768,8139180,8142428,8138984,8141548,8140448,8143088],"length":1,"stats":{"Line":0}},{"line":91,"address":[8146098],"length":1,"stats":{"Line":0}},{"line":92,"address":[8151340,8150291,8149095,8149631,8149851,8149005,8146157,8148907,8149411,8150071,8150511,8150951,8150731,8151419],"length":1,"stats":{"Line":0}},{"line":98,"address":[9233722],"length":1,"stats":{"Line":0}},{"line":99,"address":[8148402,8146862,8148791,8146260,8147522,8147742,8148870,8147302,8146456,8147962,8146546,8148182,8146358,8147082],"length":1,"stats":{"Line":0}},{"line":107,"address":[8134727,8134287,8131993,8131300,8131895,8133407,8135468,8134507,8134067,8132083,8132967,8131699,8133627,8134947,8132527,8132747,8135547,8131797,8133847,8133187,8131503,8131601],"length":1,"stats":{"Line":0}},{"line":116,"address":[8135581],"length":1,"stats":{"Line":0}},{"line":117,"address":[8135641,8137447,8138868,8137545,8137635,8137951,8138391,8138611,8138171],"length":1,"stats":{"Line":0}},{"line":118,"address":[8135621],"length":1,"stats":{"Line":0}},{"line":119,"address":[9224985],"length":1,"stats":{"Line":0}},{"line":120,"address":[8135803,8137322,8137408,8136625,8136089,8135901,8136845,8136405,8135999,8137065],"length":1,"stats":{"Line":0}},{"line":123,"address":[9223336],"length":1,"stats":{"Line":0}},{"line":126,"address":[8426676],"length":1,"stats":{"Line":0}},{"line":128,"address":[8426712],"length":1,"stats":{"Line":0}},{"line":129,"address":[8426754],"length":1,"stats":{"Line":0}},{"line":130,"address":[8426785,8426914],"length":1,"stats":{"Line":0}},{"line":132,"address":[8426758,8426893],"length":1,"stats":{"Line":0}},{"line":135,"address":[8162005],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","atoms","button_group.rs"],"content":"//! Contains the [`ButtonGroup`] component.\n\nuse leptos::*;\n\nuse super::button::ButtonProps;\n\n/// A group of buttons\n#[component]\npub fn ButtonGroup(\n    /// These will be transformed into [`super::Button`] elements.\n    children: Vec\u003cButtonProps\u003e,\n) -\u003e impl IntoView {\n    let class = \"max-w-full flex align-center gap-px [\u0026\u003e*]:flex-1 \\\n        [\u0026\u003e*:not(:first-child):not(:last-child)]:ml-0 \\\n        [\u0026\u003e*:not(:first-child):not(:last-child)]:rounded-none \\\n        [\u0026\u003e*:not(:only-child):first-child]:rounded-r-none \\\n        [\u0026\u003e*:not(:only-child):last-child]:rounded-l-none \\\n        [\u0026\u003e*:not(:only-child):last-child]:ml-0\";\n\n    view! {\n        \u003cdiv class=class\u003e\n            {children}\n        \u003c/div\u003e\n    }\n}\n","traces":[{"line":9,"address":[9282208,9281552,9282179],"length":1,"stats":{"Line":0}},{"line":13,"address":[9281574],"length":1,"stats":{"Line":0}},{"line":20,"address":[9281767],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","atoms","mod.rs"],"content":"//! Contains small components that do not contain child components.\n\nmod button;\nmod button_group;\nmod modal;\nmod number_input;\nmod toggle;\n\npub use button::{\n    Button,\n    ButtonProps,\n};\npub use button_group::ButtonGroup;\npub use modal::Modal;\npub use number_input::NumberInput;\npub use toggle::Toggle;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","atoms","modal.rs"],"content":"//! Contains the [`Modal`] component.\n\nuse std::path::Path;\n\nuse ev::MouseEvent;\nuse leptos::*;\nuse wasm_bindgen::{\n    closure::Closure,\n    JsCast,\n    JsValue,\n};\nuse web_sys::HtmlInputElement;\n\nuse crate::{\n    components::atoms::Button,\n    unwrap_or_return,\n    Error,\n};\n\n/// A generic modal that others can be based upon.\n#[component]\npub fn Modal\u003cC\u003e(\n    /// If the modal should be shown.\n    show: ReadSignal\u003cbool\u003e,\n    /// Gets called if the modal is closed by clicking outside the modal.\n    on_close: C,\n    /// The content of the modal.\n    children: Children,\n) -\u003e impl IntoView\nwhere\n    C: Fn() + 'static,\n{\n    let modal_ref: NodeRef\u003chtml::Div\u003e = create_node_ref();\n    let input_ref: NodeRef\u003chtml::Input\u003e = create_node_ref();\n\n    let on_outside_click = move |e: MouseEvent| {\n        // actual dom node that got clicked on\n        let target_node = e\n            .target()\n            .and_then(|t| {\n                t.dyn_ref::\u003cweb_sys::Node\u003e()\n                    .cloned()\n            });\n\n        // if the clicked node is outside the modal itself\n        if !modal_ref\n            .get()\n            .unwrap()\n            .contains(target_node.as_ref())\n        {\n            on_close();\n        }\n    };\n\n    view! {\n        \u003cdiv\n            id=\"modal\"\n            aria-hidden={move || if show() {\"false\"} else {\"true\"}}\n            tabindex=\"-1\"\n            style:display=move || if show() {\"flex\"} else {\"none\"}\n            class=\"overflow-y-auto overflow-x-hidden fixed top-0 right-0 left-0 z-50 justify-center items-center w-full md:inset-0 h-[calc(100%-1rem)] max-h-full\"\n            on:click=on_outside_click\u003e\n            \u003cdiv _ref=modal_ref class=\"relative p-4 w-full max-w-2xl max-h-full\"\u003e\n                // content\n                \u003cdiv class=\"relative bg-white rounded-lg shadow dark:bg-gray-700\"\u003e\n                    {children()}\n                \u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    }\n}\n","traces":[{"line":22,"address":[9482927,9480925,9481007,9482845,9479104,9481024],"length":1,"stats":{"Line":0}},{"line":33,"address":[8429860,8431844],"length":1,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[8432164,8430180],"length":1,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[8432562,8430578],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","atoms","number_input.rs"],"content":"//! Contains the [`NumberInput`] component.\n\nuse leptos::*;\n\n/// An input html element for number input.\n#[component]\npub fn NumberInput\u003cF, V\u003e(\n    /// The label on the input.\n    text: \u0026'static str,\n    /// Gets called when the number input is changed.\n    on_input: F,\n    /// Gets called to set the current input value.\n    #[prop(optional)]\n    value: Option\u003cV\u003e,\n    /// The minimum value (default: 0)\n    #[prop(optional)]\n    min: f64,\n    /// The maximum value (default: i32::MAX)\n    #[prop(default = (i32::MAX) as f64)]\n    max: f64,\n    /// The step value (default: 1.0)\n    #[prop(default = 1.0)]\n    step: f64,\n) -\u003e impl IntoView\nwhere\n    F: Fn(f64) + 'static,\n    V: (Fn() -\u003e f64) + Copy + 'static,\n{\n    let id = text\n        .to_lowercase()\n        .replace(' ', \"_\");\n\n    let parse_input = move |ev| {\n        let val = event_target_value(\u0026ev);\n\n        on_input(\n            val.parse()\n                .unwrap_or(min),\n        );\n    };\n\n    view! {\n    \u003cdiv class=\"relative mb-3\" data-twe-input-wrapper-init\u003e\n      \u003cinput\n        type=\"number\"\n        class=\"peer block min-h-[auto] w-full rounded border-b-2 rounded-md border-solid border-blue-400 bg-transparent px-3 py-[0.32rem] leading-[1.6] outline-none transition-all duration-200 ease-linear peer-focus:text-primary motion-reduce:transition-none dark:text-white dark:placeholder:text-neutral-300 dark:autofill:shadow-autofill dark:peer-focus:text-primary dark:border-blue-600 focus:border-blue-600 dark:focus:border-blue-800\"\n        id={id.clone()}\n        on:input=parse_input\n        max=max\n        min=min\n        step=step\n        prop:value=move || value.map(|v| v().max(min)) /\u003e\n      \u003clabel\n        for={id}\n        class=\"pointer-events-none absolute left-3 top-0 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-neutral-500 peer-focus:text-primary -translate-y-[0.9rem] scale-[0.8] dark:text-neutral-400 dark:peer-focus:text-primary\"\n        \u003e{text}\n      \u003c/label\u003e\n    \u003c/div\u003e\n        }\n}\n","traces":[{"line":7,"address":[9305296,9305205,9305278,9303168,9307333,9307424,9311589,9307406,9309461,9309534,9309552,9311662],"length":1,"stats":{"Line":0}},{"line":29,"address":[10224029,10226221,10219713,10219521,10221837,10221713,10224097,10226097,10226289,10219645,10221905,10223905],"length":1,"stats":{"Line":0}},{"line":33,"address":[10222018,10219826,10226402,10224210],"length":1,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[10222465,10220273,10226849,10224657],"length":1,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","atoms","toggle.rs"],"content":"//! Contains the [`Toggle`] component.\n\nuse leptos::*;\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlInputElement;\n\n/// An input html element for boolean input displayed as a toggle button.\n#[component]\npub fn Toggle\u003cF, V\u003e(\n    /// The label on the input.\n    text: \u0026'static str,\n    /// Gets called when the number input is changed.\n    on_input: F,\n    /// Gets called to set the current input value.\n    #[prop(optional)]\n    value: Option\u003cV\u003e,\n) -\u003e impl IntoView\nwhere\n    F: Fn(bool) + 'static,\n    V: (Fn() -\u003e bool) + Copy + 'static,\n{\n    let input_ref: NodeRef\u003chtml::Input\u003e = create_node_ref();\n\n    let id = text\n        .to_lowercase()\n        .replace(' ', \"_\");\n\n    let parse_input = move |ev| {\n        let input = input_ref\n            .get()\n            .unwrap();\n        let input_elem: \u0026HtmlInputElement = input.unchecked_ref();\n\n        on_input(input_elem.checked());\n    };\n\n    let input_class = \"\n        align-middle\n        inline-block\n        relative\n        w-10\n        h-5\n        transition-all\n        duration-200\n        ease-in-out\n        bg-gray-400\n        rounded-full\n        shadow-inner\n        outline-none\n        appearance-none\n        cursor-pointer\n        before:content-['']\n        before:absolute\n        before:w-5\n        before:h-5\n        before:rounded-[50%]\n        before:top-0\n        before:left-0\n        before:scale-[1.1]\n        before:shadow-[0_0.125rem_0.5rem_rgba(0,0,0,0.2)]\n        before:bg-white\n        before:duration-200\n        before:ease-in-out\n        checked:bg-indigo-400\n        checked:before:left-5\";\n\n    view! {\n    \u003cdiv class=\"relative mb-3\" data-twe-input-wrapper-init\u003e\n      \u003cinput\n        type=\"checkbox\"\n        class=input_class\n        id={id.clone()}\n        _ref=input_ref\n        on:input=parse_input\n        checked=move || value.map_or(false, |v| v())\n        prop:value=move || value.map(|v| v()) /\u003e\n      \u003cspan\n        class=\"pointer-events-none inline-block align-middle p-2 truncate pt-[0.37rem] text-neutral-500 peer-focus:text-primary dark:text-neutral-400 dark:peer-focus:text-primary\"\n        \u003e{text}\n      \u003c/span\u003e\n    \u003c/div\u003e\n        }\n}\n","traces":[{"line":9,"address":[7979120,7977023,7979103,7974960,7977040,7981129,7976969,7981183,7979049],"length":1,"stats":{"Line":0}},{"line":22,"address":[10304223,10302079,10306367],"length":1,"stats":{"Line":0}},{"line":24,"address":[10304425,10304520,10302281,10306569,10306664,10302376],"length":1,"stats":{"Line":0}},{"line":28,"address":[10304625,10306769,10302481],"length":1,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[10304196,10302052,10306340],"length":1,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[10307574,10305430,10303286],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":51},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","mod.rs"],"content":"//! Contains all leptos (html) components used for building the webpage.\n\nmod atoms;\nmod molecules;\nmod organisms;\nmod pages;\nmod state;\n\npub use pages::Home;\npub use state::{\n    CanvasState,\n    MapState,\n    StateProvider,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","molecules","canvas.rs"],"content":"//! Contains the [`Canvas`] component.\n\nuse std::sync::atomic::{\n    AtomicBool,\n    Ordering,\n};\n\nuse ev::UiEvent;\nuse leptos::{\n    html::Canvas as HtmlCanvas,\n    *,\n};\nuse wasm_bindgen::{\n    closure::Closure,\n    JsCast,\n};\n\nuse crate::{\n    components::{\n        state::ActionType,\n        CanvasState,\n        MapState,\n    },\n    models::{\n        EdgeID,\n        GridNode,\n        Map,\n        SelectedLine,\n        SelectedStation,\n    },\n};\n\n/// If the document has fully loaded.\nstatic DOCUMENT_LOADED: AtomicBool = AtomicBool::new(false);\n\n/// Calculates and updates the size of the canvas.\n///\n/// To have a canvas resize dynamically, we need to manually adjust its size\n/// CSS will NOT work, as it will just make everything blurry.\n/// This means we have to manually calculate the desired size of the canvas.\nfn update_canvas_size(map_state: \u0026RwSignal\u003cMapState\u003e) {\n    let doc = document();\n\n    // the navbar borders the top, so the height is `window - navbar`.\n    let win_height = window()\n        .inner_height()\n        .unwrap()\n        .as_f64()\n        .unwrap();\n\n    let navbar = doc\n        .get_element_by_id(\"navbar\")\n        .expect(\"navbar should exist\");\n    let nav_height_px = window()\n        .get_computed_style(\u0026navbar)\n        .unwrap()\n        .expect(\"should have style\")\n        .get_property_value(\"height\")\n        .expect(\"should have height property\");\n\n    let height = (win_height\n        - nav_height_px\n            .trim_end_matches(\"px\")\n            .parse::\u003cf64\u003e()\n            .expect(\"height should be a number\")\n            .round()) as u32;\n\n    // the sidebar borders its side, so width is `window - sidebar`.\n    let win_width = window()\n        .inner_width()\n        .unwrap()\n        .as_f64()\n        .unwrap();\n\n    let sidebar = doc\n        .get_element_by_id(\"sidebar\")\n        .expect(\"sidebar should exist\");\n    let side_width_px = window()\n        .get_computed_style(\u0026sidebar)\n        .unwrap()\n        .expect(\"should have style\")\n        .get_property_value(\"width\")\n        .expect(\"should have width property\");\n\n    let width = (win_width\n        - side_width_px\n            .trim_end_matches(\"px\")\n            .parse::\u003cf64\u003e()\n            .expect(\"width should be a number\")\n            .round()) as u32;\n\n    // update the state with the new size.\n    logging::log!(\n        \"new canvas size: ({}, {})\",\n        height,\n        width\n    );\n    map_state.update(|state| state.update_canvas_state(|canvas| canvas.set_size((height, width))));\n}\n\n/// Gets the position on the canvas that was clicked.\nfn canvas_click_pos(map_size: (u32, u32), ev: \u0026UiEvent) -\u003e (f64, f64) {\n    let win_height = window()\n        .inner_height()\n        .unwrap()\n        .as_f64()\n        .unwrap()\n        .round();\n    let win_width = window()\n        .inner_width()\n        .unwrap()\n        .as_f64()\n        .unwrap()\n        .round();\n\n    (\n        (f64::from(ev.page_x()) - (win_width - f64::from(map_size.1))),\n        (f64::from(ev.page_y()) - (win_height - f64::from(map_size.0))),\n    )\n}\n\n/// Helper function for recalculating an edge nodes.\nfn recalculate_edge_nodes(map: \u0026mut Map, edge_id: EdgeID) {\n    let edge = map\n        .get_edge(edge_id)\n        .cloned()\n        .expect(\"edge should exist\");\n    let mut edge = edge.clone();\n    edge.calculate_nodes(map);\n    map.add_edge(edge);\n}\n\n/// Listener for the [mousedown] event on the canvas.\n///\n/// [mousedown]: https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event\nfn on_mouse_down(map_state: \u0026mut MapState, ev: \u0026UiEvent) {\n    // Actions are only performed on mouseup\n    if map_state\n        .get_selected_action()\n        .is_some()\n    {\n        return;\n    }\n\n    let mut map = map_state\n        .get_map()\n        .clone();\n    let canvas_state = map_state.get_canvas_state();\n\n    // Handle a click while having a new station selected.\n    if let Some(selected) = map_state\n        .get_selected_station()\n        .cloned()\n    {\n        map.add_station(selected.deselect());\n        map_state.clear_selected_station();\n        map_state.set_map(map);\n        return;\n    }\n\n    let canvas_pos = canvas_click_pos(canvas_state.get_size(), ev);\n    let mouse_pos = GridNode::from_canvas_pos(canvas_pos, canvas_state);\n\n    // Handle a click while having a new line selected\n    if let Some(selected_line) = map_state\n        .get_selected_line()\n        .copied()\n    {\n        if let Some(station_at_pos) = map.station_at_node(mouse_pos) {\n            let (before, after) = selected_line.get_before_after();\n            let mut line = map\n                .get_or_add_line(selected_line.get_line())\n                .clone();\n\n            line.add_station(\u0026mut map, station_at_pos, before, after);\n\n            map.add_line(line);\n            map_state.set_map(map);\n            map_state.clear_selected_line();\n        }\n        return;\n    }\n\n    if let Some(mut selected_station) = map\n        .station_at_node(mouse_pos)\n        .and_then(|s| map.get_station(s))\n        .cloned()\n        .map(SelectedStation::new)\n    {\n        for line in map.get_lines() {\n            let (before, after) = line.get_station_neighbors(\n                \u0026map,\n                selected_station\n                    .get_station()\n                    .get_id(),\n            );\n            selected_station.add_before(before);\n            selected_station.add_after(after);\n        }\n\n        selected_station\n            .get_station()\n            .print_info();\n\n        map_state.set_selected_station(selected_station);\n        return;\n    }\n\n    if let Some(selected_line) = map\n        .line_at_node(mouse_pos)\n        .cloned()\n        .map(|l| SelectedLine::new(\u0026l, \u0026map, mouse_pos, Some(mouse_pos)))\n    {\n        map_state.set_selected_line(selected_line);\n        for edge in map.get_edges() {\n            if edge\n                .get_nodes()\n                .contains(\u0026mouse_pos)\n            {\n                edge.print_info();\n                break;\n            }\n        }\n    }\n}\n\n/// Listener for the [mouseup] event on the canvas.\n///\n/// [mouseup]: https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseup_event\nfn on_mouse_up(map_state: \u0026mut MapState, ev: \u0026UiEvent, shift_key: bool) {\n    let mut map = map_state\n        .get_map()\n        .clone();\n\n    let canvas_state = map_state.get_canvas_state();\n    let canvas_pos = canvas_click_pos(canvas_state.get_size(), ev);\n    let mouse_pos = GridNode::from_canvas_pos(canvas_pos, canvas_state);\n\n    // Handle a click while having an operation selected\n    if let Some(action_type) = map_state.get_selected_action() {\n        match action_type {\n            ActionType::RemoveStation =\u003e {\n                if let Some(station_id) = map.station_at_node(mouse_pos) {\n                    map.remove_station(station_id);\n                }\n            },\n            ActionType::RemoveLine =\u003e {\n                if let Some(selected_line) = map.line_at_node(mouse_pos) {\n                    map.remove_line(selected_line.get_id());\n                }\n            },\n            ActionType::LockStation =\u003e {\n                if let Some(station_id) = map.station_at_node(mouse_pos) {\n                    map.get_mut_station(station_id)\n                        .expect(\"Found station but id does not exit\")\n                        .lock();\n                }\n            },\n            ActionType::UnlockStation =\u003e {\n                if let Some(station_id) = map.station_at_node(mouse_pos) {\n                    map.get_mut_station(station_id)\n                        .expect(\"Found station but id does not exit\")\n                        .unlock();\n                }\n            },\n        }\n        map_state.set_map(map);\n        if !shift_key {\n            map_state.clear_selected_action();\n        }\n        return;\n    }\n\n    // Handle a mouseup while having a line selected\n    if let Some(selected_line) = map_state\n        .get_selected_line()\n        .copied()\n    {\n        if let Some(station_at_pos) = map.station_at_node(mouse_pos) {\n            let (before, after) = selected_line.get_before_after();\n            let mut line = map\n                .get_or_add_line(selected_line.get_line())\n                .clone();\n\n            line.add_station(\u0026mut map, station_at_pos, before, after);\n\n            if let Some(before_station) = before {\n                let edge_id = map.get_edge_id_between(before_station, station_at_pos);\n                recalculate_edge_nodes(\u0026mut map, edge_id);\n            }\n\n            if let Some(after_station) = after {\n                let edge_id = map.get_edge_id_between(station_at_pos, after_station);\n                recalculate_edge_nodes(\u0026mut map, edge_id);\n            }\n\n            map.add_line(line);\n            map_state.set_map(map);\n        }\n\n        map_state.clear_selected_line();\n        return;\n    }\n\n    // Handle a mouseup while having a station selected\n    let Some(selected_station) = map_state\n        .get_selected_station()\n        .cloned()\n        .map(SelectedStation::deselect)\n    else {\n        return;\n    };\n\n    let mut edge_ids = Vec::new();\n    for station in map.get_mut_stations() {\n        if *station == selected_station {\n            if station.get_pos() == selected_station.get_pos() {\n                break;\n            }\n\n            station.set_pos(selected_station.get_pos());\n            station.set_original_pos(selected_station.get_pos());\n            station.lock();\n            edge_ids = station\n                .get_edges()\n                .to_vec();\n            break;\n        }\n    }\n\n    for edge_id in edge_ids {\n        recalculate_edge_nodes(\u0026mut map, edge_id);\n    }\n\n    map_state.set_map(map);\n    map_state.clear_selected_station();\n}\n\n/// Listener for the [mousemove] event on the canvas.\n///\n/// [mousemove]: https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event\nfn on_mouse_move(map_state_signal: \u0026RwSignal\u003cMapState\u003e, ev: \u0026UiEvent) {\n    let mut map_state = map_state_signal.get();\n    let canvas_state = map_state.get_canvas_state();\n    let canvas_pos = canvas_click_pos(canvas_state.get_size(), ev);\n    let mouse_pos = GridNode::from_canvas_pos(canvas_pos, canvas_state);\n\n    // Handle move of selected line\n    if let Some(selected) = map_state.get_mut_selected_line() {\n        if selected.get_current_hover() != mouse_pos {\n            selected.set_current_hover(mouse_pos);\n            map_state_signal.set(map_state);\n        }\n        return;\n    }\n\n    // Handle move of selected station\n    let Some(mut selected) = map_state\n        .get_selected_station()\n        .cloned()\n    else {\n        return;\n    };\n\n    if mouse_pos == selected.get_pos() {\n        return;\n    }\n\n    selected.update_pos(mouse_pos);\n    map_state.set_selected_station(selected);\n    map_state_signal.set(map_state);\n}\n\n/// Listener for the [mouseout] event on the canvas.\n///\n/// [mouseout]: https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event\nfn on_mouse_out(map_state: \u0026mut MapState) {\n    map_state.clear_selected_station();\n    map_state.clear_selected_line();\n}\n\n/// Listener for when the user scrolls on the canvas.\nfn on_scroll(map_state: \u0026mut MapState, amount: f64) {\n    if amount \u003e 0.0 {\n        map_state.update_canvas_state(CanvasState::zoom_in);\n    } else {\n        map_state.update_canvas_state(CanvasState::zoom_out);\n    };\n}\n\n/// The canvas itself.\n/// This is where the map is drawn on and the user can interact with the map.\n#[component]\npub fn Canvas() -\u003e impl IntoView {\n    let canvas_ref = create_node_ref::\u003cHtmlCanvas\u003e();\n    let map_state =\n        use_context::\u003cRwSignal\u003cMapState\u003e\u003e().expect(\"to have found the global map state\");\n\n    // ensures we know the size of the canvas and that one page resizing, the canvas\n    // is also resized.\n    create_effect(move |_| {\n        update_canvas_size(\u0026map_state);\n\n        if !DOCUMENT_LOADED.load(Ordering::Relaxed) {\n            DOCUMENT_LOADED.store(true, Ordering::Release);\n            let f = Closure::\u003cdyn Fn()\u003e::new(move || update_canvas_size(\u0026map_state));\n            window().set_onresize(Some(\n                f.as_ref()\n                    .unchecked_ref(),\n            ));\n            f.forget();\n        }\n    });\n\n    // redraw the canvas if the map state changes.\n    create_effect(move |_| {\n        let canvas_node = \u0026canvas_ref\n            .get()\n            .expect(\"should be loaded now\");\n        let s = map_state\n            .get()\n            .get_canvas_state()\n            .get_size();\n        canvas_node.set_height(s.0);\n        canvas_node.set_width(s.1);\n\n        map_state\n            .get()\n            .draw_to_canvas(\u0026canvas_ref);\n    });\n\n    view! {\n        \u003cdiv class=\"absolute grow overflow-hidden bg-zinc-50 dark:bg-neutral-700 text-black dark:text-white\"\u003e\n            \u003ccanvas\n                _ref=canvas_ref\n\n                on:mousedown=move |ev| map_state.update(|state| on_mouse_down(state, ev.as_ref()))\n                on:mouseup=move |ev| map_state.update(|state| on_mouse_up(state, ev.as_ref(), ev.shift_key()))\n                on:mousemove=move |ev| on_mouse_move(\u0026map_state, ev.as_ref())\n                on:mouseout=move |_| map_state.update(on_mouse_out)\n\n                on:touchstart=move |ev| map_state.update(|state| on_mouse_down(state, ev.as_ref()))\n                on:touchend=move |ev| map_state.update(|state| on_mouse_up(state, ev.as_ref(), ev.shift_key()))\n                on:touchmove=move |ev| on_mouse_move(\u0026map_state, ev.as_ref())\n                on:touchcancel=move |_| map_state.update(on_mouse_out)\n\n                on:wheel=move |ev| map_state.update(|state| on_scroll(state, ev.delta_y()))\n\n                id=\"canvas\"\n                style=\"touch-action: none;\"\n                class=\"object-contain\"/\u003e\n        \u003c/div\u003e\n    }\n}\n","traces":[{"line":41,"address":[8489200,8502528],"length":1,"stats":{"Line":0}},{"line":42,"address":[9795782],"length":1,"stats":{"Line":0}},{"line":45,"address":[8489323,8489653,8489837,8489254],"length":1,"stats":{"Line":0}},{"line":51,"address":[8489884],"length":1,"stats":{"Line":0}},{"line":54,"address":[8490186,8490621,8490487,8489994,8490063],"length":1,"stats":{"Line":0}},{"line":61,"address":[9797537],"length":1,"stats":{"Line":0}},{"line":62,"address":[8490798],"length":1,"stats":{"Line":0}},{"line":69,"address":[8491578,8491394,8491036],"length":1,"stats":{"Line":0}},{"line":75,"address":[8491625],"length":1,"stats":{"Line":0}},{"line":78,"address":[8491927,8491735,8491804,8492228,8492362],"length":1,"stats":{"Line":0}},{"line":85,"address":[8492774],"length":1,"stats":{"Line":0}},{"line":86,"address":[8492571],"length":1,"stats":{"Line":0}},{"line":93,"address":[8493029],"length":1,"stats":{"Line":0}},{"line":98,"address":[8162720,8162784,8162816,8162752],"length":1,"stats":{"Line":0}},{"line":102,"address":[8502560,8503843],"length":1,"stats":{"Line":0}},{"line":103,"address":[8502611,8503095,8502929],"length":1,"stats":{"Line":0}},{"line":109,"address":[8503465,8503631,8503159],"length":1,"stats":{"Line":0}},{"line":117,"address":[8503703,8503760],"length":1,"stats":{"Line":0}},{"line":118,"address":[8503773,8503827],"length":1,"stats":{"Line":0}},{"line":123,"address":[9810384,9810789],"length":1,"stats":{"Line":0}},{"line":124,"address":[8503899],"length":1,"stats":{"Line":0}},{"line":128,"address":[8504049,8503997],"length":1,"stats":{"Line":0}},{"line":129,"address":[8504057],"length":1,"stats":{"Line":0}},{"line":130,"address":[8504118],"length":1,"stats":{"Line":0}},{"line":136,"address":[8504336,8505990,8507744],"length":1,"stats":{"Line":0}},{"line":138,"address":[8504375],"length":1,"stats":{"Line":0}},{"line":145,"address":[8504454],"length":1,"stats":{"Line":0}},{"line":148,"address":[9810977],"length":1,"stats":{"Line":0}},{"line":151,"address":[8504567],"length":1,"stats":{"Line":0}},{"line":155,"address":[8504735,8504694],"length":1,"stats":{"Line":0}},{"line":156,"address":[8504770],"length":1,"stats":{"Line":0}},{"line":157,"address":[9811231],"length":1,"stats":{"Line":0}},{"line":161,"address":[8504875],"length":1,"stats":{"Line":0}},{"line":162,"address":[9811433],"length":1,"stats":{"Line":0}},{"line":165,"address":[8505108],"length":1,"stats":{"Line":0}},{"line":169,"address":[8505361,8505963,8505244],"length":1,"stats":{"Line":0}},{"line":170,"address":[8505432],"length":1,"stats":{"Line":0}},{"line":171,"address":[8505566],"length":1,"stats":{"Line":0}},{"line":172,"address":[8505543],"length":1,"stats":{"Line":0}},{"line":175,"address":[8505664],"length":1,"stats":{"Line":0}},{"line":177,"address":[8505738],"length":1,"stats":{"Line":0}},{"line":178,"address":[8505869],"length":1,"stats":{"Line":0}},{"line":179,"address":[8505944],"length":1,"stats":{"Line":0}},{"line":184,"address":[8506015,8505293],"length":1,"stats":{"Line":0}},{"line":186,"address":[7455214,7455200],"length":1,"stats":{"Line":0}},{"line":190,"address":[8506473,8506988,8506163,8506253,8506417],"length":1,"stats":{"Line":0}},{"line":191,"address":[9813058],"length":1,"stats":{"Line":0}},{"line":193,"address":[8506494,8506675],"length":1,"stats":{"Line":0}},{"line":197,"address":[8506804],"length":1,"stats":{"Line":0}},{"line":198,"address":[8506905],"length":1,"stats":{"Line":0}},{"line":201,"address":[8506521],"length":1,"stats":{"Line":0}},{"line":205,"address":[8506561],"length":1,"stats":{"Line":0}},{"line":209,"address":[8507071],"length":1,"stats":{"Line":0}},{"line":212,"address":[8162880,8162915],"length":1,"stats":{"Line":0}},{"line":214,"address":[8507278],"length":1,"stats":{"Line":0}},{"line":215,"address":[8507388,8507579,8507638],"length":1,"stats":{"Line":0}},{"line":216,"address":[8507659],"length":1,"stats":{"Line":0}},{"line":220,"address":[8507731],"length":1,"stats":{"Line":0}},{"line":230,"address":[8507776,8511760,8510191],"length":1,"stats":{"Line":0}},{"line":231,"address":[9814105],"length":1,"stats":{"Line":0}},{"line":235,"address":[8507906],"length":1,"stats":{"Line":0}},{"line":236,"address":[8507954],"length":1,"stats":{"Line":0}},{"line":237,"address":[8508070],"length":1,"stats":{"Line":0}},{"line":240,"address":[8508205],"length":1,"stats":{"Line":0}},{"line":241,"address":[8508276],"length":1,"stats":{"Line":0}},{"line":243,"address":[8508362,8508564],"length":1,"stats":{"Line":0}},{"line":244,"address":[8508702,8508607],"length":1,"stats":{"Line":0}},{"line":248,"address":[9814940,9814670],"length":1,"stats":{"Line":0}},{"line":249,"address":[8508765],"length":1,"stats":{"Line":0}},{"line":253,"address":[8508828,8508458],"length":1,"stats":{"Line":0}},{"line":254,"address":[8508875],"length":1,"stats":{"Line":0}},{"line":260,"address":[8508510,8508988],"length":1,"stats":{"Line":0}},{"line":261,"address":[8509035],"length":1,"stats":{"Line":0}},{"line":267,"address":[8508626],"length":1,"stats":{"Line":0}},{"line":268,"address":[8509139],"length":1,"stats":{"Line":0}},{"line":269,"address":[8509183,8509153],"length":1,"stats":{"Line":0}},{"line":275,"address":[9815397,9814580],"length":1,"stats":{"Line":0}},{"line":279,"address":[8509316,8509397,8510164],"length":1,"stats":{"Line":0}},{"line":280,"address":[9815673,9815648],"length":1,"stats":{"Line":0}},{"line":281,"address":[8509588],"length":1,"stats":{"Line":0}},{"line":282,"address":[9815745],"length":1,"stats":{"Line":0}},{"line":285,"address":[8509654],"length":1,"stats":{"Line":0}},{"line":287,"address":[8509760],"length":1,"stats":{"Line":0}},{"line":288,"address":[8509843,8509795],"length":1,"stats":{"Line":0}},{"line":289,"address":[8509859],"length":1,"stats":{"Line":0}},{"line":292,"address":[9815990,9816044],"length":1,"stats":{"Line":0}},{"line":293,"address":[8510061,8509892],"length":1,"stats":{"Line":0}},{"line":294,"address":[8510077],"length":1,"stats":{"Line":0}},{"line":297,"address":[9816083],"length":1,"stats":{"Line":0}},{"line":298,"address":[8510089],"length":1,"stats":{"Line":0}},{"line":301,"address":[9815663,9816349],"length":1,"stats":{"Line":0}},{"line":306,"address":[9816370,9815547],"length":1,"stats":{"Line":0}},{"line":314,"address":[9816539],"length":1,"stats":{"Line":0}},{"line":315,"address":[9816689,9816604,9816825,9816880],"length":1,"stats":{"Line":0}},{"line":316,"address":[9816909],"length":1,"stats":{"Line":0}},{"line":317,"address":[8510833],"length":1,"stats":{"Line":0}},{"line":321,"address":[9817069],"length":1,"stats":{"Line":0}},{"line":322,"address":[9817112],"length":1,"stats":{"Line":0}},{"line":323,"address":[8511055],"length":1,"stats":{"Line":0}},{"line":324,"address":[8511223,8511071],"length":1,"stats":{"Line":0}},{"line":326,"address":[9817277],"length":1,"stats":{"Line":0}},{"line":327,"address":[8511279],"length":1,"stats":{"Line":0}},{"line":331,"address":[8511284,8511498,8511544],"length":1,"stats":{"Line":0}},{"line":332,"address":[8511707,8511568],"length":1,"stats":{"Line":0}},{"line":335,"address":[8511578],"length":1,"stats":{"Line":0}},{"line":336,"address":[8511653],"length":1,"stats":{"Line":0}},{"line":342,"address":[8512966,8513014,8511792],"length":1,"stats":{"Line":0}},{"line":343,"address":[8511837],"length":1,"stats":{"Line":0}},{"line":344,"address":[9817953],"length":1,"stats":{"Line":0}},{"line":345,"address":[9818009],"length":1,"stats":{"Line":0}},{"line":346,"address":[9818089],"length":1,"stats":{"Line":0}},{"line":349,"address":[9818190],"length":1,"stats":{"Line":0}},{"line":350,"address":[9818311,9818265],"length":1,"stats":{"Line":0}},{"line":351,"address":[9818386],"length":1,"stats":{"Line":0}},{"line":352,"address":[9818407],"length":1,"stats":{"Line":0}},{"line":358,"address":[9818492,9818288],"length":1,"stats":{"Line":0}},{"line":362,"address":[9818967],"length":1,"stats":{"Line":0}},{"line":365,"address":[9818582,9818664],"length":1,"stats":{"Line":0}},{"line":369,"address":[8512711],"length":1,"stats":{"Line":0}},{"line":370,"address":[8512766],"length":1,"stats":{"Line":0}},{"line":371,"address":[9818825],"length":1,"stats":{"Line":0}},{"line":377,"address":[8513056],"length":1,"stats":{"Line":0}},{"line":378,"address":[8513070],"length":1,"stats":{"Line":0}},{"line":379,"address":[9819064],"length":1,"stats":{"Line":0}},{"line":383,"address":[9819088],"length":1,"stats":{"Line":0}},{"line":384,"address":[9819107],"length":1,"stats":{"Line":0}},{"line":385,"address":[9819131],"length":1,"stats":{"Line":0}},{"line":387,"address":[8513136],"length":1,"stats":{"Line":0}},{"line":394,"address":[9830571,9819280,9830608],"length":1,"stats":{"Line":0}},{"line":395,"address":[8513349],"length":1,"stats":{"Line":0}},{"line":396,"address":[9819449],"length":1,"stats":{"Line":0}},{"line":401,"address":[7455424,7455804],"length":1,"stats":{"Line":0}},{"line":402,"address":[8163104],"length":1,"stats":{"Line":0}},{"line":404,"address":[7455469,7455799],"length":1,"stats":{"Line":0}},{"line":405,"address":[8163143],"length":1,"stats":{"Line":0}},{"line":406,"address":[8163504,8163509,8163175],"length":1,"stats":{"Line":0}},{"line":407,"address":[8163278,8163210,8163365],"length":1,"stats":{"Line":0}},{"line":408,"address":[7455635,7455690],"length":1,"stats":{"Line":0}},{"line":411,"address":[8163407],"length":1,"stats":{"Line":0}},{"line":416,"address":[8163520,8164090],"length":1,"stats":{"Line":0}},{"line":417,"address":[8163596],"length":1,"stats":{"Line":0}},{"line":420,"address":[8163787,8163652,8163739],"length":1,"stats":{"Line":0}},{"line":423,"address":[8163746,8163848],"length":1,"stats":{"Line":0}},{"line":424,"address":[8163867],"length":1,"stats":{"Line":0}},{"line":425,"address":[8163908],"length":1,"stats":{"Line":0}},{"line":427,"address":[8163954],"length":1,"stats":{"Line":0}},{"line":429,"address":[8164008],"length":1,"stats":{"Line":0}},{"line":432,"address":[8523969],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":148},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","molecules","file_downloader.rs"],"content":"//! Contains the [`FileDownloader`] component.\n\nuse leptos::*;\nuse wasm_bindgen::{\n    JsCast,\n    JsValue,\n};\nuse web_sys::{\n    js_sys::Array,\n    Blob,\n    BlobPropertyBag,\n    Url,\n};\n\nuse super::FileType;\nuse crate::{\n    components::{\n        atoms::Button,\n        MapState,\n    },\n    unwrap_or_return,\n    utils::json::encode_map,\n};\n\n/// A modal that lets the user download a file representing the map.\n#[component]\npub fn FileDownloader() -\u003e impl IntoView {\n    let map_state =\n        use_context::\u003cRwSignal\u003cMapState\u003e\u003e().expect(\"to have found the global map state\");\n\n    let download_map = move |file_type: FileType| {\n        let encoded = unwrap_or_return!(match file_type {\n            FileType::Json =\u003e {\n                let state = map_state.get_untracked();\n                encode_map(\n                    state.get_map(),\n                    state.get_canvas_state(),\n                )\n            },\n            FileType::GraphML =\u003e return,\n        });\n        let options = BlobPropertyBag::new();\n        options.set_type(file_type.to_mime_type());\n\n        let str_sequence = std::iter::once(JsValue::from_str(\u0026encoded)).collect::\u003cArray\u003e();\n        let blob = unwrap_or_return!(Blob::new_with_str_sequence_and_options(\n            \u0026str_sequence,\n            \u0026options\n        ));\n        let url = unwrap_or_return!(Url::create_object_url_with_blob(\u0026blob));\n\n        let elem = unwrap_or_return!(document().create_element(\"a\"))\n            .dyn_into::\u003cweb_sys::HtmlAnchorElement\u003e()\n            .expect(\"to convert the element to an anchor element\");\n\n        elem.set_href(\u0026url);\n        elem.set_download(\u0026format!(\n            \"metro-map.{}\",\n            match file_type {\n                FileType::Json =\u003e \"json\",\n                FileType::GraphML =\u003e \"graphml\",\n            }\n        ));\n        elem.click();\n\n        unwrap_or_return!(Url::revoke_object_url(\u0026url));\n    };\n\n    view! {\n        \u003cButton text=\"Download Map\" outlined=true can_focus=false on_click=Box::new(move |_| download_map(FileType::Json))/\u003e\n    }\n}\n","traces":[{"line":27,"address":[9694288],"length":1,"stats":{"Line":0}},{"line":28,"address":[9694305],"length":1,"stats":{"Line":0}},{"line":31,"address":[8888367,8888532,8886064],"length":1,"stats":{"Line":0}},{"line":32,"address":[8886099,8886308],"length":1,"stats":{"Line":0}},{"line":34,"address":[8886125],"length":1,"stats":{"Line":0}},{"line":35,"address":[9941327],"length":1,"stats":{"Line":0}},{"line":36,"address":[8886165],"length":1,"stats":{"Line":0}},{"line":37,"address":[8886252],"length":1,"stats":{"Line":0}},{"line":42,"address":[8886537,8886397],"length":1,"stats":{"Line":0}},{"line":43,"address":[8886544,8886635],"length":1,"stats":{"Line":0}},{"line":45,"address":[8886662],"length":1,"stats":{"Line":0}},{"line":46,"address":[9941901],"length":1,"stats":{"Line":0}},{"line":47,"address":[8886850,8886789],"length":1,"stats":{"Line":0}},{"line":50,"address":[8886950,8887057],"length":1,"stats":{"Line":0}},{"line":52,"address":[8887350,8887156,8887454,8887255,8887391],"length":1,"stats":{"Line":0}},{"line":56,"address":[8887570],"length":1,"stats":{"Line":0}},{"line":57,"address":[8887929,8888000,8887800],"length":1,"stats":{"Line":0}},{"line":59,"address":[8887616],"length":1,"stats":{"Line":0}},{"line":60,"address":[8887634],"length":1,"stats":{"Line":0}},{"line":61,"address":[8887663],"length":1,"stats":{"Line":0}},{"line":64,"address":[8888046],"length":1,"stats":{"Line":0}},{"line":66,"address":[8888082],"length":1,"stats":{"Line":0}},{"line":69,"address":[8888573,8888560],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","molecules","file_modal.rs"],"content":"//! Contains the [`FileModal`] component.\n\nuse std::path::Path;\n\nuse ev::MouseEvent;\nuse leptos::*;\nuse wasm_bindgen::{\n    closure::Closure,\n    JsCast,\n    JsValue,\n};\nuse web_sys::HtmlInputElement;\n\nuse crate::{\n    components::atoms::{\n        Button,\n        Modal,\n    },\n    unwrap_or_return,\n    Error,\n};\n\n/// The accepted file types.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FileType {\n    /// JSON file type.\n    Json,\n    /// GraphML file type.\n    GraphML,\n}\n\nimpl FileType {\n    /// Returns the MIME type of the file type.\n    pub fn to_mime_type(self) -\u003e \u0026'static str {\n        match self {\n            FileType::Json =\u003e \"application/json\",\n            FileType::GraphML =\u003e \"application/graphml+xml\",\n        }\n    }\n}\n\n/// Gets the file uploaded to the input element by the user and passes its\n/// contents to the provided `on_submit` callback function.\nfn get_file\u003cS\u003e(input: \u0026HtmlInputElement, on_submit: S)\nwhere\n    S: Fn(FileType, String) + 'static,\n{\n    let Some(file) = input\n        .files()\n        .and_then(|l| l.item(0))\n    else {\n        return;\n    };\n\n    let file_name = file.name();\n    let file_ext = Path::new(\u0026file_name).extension();\n\n    let file_type = if file_ext.map_or(false, |ext| {\n        ext.eq_ignore_ascii_case(\"json\")\n    }) {\n        FileType::Json\n    } else if file_ext.map_or(false, |ext| {\n        ext.eq_ignore_ascii_case(\"graphml\")\n    }) {\n        FileType::GraphML\n    } else {\n        return;\n    };\n\n    let cb = Closure::new(move |v: JsValue| {\n        on_submit(\n            file_type,\n            unwrap_or_return!(v\n                .as_string()\n                .ok_or(Error::other(\n                    \"file contents should be a string\"\n                ))),\n        );\n    });\n\n    let _ = file\n        .text()\n        .then(\u0026cb);\n\n    cb.forget();\n}\n\n/// A modal that asks the user to upload a file.\n#[component]\npub fn FileModal\u003cS, C\u003e(\n    /// If the modal should be shown.\n    show: ReadSignal\u003cbool\u003e,\n    /// Gets called on file submit with the contents of the file.\n    on_submit: S,\n    /// Gets called if the modal is closed without submit (the user clicks\n    /// outside of the modal).\n    on_close: C,\n) -\u003e impl IntoView\nwhere\n    S: Fn(FileType, String) + 'static + Copy,\n    C: Fn() + 'static,\n{\n    let input_ref: NodeRef\u003chtml::Input\u003e = create_node_ref();\n\n    view! {\n        \u003cModal show=show on_close=on_close\u003e\n            // body\n            \u003cdiv class=\"p-4 md:p-5 space-y-4\"\u003e\n                \u003clabel\n                    for=\"file-form\"\n                    class=\"mb-2 inline-block text-neutral-500 dark:text-neutral-400\"\u003e\n                    \"input file to upload to the map editor\"\n                \u003c/label\u003e\n                \u003cinput\n                    id=\"file-form\"\n                    _ref=input_ref\n                    type=\"file\"\n                    accept=\".json, .graphml\"\n                    class=\"relative m-0 block w-full min-w-0 flex-auto cursor-pointer rounded border border-solid border-secondary-500 bg-transparent bg-clip-padding px-3 py-[0.32rem] text-base font-normal text-surface transition duration-300 ease-in-out file:-mx-3 file:-my-[0.32rem] file:me-3 file:cursor-pointer file:overflow-hidden file:rounded-none file:border-0 file:border-e file:border-solid file:border-inherit file:bg-transparent file:px-3  file:py-[0.32rem] file:text-surface focus:border-primary focus:text-gray-700 focus:shadow-inset focus:outline-none dark:border-white/70 dark:text-white  file:dark:text-white\"/\u003e\n            \u003c/div\u003e\n            // footer\n            \u003cdiv class=\"flex items-center p-4 md:p-5 border-t border-gray-200 rounded-b dark:border-gray-600\"\u003e\n                \u003cButton text=\"Upload File\" on_click=Box::new(move |_| get_file(\u0026input_ref.get().unwrap(), on_submit))/\u003e\n            \u003c/div\u003e\n        \u003c/Modal\u003e\n    }\n}\n","traces":[{"line":34,"address":[9124800],"length":1,"stats":{"Line":0}},{"line":35,"address":[9124809],"length":1,"stats":{"Line":0}},{"line":36,"address":[9124824],"length":1,"stats":{"Line":0}},{"line":37,"address":[9124847],"length":1,"stats":{"Line":0}},{"line":44,"address":[9634922,9634953,9634016],"length":1,"stats":{"Line":0}},{"line":48,"address":[9634128,9634036],"length":1,"stats":{"Line":0}},{"line":50,"address":[9205944,9205936],"length":1,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[9205169],"length":1,"stats":{"Line":0}},{"line":56,"address":[9205251,9205316],"length":1,"stats":{"Line":0}},{"line":58,"address":[9635088,9634497,9634399,9634461],"length":1,"stats":{"Line":0}},{"line":59,"address":[9635102],"length":1,"stats":{"Line":0}},{"line":61,"address":[9634453],"length":1,"stats":{"Line":0}},{"line":62,"address":[9634467,9634436,9635136],"length":1,"stats":{"Line":0}},{"line":63,"address":[9635150],"length":1,"stats":{"Line":0}},{"line":65,"address":[9634489],"length":1,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[9635633,9634525,9635184],"length":1,"stats":{"Line":0}},{"line":71,"address":[9206168,9206412],"length":1,"stats":{"Line":0}},{"line":72,"address":[9635216],"length":1,"stats":{"Line":0}},{"line":73,"address":[9206193,9206314,9206355],"length":1,"stats":{"Line":0}},{"line":74,"address":[9635281],"length":1,"stats":{"Line":0}},{"line":75,"address":[9635289],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[9634612,9634670,9634770],"length":1,"stats":{"Line":0}},{"line":83,"address":[9205745,9205694],"length":1,"stats":{"Line":0}},{"line":85,"address":[9634815],"length":1,"stats":{"Line":0}},{"line":90,"address":[9636048,9636619],"length":1,"stats":{"Line":0}},{"line":103,"address":[9636080],"length":1,"stats":{"Line":0}},{"line":105,"address":[9636312],"length":1,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","molecules","mod.rs"],"content":"//! Contains components that contain child components or have complex state\n//! interactions.\n\nmod canvas;\nmod file_downloader;\nmod file_modal;\nmod settings_modal;\n\npub use canvas::Canvas;\npub use file_downloader::FileDownloader;\npub use file_modal::{\n    FileModal,\n    FileType,\n};\npub use settings_modal::SettingsModal;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","molecules","settings_modal.rs"],"content":"//! Contains the [`SettingsModal`] component.\n\nuse std::path::Path;\n\nuse ev::MouseEvent;\nuse leptos::*;\nuse wasm_bindgen::{\n    closure::Closure,\n    JsCast,\n    JsValue,\n};\nuse web_sys::HtmlInputElement;\n\nuse crate::{\n    components::atoms::{\n        Button,\n        Modal,\n        NumberInput,\n        Toggle,\n    },\n    unwrap_or_return,\n    Error,\n    MapState,\n};\n\n/// A modal for changing the settings of the algorithm.\n#[component]\npub fn SettingsModal\u003cC\u003e(\n    /// If the modal should be shown.\n    show: ReadSignal\u003cbool\u003e,\n    /// Gets called if the modal is closed.\n    on_close: C,\n) -\u003e impl IntoView\nwhere\n    C: Fn() + Clone + 'static,\n{\n    let map_state =\n        use_context::\u003cRwSignal\u003cMapState\u003e\u003e().expect(\"to have found the global map state\");\n\n    let update_square_size = move |mut n: f64| {\n        if n \u003c 1.0 {\n            n = 1.0;\n        }\n\n        map_state\n            .update(|state| state.update_canvas_state(|canvas| canvas.set_square_size(n as u32)));\n    };\n\n    view! {\n        \u003cModal show=show on_close=on_close.clone()\u003e\n            // body\n            \u003cdiv class=\"p-4 md:p-5 space-y-4\"\u003e\n                \u003cToggle\n                    text=\"Enable debug output.\"\n                    value=move || map_state.get().get_algorithm_settings().debug\n                    on_input=move |b| {\n                        map_state\n                            .update(|state| state.update_algorithm_settings(|settings| {\n                                settings.debug = b;\n                            }));\n                    }/\u003e\n                \u003cToggle\n                    text=\"Enable local search result optimization.\"\n                    value=move || map_state.get().get_algorithm_settings().local_search\n                    on_input=move |b| {\n                        map_state\n                            .update(|state| state.update_algorithm_settings(|settings| {\n                                settings.local_search = b;\n                            }));\n                    }/\u003e\n                \u003cToggle\n                    text=\"Enable station relocation (off equals setting the node-set radius to 0).\"\n                    value=move || map_state.get().get_algorithm_settings().allow_station_relocation\n                    on_input=move |b| {\n                        map_state\n                            .update(|state| state.update_algorithm_settings(|settings| {\n                                settings.allow_station_relocation = b;\n                            }));\n                    }/\u003e\n                \u003cNumberInput\n                    text=\"Set canvas grid size.\"\n                    min=2.0\n                    max=100.0\n                    value=move || f64::from(map_state.get().get_canvas_state().get_square_size())\n                    on_input=update_square_size/\u003e\n                \u003cNumberInput\n                    text=\"Set maximum number of algorithm iterations.\"\n                    min=1.0\n                    max=20.0\n                    value=move || map_state.get().get_algorithm_settings().edge_routing_attempts as f64\n                    on_input=move |n| {\n                        map_state\n                            .update(|state| state.update_algorithm_settings(|settings| {\n                                settings.edge_routing_attempts = n.round().abs() as usize;\n                            }));\n                    }/\u003e\n                \u003cNumberInput\n                    text=\"Set the node-set radius for possible station placement in algorithm pathfinding.\"\n                    min=0.0\n                    max=20.0\n                    value=move || f64::from(map_state.get().get_algorithm_settings().node_set_radius)\n                    on_input=move |n| {\n                        map_state\n                            .update(|state| state.update_algorithm_settings(|settings| {\n                                settings.node_set_radius = n.round().abs() as i32;\n                            }));\n                    }/\u003e\n                \u003cNumberInput\n                    text=\"Set the cost for extending an edge with one node.\"\n                    min=0.0\n                    max=10.0\n                    step=0.1\n                    value=move || map_state.get().get_algorithm_settings().move_cost\n                    on_input=move |n| {\n                        map_state\n                            .update(|state| state.update_algorithm_settings(|settings| {\n                                settings.move_cost = n;\n                            }));\n                    }/\u003e\n            \u003c/div\u003e\n            // footer\n            \u003cdiv class=\"flex items-center p-4 md:p-5 border-t border-gray-200 rounded-b dark:border-gray-600\"\u003e\n                \u003cButton text=\"Done\" on_click=Box::new(move |_| on_close())/\u003e\n            \u003c/div\u003e\n        \u003c/Modal\u003e\n    }\n}\n","traces":[{"line":28,"address":[9694272,9694755],"length":1,"stats":{"Line":0}},{"line":37,"address":[9556587],"length":1,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[9556708],"length":1,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[9558695],"length":1,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","organisms","canvas_controls.rs"],"content":"//! Contains the [`CanvasControls`] component.\n\n// Async is used for futures, which are used in the worker, even though the algorithm itself is\n// sync.\n#![allow(clippy::unused_async)]\n\nuse ev::KeyboardEvent;\nuse html::Div;\nuse leptos::{\n    logging,\n    *,\n};\nuse leptos_workers::{\n    executors::{\n        AbortHandle,\n        PoolExecutor,\n    },\n    worker,\n};\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse crate::{\n    algorithm::{\n        self,\n        AlgorithmSettings,\n    },\n    components::{\n        atoms::Button,\n        molecules::Canvas,\n        CanvasState,\n        MapState,\n    },\n    models::Map,\n    unwrap_or_return,\n    utils::{\n        IDData,\n        IDManager,\n        Result as AlgrithmResult,\n    },\n};\n\n/// The request to run the algorithm.\n#[derive(Clone, Serialize, Deserialize)]\nstruct AlgorithmRequest {\n    /// The settings for the algorithm.\n    settings: AlgorithmSettings,\n    /// The data for the [`IDManager`] to ensure the ids potentially generated\n    /// in the algorithm are unique.\n    id_manager_data: IDData,\n    /// The map to run the algorithm on.\n    map: Map,\n}\n\n/// The response from the algorithm.\n#[derive(Clone, Serialize, Deserialize)]\nstruct AlgorithmResponse {\n    /// If the algorithm ran successfully.\n    success: bool,\n    /// The Map outputted by the algorithm.\n    map: Map,\n    /// The data for the [`IDManager`] after the algorithm has run, ensuring the\n    /// main thread will not create IDs in conflict with those in the map.\n    id_manager_data: IDData,\n}\n\n/// The worker that runs the algorithm.\n#[worker(AlgorithmWorker)]\nfn run_algorithm(req: AlgorithmRequest) -\u003e AlgorithmResponse {\n    IDManager::from_data(req.id_manager_data);\n\n    let mut temp_state = MapState::new(req.map);\n    temp_state.set_algorithm_settings(req.settings);\n\n    let success = temp_state.run_algorithm();\n\n    AlgorithmResponse {\n        success,\n        map: temp_state\n            .get_map()\n            .clone(),\n        id_manager_data: IDManager::to_data(),\n    }\n}\n\n/// The canvas and the controls overlayed on it.\n#[component]\npub fn CanvasControls() -\u003e impl IntoView {\n    let container_ref = create_node_ref::\u003cDiv\u003e();\n    let map_state =\n        use_context::\u003cRwSignal\u003cMapState\u003e\u003e().expect(\"to have found the global map state\");\n    let (is_calculating, set_calculating) = create_signal(false);\n    let (executor, _) = create_signal(\n        PoolExecutor::\u003cAlgorithmWorker\u003e::new(1).expect(\"failed to start web-worker pool\"),\n    );\n    let (abort_handle, set_abort_handle) =\n        create_signal(Option::\u003cAbortHandle\u003cAlgorithmWorker\u003e\u003e::None);\n\n    create_effect(move |_| {\n        window_event_listener(\n            ev::keydown,\n            move |keyevent: KeyboardEvent| {\n                map_state.update(|state| {\n                    state.update_canvas_state(|canvas| {\n                        match keyevent\n                            .key()\n                            .as_str()\n                        {\n                            \"ArrowDown\" =\u003e canvas.move_down(),\n                            \"ArrowUp\" =\u003e canvas.move_up(),\n                            \"ArrowLeft\" =\u003e canvas.move_left(),\n                            \"ArrowRight\" =\u003e canvas.move_right(),\n                            _ =\u003e {},\n                        }\n                    });\n                });\n            },\n        );\n    });\n\n    let algorithm_req = create_action(move |req: \u0026AlgorithmRequest| {\n        let req = req.clone();\n        async move {\n            let (abort_handle, resp_fut) = executor\n                .get_untracked()\n                .run(req)\n                .expect(\"failed to start algorithm worker\");\n            set_abort_handle(Some(abort_handle));\n            let resp = resp_fut.await;\n            if resp.success {\n                map_state.update(|state| {\n                    state.set_map(resp.map);\n                });\n                IDManager::from_data(resp.id_manager_data);\n            }\n        }\n    });\n\n    let zoom_in =\n        move |_| map_state.update(|state| state.update_canvas_state(CanvasState::zoom_in));\n    let zoom_out =\n        move |_| map_state.update(|state| state.update_canvas_state(CanvasState::zoom_out));\n    let run_algorithm = move |_| {\n        let req = AlgorithmRequest {\n            settings: map_state\n                .get_untracked()\n                .get_algorithm_settings(),\n            map: map_state\n                .get_untracked()\n                .get_map()\n                .clone(),\n            id_manager_data: IDManager::to_data(),\n        };\n\n        algorithm_req.dispatch(req);\n    };\n    let abort_algorithm = move |_| {\n        if algorithm_req\n            .pending()\n            .get()\n        {\n            if let Some(handle) = abort_handle.get() {\n                handle.abort();\n                algorithm_req.set_pending(false);\n            }\n        }\n    };\n\n    let algorithm_button_class = move || {\n        let mut class = \"absolute right-5 top-5 group\".to_owned();\n\n        if algorithm_req\n            .pending()\n            .get()\n        {\n            class += \" is-calculating\";\n        }\n\n        class\n    };\n\n    view! {\n    \u003cdiv _ref=container_ref id=\"canvas-container\" class=\"grow flex self-stretch relative\"\u003e\n        \u003cCanvas/\u003e\n        \u003cdiv class=algorithm_button_class\u003e\n            \u003cButton text=\"recalculate map\" on_click=Box::new(run_algorithm) overlay=true can_focus=false bigger=true\u003e\n                \u003csvg class=\"h-8 w-8 text-blue-500 group-[.is-calculating]:animate-spin\"  width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\n                    \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\"/\u003e\n                    \u003cpath d=\"M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -5v5h5\" /\u003e\n                    \u003cpath d=\"M4 13a8.1 8.1 0 0 0 15.5 2m.5 5v-5h-5\" /\u003e\n                \u003c/svg\u003e\n            \u003c/Button\u003e\n        \u003c/div\u003e\n        \u003cShow when=move || algorithm_req.pending().get()\u003e\n            \u003cdiv class=\"absolute right-5 top-24\"\u003e\n                \u003cButton text=\"abort\" on_click=Box::new(abort_algorithm) overlay=true can_focus=false \u003e\u003cspan class=\"text-red-300\"\u003ex\u003c/span\u003e\u003c/Button\u003e\n            \u003c/div\u003e\n        \u003c/Show\u003e\n        \u003cdiv class=\"absolute right-5 bottom-20\"\u003e\n            \u003cButton text=\"zoom in\" on_click=Box::new(zoom_in) overlay=true can_focus=false \u003e+\u003c/Button\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"absolute right-5 bottom-5\"\u003e\n            \u003cButton text=\"zoom out\" on_click=Box::new(zoom_out) overlay=true can_focus=false\u003e-\u003c/Button\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n    }\n}\n","traces":[{"line":71,"address":[9410547,9411400],"length":1,"stats":{"Line":0}},{"line":72,"address":[7396379],"length":1,"stats":{"Line":0}},{"line":74,"address":[9410701],"length":1,"stats":{"Line":0}},{"line":75,"address":[9410765],"length":1,"stats":{"Line":0}},{"line":77,"address":[9410884],"length":1,"stats":{"Line":0}},{"line":81,"address":[7396765,7396700],"length":1,"stats":{"Line":0}},{"line":84,"address":[9411008],"length":1,"stats":{"Line":0}},{"line":90,"address":[9475382,9475413,9466048],"length":1,"stats":{"Line":0}},{"line":91,"address":[9466101],"length":1,"stats":{"Line":0}},{"line":92,"address":[9466298],"length":1,"stats":{"Line":0}},{"line":94,"address":[10008318],"length":1,"stats":{"Line":0}},{"line":96,"address":[10008404],"length":1,"stats":{"Line":0}},{"line":98,"address":[9466561],"length":1,"stats":{"Line":0}},{"line":101,"address":[9411984],"length":1,"stats":{"Line":0}},{"line":102,"address":[9412019],"length":1,"stats":{"Line":0}},{"line":104,"address":[9421279,9412002,9412064],"length":1,"stats":{"Line":0}},{"line":105,"address":[9421312],"length":1,"stats":{"Line":0}},{"line":106,"address":[7407056,7407033,7407419],"length":1,"stats":{"Line":0}},{"line":107,"address":[7407075,7407166],"length":1,"stats":{"Line":0}},{"line":111,"address":[9421557,9421737,9421486],"length":1,"stats":{"Line":0}},{"line":112,"address":[9421529,9421619,9421735,9421575],"length":1,"stats":{"Line":0}},{"line":113,"address":[9421591,9421634,9421733,9421678],"length":1,"stats":{"Line":0}},{"line":114,"address":[7407377,7407404,7407338],"length":1,"stats":{"Line":0}},{"line":123,"address":[9421760],"length":1,"stats":{"Line":0}},{"line":124,"address":[9421811],"length":1,"stats":{"Line":0}},{"line":125,"address":[9421952,9422187,9423012,9432842,9422013,9421831],"length":1,"stats":{"Line":0}},{"line":126,"address":[9422346,9422417,9422078],"length":1,"stats":{"Line":0}},{"line":128,"address":[9422278],"length":1,"stats":{"Line":0}},{"line":129,"address":[9422373,9422613],"length":1,"stats":{"Line":0}},{"line":130,"address":[9422680],"length":1,"stats":{"Line":0}},{"line":131,"address":[9422813,9423053,9422960,9422217],"length":1,"stats":{"Line":0}},{"line":132,"address":[9423312,9432651],"length":1,"stats":{"Line":0}},{"line":133,"address":[9432896,9423327],"length":1,"stats":{"Line":0}},{"line":134,"address":[7418522],"length":1,"stats":{"Line":0}},{"line":136,"address":[9432600],"length":1,"stats":{"Line":0}},{"line":141,"address":[7427744,7427648,7418560,7427753],"length":1,"stats":{"Line":0}},{"line":143,"address":[10013594],"length":1,"stats":{"Line":0}},{"line":145,"address":[9471662],"length":1,"stats":{"Line":0}},{"line":147,"address":[9451477,9451560],"length":1,"stats":{"Line":0}},{"line":150,"address":[9451717,9451613],"length":1,"stats":{"Line":0}},{"line":154,"address":[9451724],"length":1,"stats":{"Line":0}},{"line":157,"address":[9452024],"length":1,"stats":{"Line":0}},{"line":159,"address":[10013640],"length":1,"stats":{"Line":0}},{"line":160,"address":[9452199,9452255,9452553],"length":1,"stats":{"Line":0}},{"line":164,"address":[9452313],"length":1,"stats":{"Line":0}},{"line":165,"address":[7437920],"length":1,"stats":{"Line":0}},{"line":166,"address":[9452503],"length":1,"stats":{"Line":0}},{"line":171,"address":[9471722],"length":1,"stats":{"Line":0}},{"line":172,"address":[7438088],"length":1,"stats":{"Line":0}},{"line":174,"address":[9452643,9452694],"length":1,"stats":{"Line":0}},{"line":178,"address":[9452772],"length":1,"stats":{"Line":0}},{"line":181,"address":[9452741],"length":1,"stats":{"Line":0}},{"line":184,"address":[9460293,9460048,9460359,9463812,9460336],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":53},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","organisms","mod.rs"],"content":"//! Contains large, complex components that make up major elements of the page\n//! and consist of multiple child components.\n\nmod canvas_controls;\nmod navbar;\nmod sidebar;\n\npub use canvas_controls::CanvasControls;\npub use navbar::Navbar;\npub use sidebar::Sidebar;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","organisms","navbar.rs"],"content":"//! Contains the [`Navbar`] component.\n\nuse leptos::*;\n\nuse crate::{\n    components::{\n        atoms::Button,\n        molecules::{\n            FileDownloader,\n            FileModal,\n            FileType,\n            SettingsModal,\n        },\n        MapState,\n    },\n    unwrap_or_return,\n    utils::{\n        graphml,\n        json,\n    },\n};\n\n/// The navbar at the top of the page.\n/// Also contains the modal for uploading a file.\n#[component]\npub fn Navbar() -\u003e impl IntoView {\n    let (show_file_modal, set_show_file_modal) = create_signal(false);\n    let (show_settings_modal, set_show_settings_modal) = create_signal(false);\n    let map_state =\n        use_context::\u003cRwSignal\u003cMapState\u003e\u003e().expect(\"to have found the global map state\");\n\n    let on_submit = move |file_type: FileType, s: String| {\n        set_show_file_modal(false);\n\n        map_state.update(|state| {\n            let map = unwrap_or_return!(match file_type {\n                FileType::Json =\u003e {\n                    json::decode_map(\u0026s, state.get_canvas_state())\n                },\n                FileType::GraphML =\u003e {\n                    graphml::decode_map(\u0026s, state.get_canvas_state())\n                },\n            });\n\n            state.set_map(map.clone());\n            state.set_last_loaded(map);\n        });\n    };\n\n    view! {\n    \u003cnav id=\"navbar\" class=\"pr-4 max-h-20 relative flex w-full items-center justify-between bg-zinc-100 py-2 shadow-dark-mild shadow-sm dark:shadow-neutral-900 dark:bg-neutral-750 lg:py-4\"\u003e\n      \u003cdiv class=\"flex w-full items-center justify-between px-3\"\u003e\n        \u003cdiv class=\"ms-2\"\u003e\n          \u003ca class=\"text-2xl font-extrabold text-black dark:text-white\" href=\"#\"\u003eMetro Map Editor\u003c/a\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"flex flex-row items-end space-x-3\" \u003e\n            \u003cButton text=\"Advanced Settings\" outlined=true on_click=Box::new(move |_| set_show_settings_modal(true))/\u003e\n            \u003cFileDownloader/\u003e\n            \u003cButton text=\"Upload File\" outlined=true on_click=Box::new(move |_| set_show_file_modal(true))/\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/nav\u003e\n    \u003cFileModal\n        show=show_file_modal\n        on_close=move || set_show_file_modal(false)\n        on_submit=on_submit /\u003e\n    \u003cSettingsModal\n        show=show_settings_modal\n        on_close=move || set_show_settings_modal(false) /\u003e\n    }\n}\n","traces":[{"line":26,"address":[9011200],"length":1,"stats":{"Line":0}},{"line":27,"address":[9011217],"length":1,"stats":{"Line":0}},{"line":28,"address":[9011278],"length":1,"stats":{"Line":0}},{"line":29,"address":[9011324],"length":1,"stats":{"Line":0}},{"line":32,"address":[8997648,9007033],"length":1,"stats":{"Line":0}},{"line":35,"address":[8997830,9007056,9007634,9007605],"length":1,"stats":{"Line":0}},{"line":36,"address":[9007086,9007254],"length":1,"stats":{"Line":0}},{"line":38,"address":[9007112],"length":1,"stats":{"Line":0}},{"line":41,"address":[9007184],"length":1,"stats":{"Line":0}},{"line":45,"address":[9007376,9007509],"length":1,"stats":{"Line":0}},{"line":46,"address":[9007528],"length":1,"stats":{"Line":0}},{"line":50,"address":[9009981,9007779,9010032,9009591,9010597,9010280,9009006,9010095,9007842,9010330],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","organisms","sidebar.rs"],"content":"//! Contains the [`Sidebar`] component.\n\nuse leptos::*;\n\nuse crate::{\n    components::{\n        atoms::{\n            Button,\n            ButtonGroup,\n            ButtonProps,\n            NumberInput,\n        },\n        state::ActionType,\n        MapState,\n    },\n    models::{\n        Line,\n        Map,\n        SelectedLine,\n        SelectedStation,\n        Station,\n    },\n};\n\n/// The sidebar component with all the tools on there for editing the canvas.\n#[component]\npub fn Sidebar() -\u003e impl IntoView {\n    let map_state =\n        use_context::\u003cRwSignal\u003cMapState\u003e\u003e().expect(\"to have found the global map state\");\n\n    let action_selected = move |action| {\n        Signal::derive(move || {\n            map_state\n                .get()\n                .get_selected_action()\n                == Some(action)\n        })\n    };\n\n    let add_station = move |_| {\n        map_state.update(|state| {\n            state.set_selected_station(SelectedStation::new_station());\n        });\n    };\n\n    let add_line = move |_| {\n        map_state.update(|state| {\n            let line = SelectedLine::new_line(state.get_mut_map());\n            state.set_selected_line(line);\n        });\n    };\n\n    let remove_station = move |_| {\n        map_state.update(|state| {\n            state.set_selected_action(ActionType::RemoveStation);\n        });\n    };\n    let remove_station_selected = action_selected(ActionType::RemoveStation);\n\n    let remove_line = move |_| {\n        map_state.update(|state| {\n            state.set_selected_action(ActionType::RemoveLine);\n        });\n    };\n    let remove_line_selected = action_selected(ActionType::RemoveLine);\n\n    let lock_station = move |_| {\n        map_state.update(|state| {\n            state.set_selected_action(ActionType::LockStation);\n        });\n    };\n    let lock_station_selected = action_selected(ActionType::LockStation);\n\n    let unlock_station = move |_| {\n        map_state.update(|state| {\n            state.set_selected_action(ActionType::UnlockStation);\n        });\n    };\n    let unlock_station_selected = action_selected(ActionType::UnlockStation);\n\n    view! {\n        \u003cdiv id=\"sidebar\" class=\"h-full w-full flex flex-col gap-y-4 bg-zinc-100 py-2 shadow-right shadow-dark-mild dark:shadow-black dark:bg-neutral-750 text-black dark:text-white px-2\"\u003e\n            \u003cButton\n                on_click=Box::new(move |_| map_state.update(|state| state.set_map(state.get_last_loaded().cloned().unwrap_or_else(testmap))))\n                text=\"reset map\" /\u003e\n            \u003cButtonGroup\n                children={vec![\n                    ButtonProps::builder()\n                        .text(\"Add Station\")\n                        .on_click(Box::new(add_station))\n                        .build(),\n                    ButtonProps::builder()\n                        .text(\"Remove Station\")\n                        .on_click(Box::new(remove_station))\n                        .active(remove_station_selected)\n                        .danger(true)\n                        .build(),\n                ]}/\u003e\n            \u003cButtonGroup\n                children={vec![\n                    ButtonProps::builder()\n                        .text(\"Add Line\")\n                        .on_click(Box::new(add_line))\n                        .build(),\n                    ButtonProps::builder()\n                        .text(\"Remove Line\")\n                        .on_click(Box::new(remove_line))\n                        .active(remove_line_selected)\n                        .danger(true)\n                        .build(),\n                ]}/\u003e\n            \u003cButtonGroup\n                children={vec![\n                    ButtonProps::builder()\n                        .text(\"Lock Station\")\n                        .on_click(Box::new(lock_station))\n                        .active(lock_station_selected)\n                        .build(),\n                    ButtonProps::builder()\n                        .text(\"Unlock Station\")\n                        .on_click(Box::new(unlock_station))\n                        .active(unlock_station_selected)\n                        .danger(true)\n                        .build(),\n                ]}/\u003e\n        \u003c/div\u003e\n    }\n}\n\n/// Temporary function to load in a test metro map.\nfn testmap() -\u003e Map {\n    let mut map = Map::new();\n\n    let station1 = Station::new((10, 10).into(), None);\n    let station1_id = station1.get_id();\n    let station2 = Station::new((15, 15).into(), None);\n    let station2_id = station2.get_id();\n    let station3 = Station::new((20, 25).into(), None);\n    let station3_id = station3.get_id();\n    let station4 = Station::new((20, 12).into(), None);\n    let station4_id = station4.get_id();\n    let station5 = Station::new((25, 12).into(), None);\n    let station5_id = station5.get_id();\n    let station6 = Station::new((30, 20).into(), None);\n    let station6_id = station6.get_id();\n    let station7 = Station::new((7, 5).into(), None);\n    let station7_id = station7.get_id();\n\n    map.add_station(station1);\n    map.add_station(station2);\n    map.add_station(station3);\n    map.add_station(station4);\n    map.add_station(station5);\n    map.add_station(station6);\n    map.add_station(station7);\n\n    let mut line1 = Line::new(None);\n    let mut line2 = Line::new(None);\n    let mut line3 = Line::new(None);\n\n    line1.add_station(\n        \u0026mut map,\n        station1_id,\n        Some(station2_id),\n        None,\n    );\n    line1.add_station(\n        \u0026mut map,\n        station2_id,\n        Some(station3_id),\n        None,\n    );\n    line1.add_station(\u0026mut map, station3_id, None, None);\n    map.add_line(line1);\n\n    line2.add_station(\n        \u0026mut map,\n        station4_id,\n        Some(station5_id),\n        None,\n    );\n    line2.add_station(\n        \u0026mut map,\n        station5_id,\n        Some(station6_id),\n        None,\n    );\n    line2.add_station(\u0026mut map, station6_id, None, None);\n    map.add_line(line2);\n\n    line3.add_station(\u0026mut map, station7_id, None, None);\n    map.add_line(line3);\n\n    map\n}\n","traces":[{"line":27,"address":[8815197,8815183,8810160],"length":1,"stats":{"Line":0}},{"line":28,"address":[8966502],"length":1,"stats":{"Line":0}},{"line":31,"address":[8966571],"length":1,"stats":{"Line":0}},{"line":32,"address":[8897223,8897280,8897463],"length":1,"stats":{"Line":0}},{"line":33,"address":[8897410,8897303,8897396],"length":1,"stats":{"Line":0}},{"line":36,"address":[10081148],"length":1,"stats":{"Line":0}},{"line":40,"address":[8906655,8897488],"length":1,"stats":{"Line":0}},{"line":41,"address":[8906688],"length":1,"stats":{"Line":0}},{"line":42,"address":[8906708],"length":1,"stats":{"Line":0}},{"line":46,"address":[10099635,10090480],"length":1,"stats":{"Line":0}},{"line":47,"address":[8915952],"length":1,"stats":{"Line":0}},{"line":48,"address":[8915968],"length":1,"stats":{"Line":0}},{"line":49,"address":[8915988],"length":1,"stats":{"Line":0}},{"line":53,"address":[8966619],"length":1,"stats":{"Line":0}},{"line":54,"address":[8925232],"length":1,"stats":{"Line":0}},{"line":55,"address":[10108937],"length":1,"stats":{"Line":0}},{"line":58,"address":[8810355],"length":1,"stats":{"Line":0}},{"line":60,"address":[10108960,10118115],"length":1,"stats":{"Line":0}},{"line":61,"address":[8934464],"length":1,"stats":{"Line":0}},{"line":62,"address":[8934473],"length":1,"stats":{"Line":0}},{"line":65,"address":[8966704],"length":1,"stats":{"Line":0}},{"line":67,"address":[8943663,8934496],"length":1,"stats":{"Line":0}},{"line":68,"address":[8943696],"length":1,"stats":{"Line":0}},{"line":69,"address":[8943705],"length":1,"stats":{"Line":0}},{"line":72,"address":[8966757],"length":1,"stats":{"Line":0}},{"line":74,"address":[10136547,10127392],"length":1,"stats":{"Line":0}},{"line":75,"address":[8952928],"length":1,"stats":{"Line":0}},{"line":76,"address":[8952937],"length":1,"stats":{"Line":0}},{"line":79,"address":[8966810],"length":1,"stats":{"Line":0}},{"line":81,"address":[8968877,8971757,8969239,8968835,8969689],"length":1,"stats":{"Line":0}},{"line":131,"address":[8966074,8962256,8966281],"length":1,"stats":{"Line":0}},{"line":132,"address":[8962273],"length":1,"stats":{"Line":0}},{"line":134,"address":[8962370,8962467],"length":1,"stats":{"Line":0}},{"line":135,"address":[8806492,8806434],"length":1,"stats":{"Line":0}},{"line":136,"address":[8962596],"length":1,"stats":{"Line":0}},{"line":137,"address":[8806654,8806596],"length":1,"stats":{"Line":0}},{"line":138,"address":[8806662],"length":1,"stats":{"Line":0}},{"line":139,"address":[8806819,8806761],"length":1,"stats":{"Line":0}},{"line":140,"address":[8806827],"length":1,"stats":{"Line":0}},{"line":141,"address":[8963046,8963104],"length":1,"stats":{"Line":0}},{"line":142,"address":[8806992],"length":1,"stats":{"Line":0}},{"line":143,"address":[8963219,8963277],"length":1,"stats":{"Line":0}},{"line":144,"address":[8963285],"length":1,"stats":{"Line":0}},{"line":145,"address":[8963392,8963450],"length":1,"stats":{"Line":0}},{"line":146,"address":[8963458],"length":1,"stats":{"Line":0}},{"line":147,"address":[8807421,8807479],"length":1,"stats":{"Line":0}},{"line":149,"address":[8807487],"length":1,"stats":{"Line":0}},{"line":150,"address":[8807614],"length":1,"stats":{"Line":0}},{"line":151,"address":[8807741],"length":1,"stats":{"Line":0}},{"line":152,"address":[8964024],"length":1,"stats":{"Line":0}},{"line":153,"address":[8807995],"length":1,"stats":{"Line":0}},{"line":154,"address":[8964286],"length":1,"stats":{"Line":0}},{"line":155,"address":[8808249],"length":1,"stats":{"Line":0}},{"line":157,"address":[8964548],"length":1,"stats":{"Line":0}},{"line":158,"address":[8964603,8964691],"length":1,"stats":{"Line":0}},{"line":159,"address":[8964699,8964794],"length":1,"stats":{"Line":0}},{"line":161,"address":[8808650],"length":1,"stats":{"Line":0}},{"line":164,"address":[8964802],"length":1,"stats":{"Line":0}},{"line":165,"address":[8964822],"length":1,"stats":{"Line":0}},{"line":167,"address":[8964982],"length":1,"stats":{"Line":0}},{"line":170,"address":[8964950],"length":1,"stats":{"Line":0}},{"line":171,"address":[8964970],"length":1,"stats":{"Line":0}},{"line":173,"address":[8965052],"length":1,"stats":{"Line":0}},{"line":174,"address":[8965141],"length":1,"stats":{"Line":0}},{"line":176,"address":[8809114],"length":1,"stats":{"Line":0}},{"line":179,"address":[8965282],"length":1,"stats":{"Line":0}},{"line":180,"address":[8965302],"length":1,"stats":{"Line":0}},{"line":182,"address":[8965421],"length":1,"stats":{"Line":0}},{"line":185,"address":[8965389],"length":1,"stats":{"Line":0}},{"line":186,"address":[8965409],"length":1,"stats":{"Line":0}},{"line":188,"address":[8965491],"length":1,"stats":{"Line":0}},{"line":189,"address":[8965580],"length":1,"stats":{"Line":0}},{"line":191,"address":[8965716],"length":1,"stats":{"Line":0}},{"line":192,"address":[8965805],"length":1,"stats":{"Line":0}},{"line":194,"address":[8965941],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","pages","home.rs"],"content":"//! Contains the [`Home`] page component\n\nuse leptos::*;\n\nuse crate::components::organisms::{\n    CanvasControls,\n    Navbar,\n    Sidebar,\n};\n\n/// The main page component.\n#[component]\npub fn Home() -\u003e impl IntoView {\n    view! {\n            \u003cheader\u003e\n                \u003cNavbar/\u003e\n            \u003c/header\u003e\n            \u003cdiv class=\"grow flex flex-row justify-start\"\u003e\n                \u003cdiv class=\"flex-none self-start self-stretch w-1/5 md:w-52\"\u003e\n                    \u003cSidebar/\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"grow flex self-stretch\"\u003e\n                    \u003cCanvasControls/\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n    }\n}\n","traces":[{"line":13,"address":[9359200],"length":1,"stats":{"Line":0}},{"line":14,"address":[9012974,9012735,9013914,9013805,9013957,9012624,9014054,9012656],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","pages","mod.rs"],"content":"//! The pages of the site (currently just one (home) page)\n\nmod home;\n\npub use home::Home;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","state","canvas.rs"],"content":"//! Contains the [`CanvasState`] struct and its methods.\n\nuse crate::models::GridNode;\n\n/// Contains the current state of the canvas.\n#[derive(Clone, Copy, Debug)]\npub struct CanvasState {\n    /// The height and width of the current canvas.\n    size: (u32, u32),\n    /// The size of the map grid squares.\n    square_size: u32,\n    /// How much the canvas is zoomed in.\n    zoom_factor: f64,\n    /// The height and width offset from panning the canvas.\n    offset: (i32, i32),\n    /// The maximum and minimum values for the x-axis.\n    x_limit: (i32, i32),\n    /// The maximum and minimum values for the x-axis.\n    y_limit: (i32, i32),\n}\n\nimpl CanvasState {\n    /// Create a new canvas state with default values.\n    pub fn new() -\u003e Self {\n        let mut s = Self {\n            size: (300, 300),\n            square_size: 7,\n            zoom_factor: 1.0,\n            offset: (0, 0),\n            x_limit: (0, 0),\n            y_limit: (0, 0),\n        };\n        s.recalculate_limits();\n        s\n    }\n\n    /// A getter method for the canvas size.\n    pub fn get_size(\u0026self) -\u003e (u32, u32) {\n        self.size\n    }\n\n    /// A setter method for the canvas size.\n    pub fn set_size(\u0026mut self, size: (u32, u32)) {\n        self.size = size;\n        self.recalculate_limits();\n    }\n\n    /// A getter method for the grid square size.\n    pub fn get_square_size(\u0026self) -\u003e u32 {\n        self.square_size\n    }\n\n    /// A setter method for the grid square size.\n    pub fn set_square_size(\u0026mut self, size: u32) {\n        self.square_size = size;\n        self.recalculate_limits();\n    }\n\n    /// Zooms in on the canvas.\n    pub fn zoom_in(\u0026mut self) {\n        let old_x = self.x_limit;\n        let old_y = self.y_limit;\n\n        self.zoom_factor += 0.1;\n        self.recalculate_limits();\n\n        let x_change = (self\n            .x_limit\n            .1\n            - old_x.1)\n            / 2;\n        let y_change = (self\n            .y_limit\n            .1\n            - old_y.1)\n            / 2;\n\n        self.offset\n            .0 -= x_change;\n        self.offset\n            .1 -= y_change;\n\n        self.recalculate_limits();\n    }\n\n    /// Zooms out on the canvas.\n    pub fn zoom_out(\u0026mut self) {\n        let old_x = self.x_limit;\n        let old_y = self.y_limit;\n\n        self.zoom_factor -= 0.1;\n        if self.zoom_factor \u003c= 0.21 {\n            self.zoom_factor = 0.2;\n        }\n\n        self.recalculate_limits();\n\n        let x_change = (self\n            .x_limit\n            .1\n            - old_x.1)\n            / 2;\n        let y_change = (self\n            .y_limit\n            .1\n            - old_y.1)\n            / 2;\n\n        self.offset\n            .0 -= x_change;\n        self.offset\n            .1 -= y_change;\n\n        self.recalculate_limits();\n    }\n\n    /// Move upwards on the canvas.\n    pub fn move_up(\u0026mut self) {\n        let mut amount = (self\n            .y_limit\n            .1\n            - self\n                .y_limit\n                .0)\n            / 30;\n\n        if amount \u003c 1 {\n            amount = 1;\n        }\n\n        self.offset\n            .1 -= amount;\n        self.recalculate_limits();\n    }\n\n    /// Move downwards on the canvas.\n    pub fn move_down(\u0026mut self) {\n        let mut amount = (self\n            .y_limit\n            .1\n            - self\n                .y_limit\n                .0)\n            / 30;\n\n        if amount \u003c 1 {\n            amount = 1;\n        }\n\n        self.offset\n            .1 += amount;\n        self.recalculate_limits();\n    }\n\n    /// Move leftwards on the canvas.\n    pub fn move_left(\u0026mut self) {\n        let mut amount = (self\n            .x_limit\n            .1\n            - self\n                .x_limit\n                .0)\n            / 30;\n\n        if amount \u003c 1 {\n            amount = 1;\n        }\n\n        self.offset\n            .0 -= amount;\n        self.recalculate_limits();\n    }\n\n    /// Move rightwards on the canvas.\n    pub fn move_right(\u0026mut self) {\n        let mut amount = (self\n            .x_limit\n            .1\n            - self\n                .x_limit\n                .0)\n            / 30;\n\n        if amount \u003c 1 {\n            amount = 1;\n        }\n\n        self.offset\n            .0 += amount;\n        self.recalculate_limits();\n    }\n\n    /// A getter method for the zoom factor of the canvas.\n    pub fn get_zoom_factor(\u0026self) -\u003e f64 {\n        self.zoom_factor\n    }\n\n    /// A setter method for the zoom factor of the canvas.\n    pub fn set_zoom_factor(\u0026mut self, factor: f64) {\n        self.zoom_factor = factor;\n        self.recalculate_limits();\n    }\n\n    /// Get the square size with zoom factored in.\n    pub fn drawn_square_size(\u0026self) -\u003e f64 {\n        f64::from(self.get_square_size()) * self.get_zoom_factor()\n    }\n\n    /// A getter method for the offset\n    pub fn get_offset(\u0026self) -\u003e (i32, i32) {\n        self.offset\n    }\n\n    /// Recalculates the maximum and minimum values for the x and y coordinates\n    /// to fit on the canvas.\n    fn recalculate_limits(\u0026mut self) {\n        let width_node_count = (f64::from(\n            self.size\n                .1,\n        ) / self.drawn_square_size())\n        .ceil() as i32;\n        let height_node_count = (f64::from(\n            self.size\n                .0,\n        ) / self.drawn_square_size())\n        .ceil() as i32;\n\n        self.x_limit = (\n            self.offset\n                .0,\n            width_node_count\n                + self\n                    .offset\n                    .0,\n        );\n        self.y_limit = (\n            self.offset\n                .1,\n            height_node_count\n                + self\n                    .offset\n                    .1,\n        );\n    }\n\n    /// Returns true if the given grid node is on the canvas.\n    pub fn is_on_canvas(\u0026self, node: GridNode) -\u003e bool {\n        self.x_limit\n            .0\n            \u003c node.0\n            \u0026\u0026 node.0\n                \u003c self\n                    .x_limit\n                    .1\n            \u0026\u0026 self\n                .y_limit\n                .0\n                \u003c node.1\n            \u0026\u0026 node.1\n                \u003c self\n                    .y_limit\n                    .1\n    }\n}\n\nimpl Default for CanvasState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":24,"address":[9173104],"length":1,"stats":{"Line":3}},{"line":33,"address":[8834084],"length":1,"stats":{"Line":3}},{"line":34,"address":[9173219],"length":1,"stats":{"Line":10}},{"line":38,"address":[9173248],"length":1,"stats":{"Line":2}},{"line":39,"address":[9173253],"length":1,"stats":{"Line":2}},{"line":43,"address":[9173264],"length":1,"stats":{"Line":5}},{"line":44,"address":[9173281],"length":1,"stats":{"Line":5}},{"line":45,"address":[9173286],"length":1,"stats":{"Line":5}},{"line":49,"address":[9173296],"length":1,"stats":{"Line":8}},{"line":50,"address":[9173301],"length":1,"stats":{"Line":8}},{"line":54,"address":[9173312],"length":1,"stats":{"Line":10}},{"line":55,"address":[9173325],"length":1,"stats":{"Line":10}},{"line":56,"address":[9173328],"length":1,"stats":{"Line":10}},{"line":60,"address":[9173344],"length":1,"stats":{"Line":0}},{"line":61,"address":[9173358],"length":1,"stats":{"Line":0}},{"line":62,"address":[8834256],"length":1,"stats":{"Line":0}},{"line":64,"address":[9173394],"length":1,"stats":{"Line":0}},{"line":65,"address":[9173412],"length":1,"stats":{"Line":0}},{"line":67,"address":[9173523,9173426],"length":1,"stats":{"Line":0}},{"line":72,"address":[8834387,8834502,8834423],"length":1,"stats":{"Line":0}},{"line":78,"address":[9173651,9173606,9173669],"length":1,"stats":{"Line":0}},{"line":80,"address":[9173654,9173693,9173706],"length":1,"stats":{"Line":0}},{"line":83,"address":[9173696],"length":1,"stats":{"Line":0}},{"line":87,"address":[9173728],"length":1,"stats":{"Line":0}},{"line":88,"address":[9173742],"length":1,"stats":{"Line":0}},{"line":89,"address":[8834640],"length":1,"stats":{"Line":0}},{"line":91,"address":[8834658],"length":1,"stats":{"Line":0}},{"line":92,"address":[9173868,9173800],"length":1,"stats":{"Line":0}},{"line":93,"address":[8834735],"length":1,"stats":{"Line":0}},{"line":96,"address":[9173820],"length":1,"stats":{"Line":0}},{"line":98,"address":[9173834,9173874,9173953],"length":1,"stats":{"Line":0}},{"line":103,"address":[9174052,9173937,9173973],"length":1,"stats":{"Line":0}},{"line":109,"address":[9174036,9174081,9174099],"length":1,"stats":{"Line":0}},{"line":111,"address":[8835003,8835016,8834964],"length":1,"stats":{"Line":0}},{"line":114,"address":[9174126],"length":1,"stats":{"Line":0}},{"line":118,"address":[9174160],"length":1,"stats":{"Line":0}},{"line":119,"address":[9174174,9174250],"length":1,"stats":{"Line":0}},{"line":127,"address":[8835121,8835179],"length":1,"stats":{"Line":0}},{"line":128,"address":[9174291],"length":1,"stats":{"Line":0}},{"line":131,"address":[9174310,9174323,9174275],"length":1,"stats":{"Line":0}},{"line":132,"address":[9174271],"length":1,"stats":{"Line":0}},{"line":133,"address":[9174313],"length":1,"stats":{"Line":0}},{"line":137,"address":[9174352],"length":1,"stats":{"Line":0}},{"line":138,"address":[8835246,8835322],"length":1,"stats":{"Line":0}},{"line":146,"address":[8835313,8835369],"length":1,"stats":{"Line":0}},{"line":147,"address":[8835361],"length":1,"stats":{"Line":0}},{"line":150,"address":[8835393,8835380,8835347],"length":1,"stats":{"Line":0}},{"line":151,"address":[9174463],"length":1,"stats":{"Line":0}},{"line":152,"address":[9174503],"length":1,"stats":{"Line":0}},{"line":156,"address":[9174544],"length":1,"stats":{"Line":0}},{"line":157,"address":[8835438,8835514],"length":1,"stats":{"Line":0}},{"line":165,"address":[9174625,9174683],"length":1,"stats":{"Line":0}},{"line":166,"address":[9174675],"length":1,"stats":{"Line":0}},{"line":169,"address":[9174659,9174707,9174694],"length":1,"stats":{"Line":0}},{"line":170,"address":[9174655],"length":1,"stats":{"Line":0}},{"line":171,"address":[9174697],"length":1,"stats":{"Line":0}},{"line":175,"address":[8835616],"length":1,"stats":{"Line":0}},{"line":176,"address":[9174826,9174750],"length":1,"stats":{"Line":0}},{"line":184,"address":[9174817,9174873],"length":1,"stats":{"Line":0}},{"line":185,"address":[9174865],"length":1,"stats":{"Line":0}},{"line":188,"address":[9174897,9174851,9174884],"length":1,"stats":{"Line":0}},{"line":189,"address":[9174847],"length":1,"stats":{"Line":0}},{"line":190,"address":[9174887],"length":1,"stats":{"Line":0}},{"line":194,"address":[9174928],"length":1,"stats":{"Line":8}},{"line":195,"address":[8835813],"length":1,"stats":{"Line":2}},{"line":199,"address":[8835824],"length":1,"stats":{"Line":1}},{"line":200,"address":[8835839],"length":1,"stats":{"Line":1}},{"line":201,"address":[9174964],"length":1,"stats":{"Line":1}},{"line":205,"address":[9174976],"length":1,"stats":{"Line":7}},{"line":206,"address":[9174990,9175021],"length":1,"stats":{"Line":9}},{"line":210,"address":[8835920],"length":1,"stats":{"Line":1}},{"line":211,"address":[8835925],"length":1,"stats":{"Line":2}},{"line":216,"address":[9175072],"length":1,"stats":{"Line":7}},{"line":217,"address":[9175124],"length":1,"stats":{"Line":2}},{"line":218,"address":[8835950],"length":1,"stats":{"Line":7}},{"line":220,"address":[9175106],"length":1,"stats":{"Line":7}},{"line":222,"address":[9175220],"length":1,"stats":{"Line":10}},{"line":223,"address":[9175186],"length":1,"stats":{"Line":9}},{"line":225,"address":[8836065],"length":1,"stats":{"Line":2}},{"line":228,"address":[9175322],"length":1,"stats":{"Line":10}},{"line":229,"address":[9175286],"length":1,"stats":{"Line":10}},{"line":231,"address":[9175349,9175293],"length":1,"stats":{"Line":10}},{"line":236,"address":[9175378],"length":1,"stats":{"Line":10}},{"line":237,"address":[9175328],"length":1,"stats":{"Line":10}},{"line":239,"address":[8836248,8836194],"length":1,"stats":{"Line":10}},{"line":247,"address":[9175408],"length":1,"stats":{"Line":4}},{"line":248,"address":[9175434],"length":1,"stats":{"Line":4}},{"line":251,"address":[9175455],"length":1,"stats":{"Line":3}},{"line":255,"address":[9175469],"length":1,"stats":{"Line":3}},{"line":259,"address":[9175483],"length":1,"stats":{"Line":3}},{"line":267,"address":[9175504],"length":1,"stats":{"Line":0}},{"line":268,"address":[9175512],"length":1,"stats":{"Line":0}}],"covered":40,"coverable":92},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","state","map.rs"],"content":"//! Contains the [`MapState`] and all its methods.\n\nuse leptos::{\n    html::Canvas,\n    *,\n};\nuse web_sys::HtmlCanvasElement;\n\nuse super::CanvasState;\nuse crate::{\n    algorithm::{\n        drawing::redraw_canvas,\n        recalculate_map,\n        AlgorithmSettings,\n    },\n    models::{\n        Map,\n        SelectedLine,\n        SelectedStation,\n    },\n    unwrap_or_return,\n};\n\n/// The type of operation that is currently selected.\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum ActionType {\n    /// User wants to remove a [`Station`].\n    ///\n    /// [`Station`]: crate::models::Station\n    RemoveStation,\n    /// User wants to remove a [`Line`].\n    ///\n    /// [`Line`]: crate::models::Line\n    RemoveLine,\n    /// User wants to lock the location of a [`Station`].\n    ///\n    /// [`Station`]: crate::models::Station\n    LockStation,\n    /// User wants to unlock the location of a [`Station`].\n    ///\n    /// [`Station`]: crate::models::Station\n    UnlockStation,\n}\n\n/// Holds all the state of the current [`Map`], canvas and any potentially\n/// selected objects.\n#[derive(Clone, Debug)]\npub struct MapState {\n    /// The current state of the map.\n    map: Map,\n    /// The currently selected [`crate::models::Station`].\n    selected_station: Option\u003cSelectedStation\u003e,\n    /// The currently selected [`crate::models::Line`].\n    selected_line: Option\u003cSelectedLine\u003e,\n    /// The type of action that is currently selected.\n    selected_action: Option\u003cActionType\u003e,\n    /// The state of the canvas.\n    canvas: CanvasState,\n    /// The settings for the algorithm.\n    algorithm_settings: AlgorithmSettings,\n    /// The last loaded map.\n    last_loaded: Option\u003cMap\u003e,\n}\n\nimpl MapState {\n    /// Create a new [`MapState`] using the given [`Map`]. Sets all other state\n    /// properties to default values.\n    pub fn new(map: Map) -\u003e Self {\n        Self {\n            map,\n            selected_station: None,\n            selected_line: None,\n            selected_action: None,\n            canvas: CanvasState::default(),\n            algorithm_settings: AlgorithmSettings::default(),\n            last_loaded: None,\n        }\n    }\n\n    /// A getter method for the [`Map`].\n    pub fn get_map(\u0026self) -\u003e \u0026Map {\n        \u0026self.map\n    }\n\n    /// A mutable getter method for the [`Map`].\n    pub fn get_mut_map(\u0026mut self) -\u003e \u0026mut Map {\n        \u0026mut self.map\n    }\n\n    /// A setter method for the [`Map`].\n    pub fn set_map(\u0026mut self, map: Map) {\n        self.map = map;\n    }\n\n    /// A getter method for the selected station.\n    pub fn get_selected_station(\u0026self) -\u003e Option\u003c\u0026SelectedStation\u003e {\n        self.selected_station\n            .as_ref()\n    }\n\n    /// A setter method for the selected station.\n    pub fn set_selected_station(\u0026mut self, station: SelectedStation) {\n        self.selected_station = Some(station);\n    }\n\n    /// Set the selected station to None.\n    pub fn clear_selected_station(\u0026mut self) {\n        self.selected_station = None;\n    }\n\n    /// A getter method for the selected action.\n    pub fn get_selected_action(\u0026self) -\u003e Option\u003cActionType\u003e {\n        self.selected_action\n    }\n\n    /// A setter method for the selected action.\n    pub fn set_selected_action(\u0026mut self, operation: ActionType) {\n        self.selected_action = Some(operation);\n    }\n\n    /// Set the selected action to None.\n    pub fn clear_selected_action(\u0026mut self) {\n        self.selected_action = None;\n    }\n\n    /// A mutable getter method for the selected line.\n    pub fn get_mut_selected_line(\u0026mut self) -\u003e Option\u003c\u0026mut SelectedLine\u003e {\n        self.selected_line\n            .as_mut()\n    }\n\n    /// A getter method for the selected line.\n    pub fn get_selected_line(\u0026self) -\u003e Option\u003c\u0026SelectedLine\u003e {\n        self.selected_line\n            .as_ref()\n    }\n\n    /// A setter method for the selected line.\n    pub fn set_selected_line(\u0026mut self, line: SelectedLine) {\n        self.selected_line = Some(line);\n    }\n\n    /// Set the selected line to None.\n    pub fn clear_selected_line(\u0026mut self) {\n        self.selected_line = None;\n    }\n\n    /// A getter method for the last loaded map.\n    pub fn get_last_loaded(\u0026self) -\u003e Option\u003c\u0026Map\u003e {\n        self.last_loaded\n            .as_ref()\n    }\n\n    /// A setter method for the last loaded map.\n    pub fn set_last_loaded(\u0026mut self, map: Map) {\n        self.last_loaded = Some(map);\n    }\n\n    /// A getter method for the state of the canvas.\n    #[inline]\n    pub fn get_canvas_state(\u0026self) -\u003e CanvasState {\n        self.canvas\n    }\n\n    /// Update the state of the canvas.\n    pub fn update_canvas_state\u003cF\u003e(\u0026mut self, f: F)\n    where\n        F: FnOnce(\u0026mut CanvasState),\n    {\n        f(\u0026mut self.canvas);\n    }\n\n    /// Draw the current state to the provided canvas.\n    pub fn draw_to_canvas(\u0026self, canvas_ref: \u0026NodeRef\u003cCanvas\u003e) {\n        redraw_canvas(\n            \u0026canvas_ref\n                .get()\n                .expect(\"should be loaded now\") as \u0026HtmlCanvasElement,\n            self,\n        );\n    }\n\n    /// Run the local search algorithm on the map.\n    pub fn run_local_search(\u0026mut self) {\n        let map_clone = self\n            .map\n            .clone();\n\n        for edge in self\n            .map\n            .get_mut_edges()\n        {\n            edge.calculate_nodes(\u0026map_clone);\n        }\n    }\n\n    /// Getter for the algorithm settings.\n    #[inline]\n    pub fn get_algorithm_settings(\u0026self) -\u003e AlgorithmSettings {\n        self.algorithm_settings\n    }\n\n    /// Update the algorithm settings.\n    pub fn update_algorithm_settings\u003cF\u003e(\u0026mut self, f: F)\n    where\n        F: FnOnce(\u0026mut AlgorithmSettings),\n    {\n        f(\u0026mut self.algorithm_settings);\n    }\n\n    /// Setter for the algorithm settings.\n    pub fn set_algorithm_settings(\u0026mut self, settings: AlgorithmSettings) {\n        self.algorithm_settings = settings;\n    }\n\n    /// Recalculate the x and y limits for the algorithm settings based on the\n    /// current map.\n    pub fn calculate_algorithm_settings(\u0026mut self) {\n        let mut x_limits = (i32::MAX, i32::MIN);\n        let mut y_limits = (i32::MAX, i32::MIN);\n\n        for station in self\n            .map\n            .get_mut_stations()\n        {\n            let pos = station.get_pos();\n\n            x_limits.0 = x_limits\n                .0\n                .min(pos.0);\n            x_limits.1 = x_limits\n                .1\n                .max(pos.0);\n            y_limits.0 = y_limits\n                .0\n                .min(pos.1);\n            y_limits.1 = y_limits\n                .1\n                .max(pos.1);\n        }\n\n        self.algorithm_settings\n            .grid_x_limits = (x_limits.0 - 2, x_limits.1 + 2);\n        self.algorithm_settings\n            .grid_y_limits = (y_limits.0 - 2, y_limits.1 + 2);\n    }\n\n    /// Run the full algorithm on the map. Returns true if successful.\n    pub fn run_algorithm(\u0026mut self) -\u003e bool {\n        self.calculate_algorithm_settings();\n        let res = recalculate_map(self.algorithm_settings, \u0026mut self.map);\n        if let Err(e) = res {\n            e.print_error();\n            false\n        } else {\n            true\n        }\n    }\n}\n","traces":[{"line":68,"address":[9213206,9213227,9212864],"length":1,"stats":{"Line":0}},{"line":74,"address":[8178633],"length":1,"stats":{"Line":0}},{"line":75,"address":[8178696],"length":1,"stats":{"Line":0}},{"line":81,"address":[8178960],"length":1,"stats":{"Line":0}},{"line":82,"address":[8178968],"length":1,"stats":{"Line":0}},{"line":86,"address":[9213264],"length":1,"stats":{"Line":0}},{"line":87,"address":[8178984],"length":1,"stats":{"Line":0}},{"line":91,"address":[8178992,8179058],"length":1,"stats":{"Line":0}},{"line":92,"address":[8179093,8179010],"length":1,"stats":{"Line":0}},{"line":96,"address":[8179120],"length":1,"stats":{"Line":0}},{"line":97,"address":[8179125],"length":1,"stats":{"Line":0}},{"line":102,"address":[9213424,9213504],"length":1,"stats":{"Line":0}},{"line":103,"address":[9213543,9213460],"length":1,"stats":{"Line":0}},{"line":107,"address":[8179312,8179388],"length":1,"stats":{"Line":0}},{"line":108,"address":[8179427,8179341],"length":1,"stats":{"Line":0}},{"line":112,"address":[8179456],"length":1,"stats":{"Line":0}},{"line":113,"address":[9213733],"length":1,"stats":{"Line":0}},{"line":117,"address":[9213744],"length":1,"stats":{"Line":0}},{"line":118,"address":[8179484],"length":1,"stats":{"Line":0}},{"line":122,"address":[8179504],"length":1,"stats":{"Line":0}},{"line":123,"address":[9213781],"length":1,"stats":{"Line":0}},{"line":127,"address":[9213808],"length":1,"stats":{"Line":0}},{"line":128,"address":[8179541],"length":1,"stats":{"Line":0}},{"line":133,"address":[8179552],"length":1,"stats":{"Line":0}},{"line":134,"address":[8179557],"length":1,"stats":{"Line":0}},{"line":139,"address":[9213840],"length":1,"stats":{"Line":0}},{"line":140,"address":[8179582],"length":1,"stats":{"Line":0}},{"line":144,"address":[9213904],"length":1,"stats":{"Line":0}},{"line":145,"address":[9213913],"length":1,"stats":{"Line":0}},{"line":149,"address":[8179680],"length":1,"stats":{"Line":0}},{"line":150,"address":[8179685],"length":1,"stats":{"Line":0}},{"line":155,"address":[8179712,8179805],"length":1,"stats":{"Line":0}},{"line":156,"address":[8179845,8179749],"length":1,"stats":{"Line":0}},{"line":161,"address":[8179888],"length":1,"stats":{"Line":0}},{"line":162,"address":[8179905],"length":1,"stats":{"Line":0}},{"line":166,"address":[8843648,8843616,8843744,8843680],"length":1,"stats":{"Line":0}},{"line":170,"address":[8843723,8843769,8843625,8843657],"length":1,"stats":{"Line":0}},{"line":174,"address":[9214376,9214192],"length":1,"stats":{"Line":0}},{"line":176,"address":[8180005],"length":1,"stats":{"Line":0}},{"line":184,"address":[8180176,8180557],"length":1,"stats":{"Line":0}},{"line":185,"address":[8180194],"length":1,"stats":{"Line":0}},{"line":189,"address":[8180221,8180281,8180445,8180501],"length":1,"stats":{"Line":0}},{"line":193,"address":[9214747,9214722],"length":1,"stats":{"Line":0}},{"line":199,"address":[8180592],"length":1,"stats":{"Line":0}},{"line":200,"address":[8180609],"length":1,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[8180640],"length":1,"stats":{"Line":0}},{"line":213,"address":[8180645],"length":1,"stats":{"Line":0}},{"line":218,"address":[8180672,8181322],"length":1,"stats":{"Line":0}},{"line":219,"address":[8180695],"length":1,"stats":{"Line":0}},{"line":220,"address":[8180711],"length":1,"stats":{"Line":0}},{"line":222,"address":[8181317,8180727,8180886,8180955],"length":1,"stats":{"Line":0}},{"line":226,"address":[8180971,8181173],"length":1,"stats":{"Line":0}},{"line":228,"address":[8181199],"length":1,"stats":{"Line":0}},{"line":231,"address":[8181230],"length":1,"stats":{"Line":0}},{"line":234,"address":[9215434],"length":1,"stats":{"Line":0}},{"line":237,"address":[8181292],"length":1,"stats":{"Line":0}},{"line":242,"address":[9215217],"length":1,"stats":{"Line":0}},{"line":243,"address":[8181066,8180937,8180989],"length":1,"stats":{"Line":0}},{"line":244,"address":[8181129],"length":1,"stats":{"Line":0}},{"line":245,"address":[8181149,8181082,8181048],"length":1,"stats":{"Line":0}},{"line":249,"address":[9215520],"length":1,"stats":{"Line":0}},{"line":250,"address":[8181363],"length":1,"stats":{"Line":0}},{"line":251,"address":[8181381],"length":1,"stats":{"Line":0}},{"line":252,"address":[8181504,8181438],"length":1,"stats":{"Line":0}},{"line":253,"address":[8181488],"length":1,"stats":{"Line":0}},{"line":254,"address":[8181499],"length":1,"stats":{"Line":0}},{"line":256,"address":[8181506],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":68},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","components","state","mod.rs"],"content":"//! Contains everything for keeping track of the current state of the page.\n\nuse leptos::*;\n\nmod canvas;\nmod map;\n\npub use canvas::CanvasState;\npub use map::{\n    ActionType,\n    MapState,\n};\n\nuse crate::models::Map;\n\n/// Provides all global state contexts to the page.\n#[allow(unused_braces)]\n#[component]\npub fn StateProvider(\n    /// The contents of the page that will have access to the global state.\n    children: Children,\n) -\u003e impl IntoView {\n    let map_state = create_rw_signal(MapState::new(Map::new()));\n\n    provide_context(map_state);\n\n    view! {\n        {children()}\n    }\n}\n","traces":[{"line":19,"address":[7781696,7781935,7781964],"length":1,"stats":{"Line":0}},{"line":23,"address":[7781798,7781722],"length":1,"stats":{"Line":0}},{"line":25,"address":[7781850],"length":1,"stats":{"Line":0}},{"line":27,"address":[7781893],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","lib.rs"],"content":"//! This project provides an interactive editor for metro maps.\n//! This file defines the crate and provides access to the algorithms, models,\n//! and components.\n\n// Deny all default lints and warn on pedantic ones by default\n#![deny(clippy::all)]\n#![warn(clippy::pedantic)]\n// Additionally warn when we forget to add documentation on things.\n#![warn(clippy::missing_docs_in_private_items)]\n// Lots of casts have to be done back and forth between js and rust, even if f64 to i32 might in\n// theory truncate, same with usize to f64.\n#![allow(clippy::cast_possible_truncation)]\n#![allow(clippy::cast_possible_wrap)]\n#![allow(clippy::cast_sign_loss)]\n#![allow(clippy::cast_precision_loss)]\n// Wildcard imports are idiomatic with leptos.\n#![allow(clippy::wildcard_imports)]\n// Having file and component function names be the same is idiomatic for leptos component files.\n#![allow(clippy::module_name_repetitions)]\n// Having a lot of parameters in a function is idiomatic for leptos.\n#![allow(clippy::fn_params_excessive_bools)]\n// There is not need for must_use or panics docs on functions as this is lib is only for internal\n// use.\n#![allow(clippy::missing_panics_doc)]\n#![allow(clippy::missing_errors_doc)]\n#![allow(clippy::must_use_candidate)]\n#![allow(clippy::return_self_not_must_use)]\n// FIXME: Remove this once the issue with local search has been fixed and it's back in use\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(unused_variables)]\n#![allow(unused_assignments)]\n\n// Import the necessary modules, these are more public than would be expected,\n// but this is needed to access them for testing.\npub mod algorithm;\npub mod models;\npub mod utils;\n\nmod components;\npub use components::{\n    CanvasState,\n    Home,\n    MapState,\n    StateProvider,\n};\npub use utils::Error;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","main.rs"],"content":"//! This project provides an interactive editor for metro maps.\n//! This file contains the main entry point for the application and starts the\n//! editor on the web.\n\nuse leptos::*;\nuse metro_map_editor::*;\n\nfn main() {\n    if web_sys::window().is_some() {\n        // Initialize the panic hook, which will print any panic that occurs to the\n        // console\n        console_error_panic_hook::set_once();\n\n        // Start the application\n        mount_to_body(App);\n    } else {\n        // This is a worker; do nothing\n    }\n}\n\n/// The App component that is the root for the application as a whole\n#[component]\nfn App() -\u003e impl IntoView {\n    view! {\n        \u003cdiv class=\"flex flex-col h-screen max-w-screen\"\u003e\n            \u003cStateProvider\u003e\n                \u003cHome/\u003e\n            \u003c/StateProvider\u003e\n        \u003c/div\u003e\n    }\n}\n","traces":[{"line":8,"address":[7483520,7483408],"length":1,"stats":{"Line":0}},{"line":9,"address":[7483412],"length":1,"stats":{"Line":0}},{"line":12,"address":[7483505],"length":1,"stats":{"Line":0}},{"line":15,"address":[7483510],"length":1,"stats":{"Line":0}},{"line":23,"address":[7483680,7484374,7484340],"length":1,"stats":{"Line":0}},{"line":24,"address":[7483875,7483697,7484355],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","edge.rs"],"content":"//! Contains the [`Edge`] struct and all its methods.\nuse std::{\n    fmt::{\n        self,\n        Display,\n        Formatter,\n    },\n    sync::atomic::{\n        AtomicU64,\n        Ordering as AtomicOrdering,\n    },\n};\n\nuse leptos::logging;\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse super::{\n    GridNode,\n    Line,\n    LineID,\n    Map,\n    StationID,\n};\nuse crate::{\n    algorithm::{\n        drawing::{\n            draw_edge,\n            CanvasContext,\n        },\n        run_a_star,\n    },\n    components::CanvasState,\n    utils::IDManager,\n};\n\n/// An identifier for an edge.\n#[derive(Clone, Debug, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(transparent)]\npub struct EdgeID(u64);\n\nimpl From\u003cu64\u003e for EdgeID {\n    fn from(value: u64) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl From\u003cEdgeID\u003e for u64 {\n    fn from(value: EdgeID) -\u003e Self {\n        value.0\n    }\n}\n\nimpl Display for EdgeID {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Represents an edge, which is the connection between two stations.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct Edge {\n    /// ID of the edge\n    id: EdgeID,\n    /// Start of the edge\n    from: StationID,\n    /// End of the edge\n    to: StationID,\n    /// Nodes visited between the stations\n    nodes: Vec\u003cGridNode\u003e,\n    /// Lines that use this edge\n    lines: Vec\u003cLineID\u003e,\n    /// If the edge is settled in the Dijkstra algorithm\n    is_settled: bool,\n    /// The stations contracted into this line in the algorithm\n    contracted_stations: Vec\u003cStationID\u003e,\n}\n\nimpl Edge {\n    /// Creates a new edge with start and goal.\n    pub fn new(from: StationID, to: StationID, id: Option\u003cEdgeID\u003e) -\u003e Self {\n        Self {\n            from,\n            to,\n            id: id.unwrap_or_else(IDManager::next_edge_id),\n            nodes: Vec::new(),\n            lines: Vec::new(),\n            is_settled: false,\n            contracted_stations: Vec::new(),\n        }\n    }\n\n    /// Returns the id of the edge.\n    #[inline]\n    pub fn get_id(\u0026self) -\u003e EdgeID {\n        self.id\n    }\n\n    /// Returns true if the given station id is the edge start.\n    pub fn is_from(\u0026self, id: StationID) -\u003e bool {\n        self.from == id\n    }\n\n    /// Returns true if the given station id is the edge goal.\n    pub fn is_to(\u0026self, id: StationID) -\u003e bool {\n        self.to == id\n    }\n\n    /// Get the id of the edge start.\n    #[inline]\n    pub fn get_from(\u0026self) -\u003e StationID {\n        self.from\n    }\n\n    /// Get the id of the edge goal.\n    #[inline]\n    pub fn get_to(\u0026self) -\u003e StationID {\n        self.to\n    }\n\n    /// Get the other end of the edge from the station given, returns None if\n    /// the station is not an end of the edge.\n    pub fn opposite(\u0026self, station: StationID) -\u003e Option\u003cStationID\u003e {\n        if self.from == station {\n            Some(self.to)\n        } else if self.to == station {\n            Some(self.from)\n        } else {\n            None\n        }\n    }\n\n    /// A setter for the lines that use this edge.\n    pub fn set_lines(\u0026mut self, mut lines: Vec\u003cLineID\u003e) {\n        lines.sort_unstable();\n        self.lines = lines;\n    }\n\n    /// A getter for the lines that use this edge.\n    pub fn get_lines(\u0026self) -\u003e \u0026[LineID] {\n        \u0026self.lines\n    }\n\n    /// Add a line to the lines using the edge if it didn't already exist\n    pub fn add_line(\u0026mut self, line: LineID) {\n        match self\n            .lines\n            .binary_search(\u0026line)\n        {\n            Ok(_) =\u003e {},\n            Err(pos) =\u003e {\n                self.lines\n                    .insert(pos, line);\n            },\n        }\n    }\n\n    /// Remove a line from the lines using the edge if it exists\n    pub fn remove_line(\u0026mut self, line: LineID) {\n        if let Ok(pos) = self\n            .lines\n            .binary_search(\u0026line)\n        {\n            self.lines\n                .remove(pos);\n        }\n    }\n\n    /// A getter for the nodes visited between the stations.\n    pub fn get_nodes(\u0026self) -\u003e \u0026[GridNode] {\n        \u0026self.nodes\n    }\n\n    /// A setter for the nodes visited between the stations.\n    pub fn set_nodes(\u0026mut self, nodes: Vec\u003cGridNode\u003e) {\n        self.nodes = nodes;\n    }\n\n    /// Get the start and end nodes of the edge.\n    pub fn get_edge_ends(\u0026self) -\u003e Vec\u003cGridNode\u003e {\n        if self\n            .get_nodes()\n            .len()\n            \u003c 3\n        {\n            self.get_nodes()\n                .to_vec()\n        } else {\n            vec![\n                self.get_nodes()[0],\n                self.get_nodes()[self\n                    .get_nodes()\n                    .len()\n                    - 1],\n            ]\n        }\n    }\n\n    /// A getter for if the edge is settled.\n    #[inline]\n    pub fn is_settled(\u0026self) -\u003e bool {\n        self.is_settled\n    }\n\n    /// Settle the edge.\n    pub fn settle(\u0026mut self) {\n        self.is_settled = true;\n    }\n\n    /// Unsettle the edge.\n    pub fn unsettle(\u0026mut self) {\n        self.is_settled = false;\n    }\n\n    /// Add a station to the contracted stations.\n    pub fn add_contracted_station(\u0026mut self, station: StationID) {\n        self.contracted_stations\n            .push(station);\n    }\n\n    /// Extend the contracted stations with the given stations.\n    pub fn extend_contracted_stations(\u0026mut self, stations: \u0026[StationID]) {\n        self.contracted_stations\n            .extend(stations);\n    }\n\n    /// Get the contracted stations.\n    pub fn get_contracted_stations(\u0026self) -\u003e \u0026[StationID] {\n        \u0026self.contracted_stations\n    }\n\n    /// Clear the contracted stations.\n    pub fn clear_contracted_stations(\u0026mut self) {\n        self.contracted_stations\n            .clear();\n    }\n\n    /// Returns if the edge visits the node.\n    pub fn visits_node(\u0026self, map: \u0026Map, node: GridNode) -\u003e bool {\n        if self\n            .nodes\n            .contains(\u0026node)\n        {\n            return true;\n        }\n\n        if let Some(from) = map.get_station(self.get_from()) {\n            if from.get_pos() == node {\n                return true;\n            }\n        }\n\n        if let Some(to) = map.get_station(self.get_to()) {\n            if to.get_pos() == node {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    #[allow(dead_code)]\n    pub fn print_info(\u0026self) {\n        logging::log!(\n            \"Edge: {} from {} to {} with lines [{:?}]\",\n            self.id,\n            self.get_from(),\n            self.get_to(),\n            self.get_lines()\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003cString\u003e\u003e()\n                .join(\", \")\n        );\n    }\n\n    /// Get the stations bordering the node on this edge if exists\n    #[allow(clippy::unnecessary_wraps)]\n    pub fn get_neigboring_stations(\n        \u0026self,\n        map: \u0026Map,\n        node: GridNode,\n    ) -\u003e Option\u003c(Option\u003cStationID\u003e, Option\u003cStationID\u003e)\u003e {\n        if self\n            .nodes\n            .contains(\u0026node)\n        {\n            return Some((\n                Some(self.get_from()),\n                Some(self.get_to()),\n            ));\n        }\n\n        if let Some(from) = map.get_station(self.get_from()) {\n            if from\n                .get_pos()\n                .get_neighbors()\n                .contains(\u0026node)\n            {\n                return Some((None, Some(self.get_from())));\n            }\n        }\n\n        if let Some(to) = map.get_station(self.get_to()) {\n            if to\n                .get_pos()\n                .get_neighbors()\n                .contains(\u0026node)\n            {\n                return Some((Some(self.get_to()), None));\n            }\n        }\n\n        Some((None, None))\n    }\n\n    /// Recalculates the nodes between the stations using the A* algorithm.\n    pub fn calculate_nodes(\u0026mut self, map: \u0026Map) {\n        let from = map\n            .get_station(self.get_from())\n            .expect(\"invalid station id\");\n        let to = map\n            .get_station(self.get_to())\n            .expect(\"invalid station id\");\n\n        self.set_nodes(run_a_star(from.get_pos(), to.get_pos()));\n    }\n\n    /// Draw the edge to the given canvas.\n    pub fn draw(\u0026self, map: \u0026Map, canvas: \u0026CanvasContext\u003c'_\u003e, state: CanvasState) {\n        let from = map\n            .get_station(self.get_from())\n            .expect(\"invalid from station id when drawing\");\n        let to = map\n            .get_station(self.get_to())\n            .expect(\"invalid to station id when drawing\");\n\n        let colors = self\n            .lines\n            .iter()\n            .filter_map(|l| map.get_line(*l))\n            .map(Line::get_color)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let color_count = colors.len();\n        for (i, color) in colors\n            .into_iter()\n            .enumerate()\n        {\n            let mut width = state.drawn_square_size() / 10.0 + 0.5;\n            if width \u003c 1.0 {\n                width = 1.0;\n            }\n\n            canvas.set_line_width(width);\n            canvas.set_global_alpha(1.0);\n\n            canvas.set_stroke_style_str(\u0026format!(\n                \"rgb({} {} {})\",\n                color.0, color.1, color.2,\n            ));\n            canvas.begin_path();\n\n            let color_offset = if color_count == 1 {\n                0.0\n            } else {\n                ((i as f64) * width) - ((color_count as f64 * width) / 2.0) + (width / 2.0)\n            };\n\n            draw_edge(\n                from.get_pos(),\n                to.get_pos(),\n                \u0026self.nodes,\n                canvas,\n                state,\n                color_offset,\n            );\n\n            canvas.stroke();\n        }\n    }\n}\n\nimpl PartialEq for Edge {\n    fn eq(\u0026self, other: \u0026Edge) -\u003e bool {\n        self.id == other.id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::models::Station;\n\n    #[test]\n    fn test_draw() {\n        let mut map = Map::new();\n        let canvas = CanvasContext::new();\n        let mut state = CanvasState::new();\n        state.set_square_size(5);\n        state.set_size((100, 100));\n        assert_eq!(state.drawn_square_size(), 5.0);\n\n        let mut line1 = Line::new(None);\n        line1.set_color((255, 1, 1));\n        let mut line2 = Line::new(None);\n        line2.set_color((1, 255, 1));\n\n        let from = Station::new((0, 0).into(), None);\n        let to = Station::new((3, 3).into(), None);\n        let mut edge = Edge::new(from.get_id(), to.get_id(), None);\n\n        map.add_station(from);\n        map.add_station(to);\n\n        edge.set_lines(vec![line1.get_id(), line2.get_id()]);\n        map.add_line(line1);\n        map.add_line(line2);\n\n        edge.calculate_nodes(\u0026map);\n        edge.draw(\u0026map, \u0026canvas, state);\n\n        assert_eq!(\n            canvas.get_record(\"move_to\"),\n            Some(vec![\n                \"1.8,0.8\".to_owned(),\n                \"0.8,1.8\".to_owned(),\n            ])\n        );\n\n        assert_eq!(\n            canvas.get_record(\"line_to\"),\n            Some(vec![\n                \"5.5,4.5\".to_owned(),\n                \"10.5,9.5\".to_owned(),\n                \"14.2,13.2\".to_owned(),\n                \"4.5,5.5\".to_owned(),\n                \"9.5,10.5\".to_owned(),\n                \"13.2,14.2\".to_owned()\n            ])\n        );\n    }\n}\n","traces":[{"line":45,"address":[9944512],"length":1,"stats":{"Line":1}},{"line":51,"address":[9576496],"length":1,"stats":{"Line":0}},{"line":57,"address":[9944544],"length":1,"stats":{"Line":1}},{"line":58,"address":[9944634],"length":1,"stats":{"Line":1}},{"line":83,"address":[9944704,9945067],"length":1,"stats":{"Line":1}},{"line":87,"address":[9576757],"length":1,"stats":{"Line":1}},{"line":88,"address":[9944810],"length":1,"stats":{"Line":1}},{"line":89,"address":[9944824],"length":1,"stats":{"Line":2}},{"line":91,"address":[9944881],"length":1,"stats":{"Line":2}},{"line":97,"address":[9945104],"length":1,"stats":{"Line":1}},{"line":98,"address":[9945109],"length":1,"stats":{"Line":1}},{"line":102,"address":[9945120],"length":1,"stats":{"Line":3}},{"line":103,"address":[9945134],"length":1,"stats":{"Line":3}},{"line":107,"address":[9945168],"length":1,"stats":{"Line":2}},{"line":108,"address":[9945182],"length":1,"stats":{"Line":1}},{"line":113,"address":[9945216],"length":1,"stats":{"Line":2}},{"line":114,"address":[9945221],"length":1,"stats":{"Line":2}},{"line":119,"address":[9577168],"length":1,"stats":{"Line":2}},{"line":120,"address":[9945237],"length":1,"stats":{"Line":2}},{"line":125,"address":[9945248],"length":1,"stats":{"Line":1}},{"line":126,"address":[9945266,9945330],"length":1,"stats":{"Line":2}},{"line":127,"address":[9577248],"length":1,"stats":{"Line":1}},{"line":128,"address":[9945341,9945288],"length":1,"stats":{"Line":1}},{"line":129,"address":[9945347],"length":1,"stats":{"Line":1}},{"line":131,"address":[9945332],"length":1,"stats":{"Line":0}},{"line":136,"address":[9945645,9945392,9945671],"length":1,"stats":{"Line":1}},{"line":137,"address":[9945497,9945424],"length":1,"stats":{"Line":2}},{"line":138,"address":[9577446],"length":1,"stats":{"Line":1}},{"line":142,"address":[9945680],"length":1,"stats":{"Line":2}},{"line":143,"address":[9945685],"length":1,"stats":{"Line":2}},{"line":147,"address":[9945712],"length":1,"stats":{"Line":1}},{"line":148,"address":[9945731],"length":1,"stats":{"Line":5}},{"line":153,"address":[9945786],"length":1,"stats":{"Line":1}},{"line":154,"address":[9945796],"length":1,"stats":{"Line":5}},{"line":161,"address":[9577728],"length":1,"stats":{"Line":0}},{"line":162,"address":[9945843],"length":1,"stats":{"Line":0}},{"line":166,"address":[9577805],"length":1,"stats":{"Line":0}},{"line":172,"address":[9945936],"length":1,"stats":{"Line":1}},{"line":173,"address":[9945941],"length":1,"stats":{"Line":1}},{"line":177,"address":[9945952,9946004],"length":1,"stats":{"Line":3}},{"line":178,"address":[9946039,9945970],"length":1,"stats":{"Line":6}},{"line":182,"address":[9946605,9946080],"length":1,"stats":{"Line":0}},{"line":183,"address":[9946118],"length":1,"stats":{"Line":0}},{"line":188,"address":[9946181],"length":1,"stats":{"Line":0}},{"line":191,"address":[9946536,9946456,9946140,9946206],"length":1,"stats":{"Line":0}},{"line":192,"address":[9578181,9578042,9578129],"length":1,"stats":{"Line":0}},{"line":193,"address":[9946488,9946357,9946282],"length":1,"stats":{"Line":0}},{"line":203,"address":[9946640],"length":1,"stats":{"Line":1}},{"line":204,"address":[9946645],"length":1,"stats":{"Line":1}},{"line":208,"address":[9946656],"length":1,"stats":{"Line":1}},{"line":209,"address":[9946661],"length":1,"stats":{"Line":1}},{"line":213,"address":[9578528],"length":1,"stats":{"Line":0}},{"line":214,"address":[9946677],"length":1,"stats":{"Line":0}},{"line":218,"address":[9946688],"length":1,"stats":{"Line":0}},{"line":219,"address":[9946702],"length":1,"stats":{"Line":0}},{"line":224,"address":[9578576],"length":1,"stats":{"Line":0}},{"line":225,"address":[9578594],"length":1,"stats":{"Line":0}},{"line":230,"address":[9578608],"length":1,"stats":{"Line":0}},{"line":231,"address":[9578613],"length":1,"stats":{"Line":0}},{"line":235,"address":[9578624],"length":1,"stats":{"Line":0}},{"line":236,"address":[9578629],"length":1,"stats":{"Line":0}},{"line":241,"address":[9578640],"length":1,"stats":{"Line":1}},{"line":242,"address":[9946864],"length":1,"stats":{"Line":1}},{"line":246,"address":[9578753],"length":1,"stats":{"Line":1}},{"line":249,"address":[9946896,9946955],"length":1,"stats":{"Line":2}},{"line":250,"address":[9946965],"length":1,"stats":{"Line":1}},{"line":251,"address":[9578858],"length":1,"stats":{"Line":1}},{"line":255,"address":[9578874,9578807],"length":1,"stats":{"Line":2}},{"line":256,"address":[9947080],"length":1,"stats":{"Line":1}},{"line":261,"address":[9947116],"length":1,"stats":{"Line":0}},{"line":265,"address":[9579769,9578928],"length":1,"stats":{"Line":0}},{"line":266,"address":[9947698,9947156,9947500],"length":1,"stats":{"Line":0}},{"line":281,"address":[9948016,9948771],"length":1,"stats":{"Line":1}},{"line":286,"address":[9948076],"length":1,"stats":{"Line":1}},{"line":290,"address":[9580014],"length":1,"stats":{"Line":1}},{"line":291,"address":[9948178],"length":1,"stats":{"Line":1}},{"line":292,"address":[9579981],"length":1,"stats":{"Line":1}},{"line":296,"address":[9948339,9948108],"length":1,"stats":{"Line":2}},{"line":297,"address":[9580128,9580299],"length":1,"stats":{"Line":2}},{"line":300,"address":[9948564,9948480],"length":1,"stats":{"Line":1}},{"line":302,"address":[9580356],"length":1,"stats":{"Line":0}},{"line":306,"address":[9580547,9580180],"length":1,"stats":{"Line":2}},{"line":307,"address":[9580813,9580563],"length":1,"stats":{"Line":2}},{"line":310,"address":[9580834,9580766],"length":1,"stats":{"Line":1}},{"line":312,"address":[9949134],"length":1,"stats":{"Line":1}},{"line":316,"address":[9948872],"length":1,"stats":{"Line":1}},{"line":320,"address":[9581040],"length":1,"stats":{"Line":2}},{"line":321,"address":[9581077],"length":1,"stats":{"Line":2}},{"line":322,"address":[9581064],"length":1,"stats":{"Line":2}},{"line":324,"address":[9581137],"length":1,"stats":{"Line":3}},{"line":325,"address":[9949382],"length":1,"stats":{"Line":2}},{"line":328,"address":[9949444],"length":1,"stats":{"Line":3}},{"line":332,"address":[9949520,9951600],"length":1,"stats":{"Line":1}},{"line":333,"address":[9581321,9581345],"length":1,"stats":{"Line":2}},{"line":334,"address":[9581329],"length":1,"stats":{"Line":1}},{"line":336,"address":[9949714],"length":1,"stats":{"Line":1}},{"line":337,"address":[9949690],"length":1,"stats":{"Line":1}},{"line":340,"address":[9949775],"length":1,"stats":{"Line":1}},{"line":343,"address":[9492416,9492430],"length":1,"stats":{"Line":2}},{"line":347,"address":[9949989,9949921],"length":1,"stats":{"Line":2}},{"line":348,"address":[9950253,9949997,9950215],"length":1,"stats":{"Line":3}},{"line":352,"address":[9950304,9950349],"length":1,"stats":{"Line":2}},{"line":353,"address":[9950382,9950442],"length":1,"stats":{"Line":1}},{"line":354,"address":[9950425],"length":1,"stats":{"Line":0}},{"line":357,"address":[9950409,9950449],"length":1,"stats":{"Line":1}},{"line":358,"address":[9950477],"length":1,"stats":{"Line":1}},{"line":360,"address":[9582568,9582309,9582407,9582211,9582644],"length":1,"stats":{"Line":5}},{"line":364,"address":[9951122],"length":1,"stats":{"Line":1}},{"line":366,"address":[9951162,9951180],"length":1,"stats":{"Line":1}},{"line":367,"address":[9951168],"length":1,"stats":{"Line":0}},{"line":369,"address":[9582726],"length":1,"stats":{"Line":1}},{"line":373,"address":[9951341],"length":1,"stats":{"Line":1}},{"line":374,"address":[9951380],"length":1,"stats":{"Line":1}},{"line":375,"address":[9951419],"length":1,"stats":{"Line":1}},{"line":378,"address":[9951482],"length":1,"stats":{"Line":1}},{"line":381,"address":[9951563],"length":1,"stats":{"Line":1}},{"line":387,"address":[9951648],"length":1,"stats":{"Line":1}},{"line":388,"address":[9951662],"length":1,"stats":{"Line":1}}],"covered":91,"coverable":118},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","grid_node.rs"],"content":"//! Contains the [`GridNode`] struct and its methods.\n\nuse std::{\n    fmt::Display,\n    ops::{\n        Add,\n        Mul,\n    },\n};\n\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse crate::components::CanvasState;\n\n/// Represents a node on the grid.\n#[derive(Clone, Debug, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct GridNode(\n    /// The x coordinate.\n    pub i32,\n    /// The y coordinate.\n    pub i32,\n);\n\nimpl GridNode {\n    /// Create the [`GridNode`] from the given canvas coordinate and the state\n    /// of the canvas.\n    pub fn from_canvas_pos(canvas_pos: (f64, f64), state: CanvasState) -\u003e Self {\n        Self(\n            (canvas_pos.0 / state.drawn_square_size()).round() as i32\n                + state\n                    .get_offset()\n                    .0,\n            (canvas_pos.1 / state.drawn_square_size()).round() as i32\n                + state\n                    .get_offset()\n                    .1,\n        )\n    }\n\n    /// Translate the [`GridNode`] to a canvas coordinate, given the state of\n    /// the canvas.\n    pub fn to_canvas_pos(self, state: CanvasState) -\u003e (f64, f64) {\n        let square_size = state.drawn_square_size();\n        (\n            f64::from(\n                self.0\n                    - state\n                        .get_offset()\n                        .0,\n            ) * square_size,\n            f64::from(\n                self.1\n                    - state\n                        .get_offset()\n                        .1,\n            ) * square_size,\n        )\n    }\n\n    /// Get the diagonal distance to a target node.\n    pub fn diagonal_distance_to(self, target: GridNode) -\u003e f64 {\n        let dx = (self.0 - target.0).abs();\n        let dy = (self.1 - target.1).abs();\n\n        f64::from(dx + dy) - (2f64.sqrt() - 2.0) * f64::from(dx.min(dy))\n    }\n\n    /// Get the Manhattan distance to a target node.\n    pub fn manhattan_distance_to(self, target: GridNode) -\u003e i32 {\n        let dx = (self.0 - target.0).abs();\n        let dy = (self.1 - target.1).abs();\n\n        dx + dy\n    }\n\n    /// Get a list of all the neighbors of this grid node.\n    pub fn get_neighbors(self) -\u003e Vec\u003cGridNode\u003e {\n        vec![\n            Self(self.0 - 1, self.1 - 1),\n            Self(self.0, self.1 - 1),\n            Self(self.0 + 1, self.1 - 1),\n            Self(self.0 + 1, self.1),\n            Self(self.0 + 1, self.1 + 1),\n            Self(self.0, self.1 + 1),\n            Self(self.0 - 1, self.1 + 1),\n            Self(self.0 - 1, self.1),\n        ]\n    }\n}\n\nimpl From\u003c(i32, i32)\u003e for GridNode {\n    fn from(value: (i32, i32)) -\u003e Self {\n        Self(value.0, value.1)\n    }\n}\n\nimpl Add for GridNode {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        Self(self.0 + rhs.0, self.1 + rhs.1)\n    }\n}\n\nimpl Mul\u003ci32\u003e for GridNode {\n    type Output = Self;\n\n    fn mul(self, rhs: i32) -\u003e Self::Output {\n        Self(self.0 * rhs, self.1 * rhs)\n    }\n}\n\nimpl Mul\u003cGridNode\u003e for GridNode {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        Self(self.0 * rhs.0, self.1 * rhs.1)\n    }\n}\n\nimpl PartialEq\u003c(i32, i32)\u003e for GridNode {\n    fn eq(\u0026self, other: \u0026(i32, i32)) -\u003e bool {\n        self.0 == other.0 \u0026\u0026 self.1 == other.1\n    }\n}\n\nimpl Display for GridNode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"({}, {})\", self.0, self.1)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_to_canvas_pos() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n        let result = GridNode::from((4, 5)).to_canvas_pos(canvas);\n\n        assert_eq!(result, (20.0, 25.0));\n    }\n\n    #[test]\n    fn test_from_canvas_pos() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n        let result = GridNode::from_canvas_pos((20.0, 24.6), canvas);\n\n        assert_eq!(result, (4, 5));\n    }\n\n    #[test]\n    fn test_diagonal_distance() {\n        let dist = GridNode::from((4, 5)).diagonal_distance_to(GridNode::from((10, 7)));\n\n        assert_eq!(dist.round(), 9.0);\n    }\n\n    #[test]\n    fn test_get_neighbors() {\n        let neighbors = GridNode::from((4, 5)).get_neighbors();\n\n        assert_eq!(\n            neighbors,\n            vec![\n                (3, 4),\n                (4, 4),\n                (5, 4),\n                (5, 5),\n                (5, 6),\n                (4, 6),\n                (3, 6),\n                (3, 5)\n            ]\n        );\n    }\n}\n","traces":[{"line":30,"address":[9599136],"length":1,"stats":{"Line":1}},{"line":32,"address":[9599169,9599364,9599254],"length":1,"stats":{"Line":2}},{"line":33,"address":[9599242],"length":1,"stats":{"Line":1}},{"line":36,"address":[9599351,9599393,9599270],"length":1,"stats":{"Line":2}},{"line":37,"address":[9599342],"length":1,"stats":{"Line":1}},{"line":45,"address":[9599424],"length":1,"stats":{"Line":1}},{"line":46,"address":[9599461],"length":1,"stats":{"Line":1}},{"line":48,"address":[9599528],"length":1,"stats":{"Line":5}},{"line":49,"address":[9599494,9599561],"length":1,"stats":{"Line":1}},{"line":50,"address":[9599484],"length":1,"stats":{"Line":1}},{"line":54,"address":[9599601],"length":1,"stats":{"Line":5}},{"line":55,"address":[9599610,9599548],"length":1,"stats":{"Line":5}},{"line":56,"address":[9599538],"length":1,"stats":{"Line":5}},{"line":64,"address":[9599632],"length":1,"stats":{"Line":1}},{"line":65,"address":[9599711,9599660],"length":1,"stats":{"Line":1}},{"line":66,"address":[9158435,9158467,9158402],"length":1,"stats":{"Line":3}},{"line":68,"address":[9599750,9599797,9599862,9599875],"length":1,"stats":{"Line":4}},{"line":72,"address":[9599904],"length":1,"stats":{"Line":1}},{"line":73,"address":[9599983,9599932],"length":1,"stats":{"Line":1}},{"line":74,"address":[9158674,9158735,9158707],"length":1,"stats":{"Line":2}},{"line":76,"address":[9600056,9600018],"length":1,"stats":{"Line":1}},{"line":80,"address":[9600080,9600836],"length":1,"stats":{"Line":1}},{"line":81,"address":[9600714,9600815,9600598,9600190,9600120],"length":1,"stats":{"Line":3}},{"line":82,"address":[9600244,9600144],"length":1,"stats":{"Line":1}},{"line":83,"address":[9158979,9158931],"length":1,"stats":{"Line":1}},{"line":84,"address":[9600266,9600301,9600349],"length":1,"stats":{"Line":2}},{"line":85,"address":[9159036,9159087],"length":1,"stats":{"Line":1}},{"line":86,"address":[9600412,9600374,9600463],"length":1,"stats":{"Line":2}},{"line":87,"address":[9159150,9159201],"length":1,"stats":{"Line":1}},{"line":88,"address":[9600488,9600526,9600577],"length":1,"stats":{"Line":2}},{"line":89,"address":[9600623,9600564],"length":1,"stats":{"Line":1}},{"line":95,"address":[9600864],"length":1,"stats":{"Line":5}},{"line":103,"address":[9600880],"length":1,"stats":{"Line":0}},{"line":104,"address":[9600908,9600969],"length":1,"stats":{"Line":0}},{"line":111,"address":[9600992],"length":1,"stats":{"Line":0}},{"line":112,"address":[9601079,9601016],"length":1,"stats":{"Line":0}},{"line":119,"address":[9601104],"length":1,"stats":{"Line":0}},{"line":120,"address":[9601132,9601195],"length":1,"stats":{"Line":0}},{"line":125,"address":[9601216],"length":1,"stats":{"Line":1}},{"line":126,"address":[9601236],"length":1,"stats":{"Line":1}},{"line":131,"address":[9601296],"length":1,"stats":{"Line":1}},{"line":132,"address":[9601484,9601400],"length":1,"stats":{"Line":2}}],"covered":36,"coverable":42},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","line.rs"],"content":"//! Contains the [`Line`] struct and all its methods.\nuse std::{\n    f64::consts::PI,\n    fmt::Display,\n    sync::atomic::{\n        AtomicU64,\n        Ordering as AtomicOrdering,\n    },\n};\n\nuse itertools::Itertools;\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse super::{\n    station::StationID,\n    EdgeID,\n    GridNode,\n    Map,\n};\nuse crate::{\n    algorithm::drawing::CanvasContext,\n    components::CanvasState,\n    utils::IDManager,\n};\n\n/// An identifier for a line.\n#[derive(Clone, Debug, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(transparent)]\npub struct LineID(u64);\n\nimpl From\u003cu64\u003e for LineID {\n    fn from(value: u64) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl From\u003cLineID\u003e for u64 {\n    fn from(value: LineID) -\u003e Self {\n        value.0\n    }\n}\n\nimpl Display for LineID {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Represents a metro line, including its stations, name and color.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct Line {\n    /// ID of the line.\n    id: LineID,\n    /// Name of the line.\n    name: String,\n    /// Color of the line.\n    color: (u8, u8, u8),\n    /// All stations the line visits.\n    stations: Vec\u003cStationID\u003e,\n    /// All edges between the stations.\n    edges: Vec\u003cEdgeID\u003e,\n}\n\nimpl Line {\n    /// Create a new [`Line`] with the stations it visits and an identifier.\n    /// Color and name are set to default values.\n    pub fn new(id: Option\u003cLineID\u003e) -\u003e Self {\n        if let Some(line_id) = id {\n            IDManager::update_line_id(line_id);\n        }\n\n        Self {\n            edges: Vec::new(),\n            stations: Vec::new(),\n            id: id.unwrap_or_else(IDManager::next_line_id),\n            color: (0, 0, 0),\n            name: String::new(),\n        }\n    }\n\n    /// A getter method for the stations the line visits.\n    pub fn get_stations(\u0026self) -\u003e \u0026[StationID] {\n        \u0026self.stations\n    }\n\n    /// A mutable getter method for the stations the line visits.\n    pub fn get_mut_stations(\u0026mut self) -\u003e \u0026mut [StationID] {\n        \u0026mut self.stations\n    }\n\n    /// Add a station. It will be inserted before the before station and after\n    /// the after station, Or at the end of the line. If before isn't in the\n    /// line yet, it will add both.\n    pub fn add_station(\n        \u0026mut self,\n        map: \u0026mut Map,\n        station: StationID,\n        before: Option\u003cStationID\u003e,\n        after: Option\u003cStationID\u003e,\n    ) {\n        if !self\n            .stations\n            .contains(\u0026station)\n        {\n            self.stations\n                .push(station);\n        }\n\n        if let (Some(before_station), Some(after_station)) = (before, after) {\n            if let Some(index) = self\n                .edges\n                .iter()\n                .map(|id| {\n                    map.get_edge(*id)\n                        .expect(\"line edge list contains invalid id\")\n                })\n                .position(|e| e.is_from(before_station) \u0026\u0026 e.is_to(after_station))\n            {\n                // replace edge with the station and the two edges connecting it\n                let edge_id = self.edges[index];\n                self.edges\n                    .remove(index);\n                map.removed_edge(edge_id, self.get_id());\n\n                self.add_edge(\n                    map.get_edge_id_between(station, before_station),\n                    map,\n                );\n                self.add_edge(\n                    map.get_edge_id_between(after_station, station),\n                    map,\n                );\n                return;\n            }\n            unreachable!(\"Station inserted on an edge, but can't find the edge.\");\n        }\n\n        if let Some(after_station) = after {\n            // Insert edge between station and the station it comes before\n            self.add_edge(\n                map.get_edge_id_between(station, after_station),\n                map,\n            );\n            return;\n        }\n\n        if let Some(before_station) = before {\n            // Insert edge between station and the station it comes after\n            self.add_edge(\n                map.get_edge_id_between(before_station, station),\n                map,\n            );\n        }\n    }\n\n    /// Remove a station from the line.\n    pub fn remove_station(\u0026mut self, map: \u0026mut Map, station: StationID) {\n        if let Some(index) = self\n            .stations\n            .iter()\n            .position(|s| s == \u0026station)\n        {\n            self.stations\n                .remove(index);\n        }\n\n        let mut ends = Vec::new();\n        let edges = self\n            .edges\n            .clone();\n        for edge_id in edges {\n            let edge = map\n                .get_edge(edge_id)\n                .expect(\"invalid edge id in line\");\n\n            if edge.get_to() == station {\n                ends.push(edge.get_from());\n\n                self.edges\n                    .retain(|e| *e != edge_id);\n                map.removed_edge(edge_id, self.get_id());\n            } else if edge.get_from() == station {\n                ends.push(edge.get_to());\n\n                self.edges\n                    .retain(|e| *e != edge_id);\n                map.removed_edge(edge_id, self.get_id());\n            }\n        }\n\n        for combinations in ends\n            .into_iter()\n            .combinations(2)\n        {\n            self.add_edge(\n                map.get_edge_id_between(combinations[0], combinations[1]),\n                map,\n            );\n        }\n    }\n\n    /// Add an edge that is being used by this line if it has not yet been\n    /// added.\n    pub fn add_edge(\u0026mut self, edge_id: EdgeID, map: \u0026mut Map) {\n        if self\n            .edges\n            .contains(\u0026edge_id)\n        {\n            return;\n        }\n\n        let edge = {\n            let edge = map\n                .get_mut_edge(edge_id)\n                .expect(\"adding invalid edge id to line\");\n            edge.add_line(self.get_id());\n            edge.clone()\n        };\n\n        self.edges\n            .push(edge_id);\n        self.add_station(map, edge.get_from(), None, None);\n        self.add_station(map, edge.get_to(), None, None);\n    }\n\n    /// Remove an edge from the line without further removal of it from the map\n    /// or adjecent stations.\n    pub fn remove_edge_raw(\u0026mut self, edge_id: EdgeID) {\n        self.edges\n            .retain(|e| *e != edge_id);\n    }\n\n    /// A setter for the station's color.\n    pub fn set_color(\u0026mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    /// A getter for the station's color.\n    #[inline]\n    pub fn get_color(\u0026self) -\u003e (u8, u8, u8) {\n        self.color\n    }\n\n    /// A setter for the station's name.\n    #[inline]\n    pub fn set_name(\u0026mut self, name: \u0026impl ToString) {\n        self.name = name.to_string();\n    }\n\n    /// A getter for the station's name.\n    pub fn get_name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// A getter for the station id.\n    #[inline]\n    pub fn get_id(\u0026self) -\u003e LineID {\n        self.id\n    }\n\n    /// A getter for the edges the line uses.\n    pub fn get_edges(\u0026self) -\u003e \u0026[EdgeID] {\n        \u0026self.edges\n    }\n\n    /// Get a list of neighbors of the given station.\n    pub fn get_station_neighbors(\n        \u0026self,\n        map: \u0026Map,\n        station: StationID,\n    ) -\u003e (Vec\u003cStationID\u003e, Vec\u003cStationID\u003e) {\n        let (mut before, mut after) = (Vec::new(), Vec::new());\n\n        for id in \u0026self.edges {\n            let edge = map\n                .get_edge(*id)\n                .expect(\"invalid edge id\");\n\n            if edge.get_from() == station {\n                after.push(edge.get_to());\n            } else if edge.get_to() == station {\n                before.push(edge.get_from());\n            }\n        }\n\n        (before, after)\n    }\n\n    /// Gets the stations on either side of the position on this line.\n    pub fn get_edge_stations(\n        \u0026self,\n        map: \u0026Map,\n        node: GridNode,\n    ) -\u003e (Option\u003cStationID\u003e, Option\u003cStationID\u003e) {\n        let mut from = None;\n        let mut to = None;\n\n        if self\n            .stations\n            .len()\n            == 1\n        {\n            if let Some(station) = map.get_station(self.stations[0]) {\n                if station\n                    .get_pos()\n                    .get_neighbors()\n                    .contains(\u0026node)\n                {\n                    return (Some(station.get_id()), None);\n                }\n            }\n            return (None, None);\n        }\n\n        if self\n            .stations\n            .is_empty()\n            || self\n                .edges\n                .is_empty()\n        {\n            return (None, None);\n        }\n\n        for id in \u0026self.edges {\n            if let Some(edge) = map.get_edge(*id) {\n                if let Some(res) = edge.get_neigboring_stations(map, node) {\n                    if res\n                        .0\n                        .is_some()\n                        \u0026\u0026 res\n                            .1\n                            .is_some()\n                    {\n                        return res;\n                    }\n\n                    if res\n                        .0\n                        .is_some()\n                        || res\n                            .1\n                            .is_some()\n                    {\n                        from = res.0;\n                        to = res.1;\n                    }\n                }\n            }\n        }\n\n        (from, to)\n    }\n\n    /// Returns true if the line goes through the given grid node.\n    pub fn visits_node(\u0026self, map: \u0026Map, node: GridNode) -\u003e bool {\n        if self\n            .edges\n            .iter()\n            .any(|e| {\n                map.get_edge(*e)\n                    .expect(\"invalid edge id\")\n                    .visits_node(map, node)\n            })\n        {\n            return true;\n        }\n\n        self.get_line_ends(map)\n            .into_iter()\n            .any(|e| {\n                map.get_station(e)\n                    .expect(\"edge contains invalid station id\")\n                    .is_neighbor(node)\n            })\n    }\n\n    /// Gets the start and end stations of the line.\n    fn get_line_ends(\u0026self, map: \u0026Map) -\u003e Vec\u003cStationID\u003e {\n        let mut ends = Vec::new();\n        let mut middles = Vec::new();\n\n        if self\n            .stations\n            .is_empty()\n            || self\n                .edges\n                .is_empty()\n        {\n            return self\n                .stations\n                .clone();\n        }\n\n        for id in \u0026self.edges {\n            let edge = map\n                .get_edge(*id)\n                .expect(\"invalid edge id\");\n\n            if !middles.contains(\u0026edge.get_from()) {\n                if let Some(i) = ends\n                    .iter()\n                    .position(|e| e == \u0026edge.get_from())\n                {\n                    ends.remove(i);\n                    middles.push(edge.get_from());\n                } else {\n                    ends.push(edge.get_from());\n                }\n            }\n\n            if !middles.contains(\u0026edge.get_to()) {\n                if let Some(i) = ends\n                    .iter()\n                    .position(|e| e == \u0026edge.get_to())\n                {\n                    ends.remove(i);\n                    middles.push(edge.get_to());\n                } else {\n                    ends.push(edge.get_to());\n                }\n            }\n        }\n\n        ends\n    }\n\n    /// Draws the line around a station if this line has only a single station.\n    pub fn draw(\u0026self, map: \u0026Map, canvas: \u0026CanvasContext\u003c'_\u003e, state: CanvasState) {\n        if self\n            .get_stations()\n            .len()\n            != 1\n        {\n            return;\n        }\n\n        let station = map\n            .get_station(self.get_stations()[0])\n            .expect(\"invalid station id on line\");\n\n        let mut width = state.drawn_square_size() / 10.0;\n        if width \u003c 1.0 {\n            width = 1.0;\n        }\n\n        canvas.set_line_width(width);\n        canvas.set_global_alpha(1.0);\n        canvas.set_stroke_style_str(\u0026format!(\n            \"rgb({} {} {})\",\n            self.color\n                .0,\n            self.color\n                .1,\n            self.color\n                .2\n        ));\n        canvas.begin_path();\n\n        let square_size = state.drawn_square_size();\n        let (station_x, station_y) = station.get_canvas_pos(state);\n        let offset = square_size / PI;\n\n        canvas.move_to(station_x - offset, station_y);\n        canvas.line_to(\n            station_x - (square_size - offset),\n            station_y,\n        );\n\n        canvas.move_to(station_x + offset, station_y);\n        canvas.line_to(\n            station_x + (square_size - offset),\n            station_y,\n        );\n\n        canvas.stroke();\n    }\n}\n\nimpl PartialEq for Line {\n    fn eq(\u0026self, other: \u0026Line) -\u003e bool {\n        other.id == self.id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::models::Station;\n\n    #[test]\n    fn test_add_station() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n        let station2: StationID = 2.into();\n        let station3: StationID = 3.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n        map.add_station(Station::new(\n            (0, 1).into(),\n            Some(station2),\n        ));\n        map.add_station(Station::new(\n            (0, 2).into(),\n            Some(station3),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n        line.add_station(\u0026mut map, station2, Some(station1), None);\n        line.add_station(\n            \u0026mut map,\n            station3,\n            Some(station1),\n            Some(station2),\n        );\n\n        assert_eq!(\n            line.get_stations(),\n            \u0026[station1, station2, station3]\n        );\n        assert_eq!(\n            line.get_edges()\n                .len(),\n            2\n        );\n        assert_eq!(\n            map.get_edges()\n                .len(),\n            2\n        );\n\n        assert!(\n            (map.get_edge(line.get_edges()[0])\n                .unwrap()\n                .is_from(station3)\n                \u0026\u0026 map\n                    .get_edge(line.get_edges()[0])\n                    .unwrap()\n                    .is_to(station1))\n                || (map\n                    .get_edge(line.get_edges()[1])\n                    .unwrap()\n                    .is_from(station3)\n                    \u0026\u0026 map\n                        .get_edge(line.get_edges()[1])\n                        .unwrap()\n                        .is_to(station1))\n        );\n        assert!(\n            (map.get_edge(line.get_edges()[0])\n                .unwrap()\n                .is_from(station2)\n                \u0026\u0026 map\n                    .get_edge(line.get_edges()[0])\n                    .unwrap()\n                    .is_to(station3))\n                || (map\n                    .get_edge(line.get_edges()[1])\n                    .unwrap()\n                    .is_from(station2)\n                    \u0026\u0026 map\n                        .get_edge(line.get_edges()[1])\n                        .unwrap()\n                        .is_to(station3))\n        );\n    }\n\n    #[test]\n    fn test_remove_station() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n        let station2: StationID = 2.into();\n        let station3: StationID = 3.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n        map.add_station(Station::new(\n            (0, 1).into(),\n            Some(station2),\n        ));\n        map.add_station(Station::new(\n            (0, 2).into(),\n            Some(station3),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n        line.add_station(\u0026mut map, station2, Some(station1), None);\n        line.add_station(\n            \u0026mut map,\n            station3,\n            Some(station1),\n            Some(station2),\n        );\n\n        line.remove_station(\u0026mut map, station3);\n\n        assert_eq!(\n            line.get_stations(),\n            \u0026[station1, station2]\n        );\n        assert_eq!(\n            line.get_edges()\n                .len(),\n            1\n        );\n        assert_eq!(\n            map.get_edges()\n                .len(),\n            1\n        );\n\n        assert!(\n            map.get_edge(line.get_edges()[0])\n                .unwrap()\n                .is_from(station1)\n                \u0026\u0026 map\n                    .get_edge(line.get_edges()[0])\n                    .unwrap()\n                    .is_to(station2)\n        );\n    }\n\n    #[test]\n    fn test_get_edge_stations() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n        let station2: StationID = 2.into();\n        let station3: StationID = 3.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n        map.add_station(Station::new(\n            (0, 2).into(),\n            Some(station2),\n        ));\n        map.add_station(Station::new(\n            (0, 4).into(),\n            Some(station3),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n        line.add_station(\u0026mut map, station2, Some(station1), None);\n        line.add_station(\u0026mut map, station3, Some(station2), None);\n\n        let temp_map = map.clone();\n        for edge in map.get_mut_edges() {\n            edge.calculate_nodes(\u0026temp_map);\n        }\n\n        assert_eq!(\n            line.get_edge_stations(\u0026map, (0, 1).into()),\n            (Some(station1), Some(station2))\n        );\n        assert_eq!(\n            line.get_edge_stations(\u0026map, (0, 3).into()),\n            (Some(station2), Some(station3))\n        );\n        assert_eq!(\n            line.get_edge_stations(\u0026map, (0, 5).into()),\n            (Some(station3), None)\n        );\n    }\n\n    #[test]\n    fn test_visits_node() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n        let station2: StationID = 2.into();\n        let station3: StationID = 3.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n        map.add_station(Station::new(\n            (0, 2).into(),\n            Some(station2),\n        ));\n        map.add_station(Station::new(\n            (0, 4).into(),\n            Some(station3),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n        line.add_station(\u0026mut map, station2, Some(station1), None);\n        line.add_station(\u0026mut map, station3, Some(station2), None);\n\n        let temp_map = map.clone();\n        for edge in map.get_mut_edges() {\n            edge.calculate_nodes(\u0026temp_map);\n        }\n\n        assert!(!line.visits_node(\u0026map, (0, -2).into()));\n        assert!(line.visits_node(\u0026map, (0, -1).into()));\n        assert!(line.visits_node(\u0026map, (0, 0).into()));\n        assert!(line.visits_node(\u0026map, (0, 1).into()));\n        assert!(line.visits_node(\u0026map, (0, 2).into()));\n        assert!(!line.visits_node(\u0026map, (1, 2).into()));\n        assert!(line.visits_node(\u0026map, (0, 3).into()));\n        assert!(line.visits_node(\u0026map, (0, 4).into()));\n        assert!(line.visits_node(\u0026map, (0, 5).into()));\n        assert!(!line.visits_node(\u0026map, (0, 6).into()));\n    }\n\n    #[test]\n    fn test_get_line_ends() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n        let station2: StationID = 2.into();\n        let station3: StationID = 3.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n        map.add_station(Station::new(\n            (0, 2).into(),\n            Some(station2),\n        ));\n        map.add_station(Station::new(\n            (0, 4).into(),\n            Some(station3),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n        line.add_station(\u0026mut map, station2, Some(station1), None);\n        line.add_station(\u0026mut map, station3, Some(station2), None);\n\n        let ends = line.get_line_ends(\u0026map);\n        assert_eq!(ends, vec![station1, station3]);\n    }\n\n    #[test]\n    fn test_draw_single_station() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n\n        let canvas = CanvasContext::new();\n        let mut state = CanvasState::new();\n        state.set_square_size(5);\n        line.draw(\u0026map, \u0026canvas, state);\n\n        let offset = 5.0 / PI;\n        assert_eq!(\n            canvas.get_record(\"move_to\"),\n            Some(vec![\n                format!(\"{:.1},0.0\", -offset),\n                format!(\"{:.1},0.0\", offset),\n            ])\n        );\n        assert_eq!(\n            canvas.get_record(\"line_to\"),\n            Some(vec![\n                format!(\"{:.1},0.0\", -5.0 + offset),\n                format!(\"{:.1},0.0\", 5.0 - offset),\n            ])\n        );\n    }\n\n    #[test]\n    fn test_draw_multiple_stations() {\n        let mut map = Map::new();\n        let mut line = Line::new(None);\n        let station1: StationID = 1.into();\n        let station2: StationID = 2.into();\n\n        map.add_station(Station::new(\n            (0, 0).into(),\n            Some(station1),\n        ));\n        map.add_station(Station::new(\n            (0, 2).into(),\n            Some(station2),\n        ));\n\n        line.add_station(\u0026mut map, station1, None, None);\n        line.add_station(\u0026mut map, station2, Some(station1), None);\n\n        let canvas = CanvasContext::new();\n        let state = CanvasState::new();\n        line.draw(\u0026map, \u0026canvas, state);\n\n        assert_eq!(canvas.get_record(\"move_to\"), None);\n        assert_eq!(canvas.get_record(\"line_to\"), None);\n    }\n}\n","traces":[{"line":35,"address":[7663056],"length":1,"stats":{"Line":1}},{"line":41,"address":[9931744],"length":1,"stats":{"Line":1}},{"line":47,"address":[9931760],"length":1,"stats":{"Line":0}},{"line":48,"address":[9931850],"length":1,"stats":{"Line":0}},{"line":70,"address":[9931920,9932266],"length":1,"stats":{"Line":1}},{"line":71,"address":[9931947],"length":1,"stats":{"Line":1}},{"line":72,"address":[9931968],"length":1,"stats":{"Line":1}},{"line":76,"address":[9931974],"length":1,"stats":{"Line":1}},{"line":77,"address":[9931988],"length":1,"stats":{"Line":1}},{"line":78,"address":[9932045],"length":1,"stats":{"Line":1}},{"line":79,"address":[9932116],"length":1,"stats":{"Line":4}},{"line":80,"address":[9932136],"length":1,"stats":{"Line":4}},{"line":85,"address":[9932288],"length":1,"stats":{"Line":1}},{"line":86,"address":[9932293],"length":1,"stats":{"Line":1}},{"line":90,"address":[7663616],"length":1,"stats":{"Line":0}},{"line":91,"address":[9932325],"length":1,"stats":{"Line":0}},{"line":97,"address":[9932352],"length":1,"stats":{"Line":6}},{"line":104,"address":[9932418],"length":1,"stats":{"Line":6}},{"line":108,"address":[9932454],"length":1,"stats":{"Line":6}},{"line":112,"address":[9932547,9932469],"length":1,"stats":{"Line":7}},{"line":113,"address":[7663847],"length":1,"stats":{"Line":1}},{"line":116,"address":[10147040],"length":1,"stats":{"Line":1}},{"line":117,"address":[9704766],"length":1,"stats":{"Line":1}},{"line":120,"address":[10147104,10147141],"length":1,"stats":{"Line":2}},{"line":123,"address":[9932698],"length":1,"stats":{"Line":1}},{"line":124,"address":[9932741],"length":1,"stats":{"Line":1}},{"line":126,"address":[9932763],"length":1,"stats":{"Line":1}},{"line":128,"address":[9932821],"length":1,"stats":{"Line":1}},{"line":129,"address":[7664062],"length":1,"stats":{"Line":1}},{"line":132,"address":[9932864],"length":1,"stats":{"Line":1}},{"line":133,"address":[7664100],"length":1,"stats":{"Line":1}},{"line":141,"address":[9932943,9932525],"length":1,"stats":{"Line":6}},{"line":143,"address":[9932980],"length":1,"stats":{"Line":0}},{"line":144,"address":[9932956],"length":1,"stats":{"Line":0}},{"line":150,"address":[9932988],"length":1,"stats":{"Line":6}},{"line":152,"address":[9933038],"length":1,"stats":{"Line":5}},{"line":153,"address":[9933014],"length":1,"stats":{"Line":5}},{"line":160,"address":[9933056,9934604,9934151],"length":1,"stats":{"Line":1}},{"line":161,"address":[7664367],"length":1,"stats":{"Line":1}},{"line":164,"address":[10147216,10147229],"length":1,"stats":{"Line":2}},{"line":166,"address":[9933222],"length":1,"stats":{"Line":1}},{"line":170,"address":[9933239],"length":1,"stats":{"Line":1}},{"line":171,"address":[9933272],"length":1,"stats":{"Line":1}},{"line":174,"address":[9933336,9933510,9933564],"length":1,"stats":{"Line":3}},{"line":175,"address":[9934165,9933580],"length":1,"stats":{"Line":2}},{"line":179,"address":[9934213],"length":1,"stats":{"Line":1}},{"line":180,"address":[9934297,9934499],"length":1,"stats":{"Line":2}},{"line":182,"address":[9934526],"length":1,"stats":{"Line":1}},{"line":183,"address":[9704976,9705001],"length":1,"stats":{"Line":2}},{"line":184,"address":[9934557],"length":1,"stats":{"Line":1}},{"line":185,"address":[9934317,9934280],"length":1,"stats":{"Line":2}},{"line":186,"address":[9934370],"length":1,"stats":{"Line":1}},{"line":188,"address":[9934414],"length":1,"stats":{"Line":1}},{"line":189,"address":[10147312,10147337],"length":1,"stats":{"Line":2}},{"line":190,"address":[9934445],"length":1,"stats":{"Line":1}},{"line":194,"address":[9933607,9933884,9933830],"length":1,"stats":{"Line":3}},{"line":198,"address":[9934118],"length":1,"stats":{"Line":1}},{"line":199,"address":[9933916,9934016],"length":1,"stats":{"Line":2}},{"line":207,"address":[9935118,9934640],"length":1,"stats":{"Line":1}},{"line":208,"address":[9934678],"length":1,"stats":{"Line":5}},{"line":216,"address":[9934718],"length":1,"stats":{"Line":1}},{"line":219,"address":[9934781],"length":1,"stats":{"Line":5}},{"line":220,"address":[9934813],"length":1,"stats":{"Line":1}},{"line":223,"address":[9934823],"length":1,"stats":{"Line":5}},{"line":225,"address":[9934897],"length":1,"stats":{"Line":1}},{"line":226,"address":[9935002],"length":1,"stats":{"Line":5}},{"line":231,"address":[9935152],"length":1,"stats":{"Line":0}},{"line":232,"address":[9935166],"length":1,"stats":{"Line":0}},{"line":233,"address":[10147385,10147360],"length":1,"stats":{"Line":0}},{"line":237,"address":[9935200],"length":1,"stats":{"Line":1}},{"line":238,"address":[9935241],"length":1,"stats":{"Line":1}},{"line":243,"address":[9935264],"length":1,"stats":{"Line":1}},{"line":244,"address":[9935269],"length":1,"stats":{"Line":1}},{"line":249,"address":[10147408,10147475],"length":1,"stats":{"Line":2}},{"line":250,"address":[9705288,9705144,9705362,9705218],"length":1,"stats":{"Line":4}},{"line":254,"address":[9935312],"length":1,"stats":{"Line":1}},{"line":255,"address":[9935317],"length":1,"stats":{"Line":1}},{"line":260,"address":[9935328],"length":1,"stats":{"Line":1}},{"line":261,"address":[7666453],"length":1,"stats":{"Line":1}},{"line":265,"address":[9935344],"length":1,"stats":{"Line":1}},{"line":266,"address":[9935349],"length":1,"stats":{"Line":1}},{"line":270,"address":[7666480,7667360,7667384],"length":1,"stats":{"Line":0}},{"line":275,"address":[7666536],"length":1,"stats":{"Line":0}},{"line":277,"address":[7666800,7667072,7666729],"length":1,"stats":{"Line":0}},{"line":278,"address":[9936023],"length":1,"stats":{"Line":0}},{"line":279,"address":[9936020],"length":1,"stats":{"Line":0}},{"line":282,"address":[9936092],"length":1,"stats":{"Line":0}},{"line":283,"address":[7667233,7667348],"length":1,"stats":{"Line":0}},{"line":284,"address":[9936159,9936193],"length":1,"stats":{"Line":0}},{"line":285,"address":[9936246],"length":1,"stats":{"Line":0}},{"line":289,"address":[9935824],"length":1,"stats":{"Line":0}},{"line":293,"address":[7667950,7667408],"length":1,"stats":{"Line":1}},{"line":298,"address":[7667468],"length":1,"stats":{"Line":1}},{"line":299,"address":[9936437],"length":1,"stats":{"Line":1}},{"line":301,"address":[9936446],"length":1,"stats":{"Line":1}},{"line":306,"address":[9936563,9936467],"length":1,"stats":{"Line":0}},{"line":307,"address":[9936581,9936765],"length":1,"stats":{"Line":0}},{"line":310,"address":[7667815,7667747],"length":1,"stats":{"Line":0}},{"line":312,"address":[9936827],"length":1,"stats":{"Line":0}},{"line":315,"address":[7667666],"length":1,"stats":{"Line":0}},{"line":318,"address":[7667577],"length":1,"stats":{"Line":1}},{"line":321,"address":[9936959],"length":1,"stats":{"Line":1}},{"line":325,"address":[9936980],"length":1,"stats":{"Line":0}},{"line":328,"address":[7668078,7668203],"length":1,"stats":{"Line":2}},{"line":329,"address":[7668219],"length":1,"stats":{"Line":1}},{"line":330,"address":[7668289],"length":1,"stats":{"Line":1}},{"line":331,"address":[9937392],"length":1,"stats":{"Line":1}},{"line":334,"address":[7668441],"length":1,"stats":{"Line":1}},{"line":338,"address":[7668469],"length":1,"stats":{"Line":1}},{"line":341,"address":[9937410,9937590],"length":1,"stats":{"Line":2}},{"line":344,"address":[7668521],"length":1,"stats":{"Line":1}},{"line":348,"address":[9937538],"length":1,"stats":{"Line":1}},{"line":349,"address":[7668573],"length":1,"stats":{"Line":1}},{"line":355,"address":[7668158],"length":1,"stats":{"Line":1}},{"line":359,"address":[7668608,7668849],"length":1,"stats":{"Line":1}},{"line":360,"address":[9937641],"length":1,"stats":{"Line":1}},{"line":363,"address":[9705408],"length":1,"stats":{"Line":1}},{"line":364,"address":[10147570,10147629],"length":1,"stats":{"Line":2}},{"line":366,"address":[9705471],"length":1,"stats":{"Line":1}},{"line":369,"address":[7668774],"length":1,"stats":{"Line":1}},{"line":372,"address":[9937718,9937826],"length":1,"stats":{"Line":2}},{"line":374,"address":[9705504],"length":1,"stats":{"Line":1}},{"line":375,"address":[9705522,9705573],"length":1,"stats":{"Line":2}},{"line":377,"address":[10147710],"length":1,"stats":{"Line":1}},{"line":382,"address":[7670390,7668880],"length":1,"stats":{"Line":1}},{"line":383,"address":[7668935],"length":1,"stats":{"Line":1}},{"line":384,"address":[7668972],"length":1,"stats":{"Line":1}},{"line":386,"address":[9938053,9938123],"length":1,"stats":{"Line":2}},{"line":389,"address":[9938137,9938200],"length":1,"stats":{"Line":2}},{"line":393,"address":[7669138],"length":1,"stats":{"Line":0}},{"line":398,"address":[9938214,9938415],"length":1,"stats":{"Line":2}},{"line":399,"address":[7669381,7669428],"length":1,"stats":{"Line":2}},{"line":400,"address":[7669378],"length":1,"stats":{"Line":1}},{"line":403,"address":[7669486],"length":1,"stats":{"Line":1}},{"line":404,"address":[9938789,9938700],"length":1,"stats":{"Line":2}},{"line":406,"address":[10147744,10147758],"length":1,"stats":{"Line":4}},{"line":408,"address":[7669859],"length":1,"stats":{"Line":2}},{"line":409,"address":[9938992],"length":1,"stats":{"Line":2}},{"line":411,"address":[9939038,9938972],"length":1,"stats":{"Line":4}},{"line":415,"address":[7669670,7670005],"length":1,"stats":{"Line":4}},{"line":416,"address":[7670081],"length":1,"stats":{"Line":2}},{"line":418,"address":[10147808,10147822],"length":1,"stats":{"Line":4}},{"line":420,"address":[9939344],"length":1,"stats":{"Line":0}},{"line":421,"address":[7670287],"length":1,"stats":{"Line":0}},{"line":423,"address":[7670337,7670267],"length":1,"stats":{"Line":4}},{"line":428,"address":[9938357],"length":1,"stats":{"Line":2}},{"line":432,"address":[9939568,9940746],"length":1,"stats":{"Line":1}},{"line":433,"address":[9939622],"length":1,"stats":{"Line":1}},{"line":441,"address":[9939688],"length":1,"stats":{"Line":1}},{"line":442,"address":[9939639,9939800,9939685],"length":1,"stats":{"Line":2}},{"line":445,"address":[7670594],"length":1,"stats":{"Line":1}},{"line":446,"address":[9940284,9939770],"length":1,"stats":{"Line":2}},{"line":447,"address":[9940267],"length":1,"stats":{"Line":1}},{"line":450,"address":[9939825],"length":1,"stats":{"Line":1}},{"line":451,"address":[9939870],"length":1,"stats":{"Line":1}},{"line":452,"address":[9939902,9940250,9940107,9940047,9940348,9939984],"length":1,"stats":{"Line":6}},{"line":461,"address":[9940378],"length":1,"stats":{"Line":1}},{"line":463,"address":[9940401],"length":1,"stats":{"Line":1}},{"line":464,"address":[9940430],"length":1,"stats":{"Line":1}},{"line":465,"address":[9940511],"length":1,"stats":{"Line":1}},{"line":467,"address":[7671299],"length":1,"stats":{"Line":1}},{"line":468,"address":[9940580,9940621],"length":1,"stats":{"Line":1}},{"line":469,"address":[7671337],"length":1,"stats":{"Line":1}},{"line":473,"address":[9940632],"length":1,"stats":{"Line":1}},{"line":474,"address":[9940715,9940674],"length":1,"stats":{"Line":1}},{"line":475,"address":[9940707],"length":1,"stats":{"Line":1}},{"line":479,"address":[9940726],"length":1,"stats":{"Line":1}},{"line":484,"address":[9940768],"length":1,"stats":{"Line":0}},{"line":485,"address":[9940793],"length":1,"stats":{"Line":0}}],"covered":139,"coverable":169},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","map.rs"],"content":"//! Contains the [`Map`] struct and all its methods.\n\nuse std::collections::HashMap;\n\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse super::{\n    line::LineID,\n    station::StationID,\n    Edge,\n    EdgeID,\n    GridNode,\n    Line,\n    Station,\n};\nuse crate::{\n    algorithm::drawing::CanvasContext,\n    components::CanvasState,\n    unwrap_or_return,\n    utils::Result,\n    Error,\n};\n\n/// Represents the metro map as a whole with all its lines and stations.\n#[derive(Clone, Debug, Default, Serialize, Deserialize)]\npub struct Map {\n    /// A [`HashMap`] of all stations on the map.\n    stations: HashMap\u003cStationID, Station\u003e,\n    /// A [`HashMap`] of all lines on the map.\n    lines: HashMap\u003cLineID, Line\u003e,\n    /// A [`HashMap`] of all edges on the map.\n    edges: HashMap\u003cEdgeID, Edge\u003e,\n}\n\nimpl Map {\n    /// Creates a new, empty map.\n    pub fn new() -\u003e Self {\n        Self {\n            stations: HashMap::new(),\n            lines: HashMap::new(),\n            edges: HashMap::new(),\n        }\n    }\n\n    /// Get a [`Station`] with the given id.\n    pub fn get_station(\u0026self, id: StationID) -\u003e Option\u003c\u0026Station\u003e {\n        self.stations\n            .get(\u0026id)\n    }\n\n    /// Get a mutable [`Station`] with the given id.\n    pub fn get_mut_station(\u0026mut self, id: StationID) -\u003e Option\u003c\u0026mut Station\u003e {\n        self.stations\n            .get_mut(\u0026id)\n    }\n\n    /// Get a [`Line`] with the given id.\n    pub fn get_line(\u0026self, id: LineID) -\u003e Option\u003c\u0026Line\u003e {\n        self.lines\n            .get(\u0026id)\n    }\n\n    /// Get a mutable [`Line`] with the given id.\n    pub fn get_mut_line(\u0026mut self, id: LineID) -\u003e Option\u003c\u0026mut Line\u003e {\n        self.lines\n            .get_mut(\u0026id)\n    }\n\n    /// Get a list of all [`Line`]s on the map.\n    pub fn get_lines(\u0026self) -\u003e Vec\u003c\u0026Line\u003e {\n        self.lines\n            .values()\n            .collect()\n    }\n\n    /// Get a mutable reference to all [`Line`]s on the map.\n    pub fn get_mut_lines(\u0026mut self) -\u003e Vec\u003c\u0026mut Line\u003e {\n        self.lines\n            .values_mut()\n            .collect()\n    }\n\n    /// Get a [`Edge`] with the given id.\n    pub fn get_edge(\u0026self, id: EdgeID) -\u003e Option\u003c\u0026Edge\u003e {\n        self.edges\n            .get(\u0026id)\n    }\n\n    /// Get a mutable [`Edge`] with the given id.\n    pub fn get_mut_edge(\u0026mut self, id: EdgeID) -\u003e Option\u003c\u0026mut Edge\u003e {\n        self.edges\n            .get_mut(\u0026id)\n    }\n\n    /// Get a list of all [`Edge`]s on the map.\n    pub fn get_edges(\u0026self) -\u003e Vec\u003c\u0026Edge\u003e {\n        self.edges\n            .values()\n            .collect()\n    }\n\n    /// Get a mutable reference to all [`Edge`]s on the map.\n    pub fn get_mut_edges(\u0026mut self) -\u003e Vec\u003c\u0026mut Edge\u003e {\n        self.edges\n            .values_mut()\n            .collect()\n    }\n\n    /// Get the [`Edge`] between the two given stations.\n    pub fn get_edge_id_between_if_exists(\u0026self, from: StationID, to: StationID) -\u003e Option\u003cEdgeID\u003e {\n        self.get_edges()\n            .into_iter()\n            .find(|e| (e.is_from(from) \u0026\u0026 e.is_to(to)) || (e.is_from(to) \u0026\u0026 e.is_to(from)))\n            .map(Edge::get_id)\n    }\n\n    /// Get the id of the [`Edge`] between the two given stations, else create\n    /// one.\n    pub fn get_edge_id_between(\u0026mut self, from: StationID, to: StationID) -\u003e EdgeID {\n        if let Some(e) = self.get_edge_id_between_if_exists(from, to) {\n            return e;\n        }\n\n        let new = Edge::new(from, to, None);\n        let new_id = new.get_id();\n        self.add_edge(new);\n\n        new_id\n    }\n\n    /// A getter for the stations on the map.\n    pub fn get_stations(\u0026self) -\u003e Vec\u003c\u0026Station\u003e {\n        self.stations\n            .values()\n            .collect()\n    }\n\n    /// A mutable getter for the stations on the map.\n    pub fn get_mut_stations(\u0026mut self) -\u003e Vec\u003c\u0026mut Station\u003e {\n        self.stations\n            .values_mut()\n            .collect()\n    }\n\n    /// Add a station to the map, if a station already exists with that ID, it\n    /// will be replaces.\n    pub fn add_station(\u0026mut self, station: Station) {\n        self.stations\n            .insert(station.get_id(), station);\n    }\n\n    /// Remove a station from the map.\n    pub fn remove_station(\u0026mut self, id: StationID) {\n        let lines: Vec\u003c_\u003e = self\n            .lines\n            .values()\n            .cloned()\n            .collect();\n        for mut line in lines {\n            line.remove_station(self, id);\n            self.add_line(line);\n        }\n\n        self.stations\n            .remove(\u0026id);\n    }\n\n    /// Add a line to the map.\n    pub fn add_line(\u0026mut self, line: Line) {\n        for edge_id in line.get_edges() {\n            if let Some(edge) = self.get_mut_edge(*edge_id) {\n                edge.add_line(line.get_id());\n            }\n        }\n\n        self.lines\n            .insert(line.get_id(), line);\n    }\n\n    /// Get mutable [`Line`] if exists, else add new line with that [`LineID`]\n    /// and return it.\n    pub fn get_or_add_line(\u0026mut self, id: LineID) -\u003e \u0026Line {\n        self.lines\n            .entry(id)\n            .or_insert_with(|| Line::new(Some(id)));\n\n        self.get_line(id)\n            .expect(\"did not find newly inserted line\")\n    }\n\n    /// Remove a line from the map.\n    pub fn remove_line(\u0026mut self, id: LineID) {\n        let line = unwrap_or_return!(self\n            .lines\n            .remove(\u0026id)\n            .ok_or(Error::other(\"line to remove not found\")));\n\n        for edge_id in line.get_edges() {\n            if let Some(edge) = self.get_mut_edge(*edge_id) {\n                edge.remove_line(id);\n\n                if edge\n                    .get_lines()\n                    .is_empty()\n                {\n                    self.remove_edge(*edge_id);\n                }\n            }\n        }\n    }\n\n    /// Add an edge to map, if an edge with that ID already exists, it will get\n    /// replaces.\n    pub fn add_edge(\u0026mut self, edge: Edge) {\n        self.get_mut_station(edge.get_from())\n            .expect(\"from station not found\")\n            .add_edge(edge.get_id());\n        self.get_mut_station(edge.get_to())\n            .expect(\"to station not found\")\n            .add_edge(edge.get_id());\n\n        self.edges\n            .insert(edge.get_id(), edge);\n    }\n\n    /// Remove an edge from the map.\n    pub fn remove_edge(\u0026mut self, id: EdgeID) {\n        if let Some(edge) = self\n            .edges\n            .remove(\u0026id)\n        {\n            if let Some(from_station) = self.get_mut_station(edge.get_from()) {\n                from_station.remove_edge(id);\n            }\n            if let Some(to_station) = self.get_mut_station(edge.get_to()) {\n                to_station.remove_edge(id);\n            }\n            for line in self.get_mut_lines() {\n                line.remove_edge_raw(id);\n            }\n        }\n    }\n\n    /// Update the nodes of all edges on the map, this errors if trying to\n    /// update a non-existing edge.\n    pub fn update_edges(\u0026mut self, edges: Vec\u003cEdge\u003e) -\u003e Result\u003c()\u003e {\n        for edge in edges {\n            let existing_edge = self\n                .get_mut_edge(edge.get_id())\n                .ok_or(Error::other(\n                    \"edge not found when updating edge\",\n                ))?;\n\n            existing_edge.set_nodes(\n                edge.get_nodes()\n                    .to_owned(),\n            );\n        }\n\n        Ok(())\n    }\n\n    /// Get the station located on the given grid node.\n    pub fn station_at_node(\u0026self, node: GridNode) -\u003e Option\u003cStationID\u003e {\n        self.stations\n            .values()\n            .find(|s| s.get_pos() == node)\n            .map(Station::get_id)\n    }\n\n    /// Get the line that goes through the given grid node.\n    pub fn line_at_node(\u0026self, node: GridNode) -\u003e Option\u003c\u0026Line\u003e {\n        self.lines\n            .values()\n            .find(|l| l.visits_node(self, node))\n    }\n\n    /// Notify that the given edge was removed from a line and thus all lines\n    /// should be check and the edge fully removed if not in use any other than\n    /// from.\n    pub fn removed_edge(\u0026mut self, id: EdgeID, from: LineID) {\n        let mut lines_found = Vec::new();\n        for line in self\n            .lines\n            .values()\n        {\n            if line.get_id() != from\n                \u0026\u0026 line\n                    .get_edges()\n                    .contains(\u0026id)\n            {\n                lines_found.push(line.get_id());\n            }\n        }\n\n        if lines_found.is_empty() {\n            self.remove_edge(id);\n        } else if let Some(edge) = self.get_mut_edge(id) {\n            edge.set_lines(lines_found);\n        }\n    }\n\n    /// Draw the map to the given canvas.\n    pub fn draw(\u0026self, canvas: \u0026CanvasContext\u003c'_\u003e, state: CanvasState) {\n        for edge in self.get_edges() {\n            edge.draw(self, canvas, state);\n        }\n\n        for line in self.get_lines() {\n            line.draw(self, canvas, state);\n        }\n\n        for station in self.get_stations() {\n            station.draw(canvas, state);\n        }\n    }\n\n    /// Use the A* algorithm to calculate the edges between all stations\n    /// quickly.\n    pub fn quickcalc_edges(\u0026mut self) {\n        let temp_map = self.clone();\n        for edge in self.get_mut_edges() {\n            edge.calculate_nodes(\u0026temp_map);\n        }\n    }\n}\n","traces":[{"line":40,"address":[10132176,10132399],"length":1,"stats":{"Line":5}},{"line":42,"address":[9063078],"length":1,"stats":{"Line":5}},{"line":43,"address":[10132207],"length":1,"stats":{"Line":5}},{"line":44,"address":[10132264],"length":1,"stats":{"Line":5}},{"line":49,"address":[10132432],"length":1,"stats":{"Line":1}},{"line":50,"address":[9063310],"length":1,"stats":{"Line":2}},{"line":55,"address":[10132464],"length":1,"stats":{"Line":2}},{"line":56,"address":[10132478],"length":1,"stats":{"Line":2}},{"line":61,"address":[10132496],"length":1,"stats":{"Line":1}},{"line":62,"address":[10132510],"length":1,"stats":{"Line":1}},{"line":67,"address":[10132544],"length":1,"stats":{"Line":1}},{"line":68,"address":[10132558],"length":1,"stats":{"Line":1}},{"line":73,"address":[10132592],"length":1,"stats":{"Line":1}},{"line":74,"address":[10132611],"length":1,"stats":{"Line":1}},{"line":80,"address":[10132656],"length":1,"stats":{"Line":1}},{"line":81,"address":[10132675],"length":1,"stats":{"Line":1}},{"line":87,"address":[10132720],"length":1,"stats":{"Line":1}},{"line":88,"address":[9063598],"length":1,"stats":{"Line":1}},{"line":93,"address":[10132768],"length":1,"stats":{"Line":5}},{"line":94,"address":[10132782],"length":1,"stats":{"Line":1}},{"line":99,"address":[10132816],"length":1,"stats":{"Line":5}},{"line":100,"address":[9063699],"length":1,"stats":{"Line":1}},{"line":106,"address":[10132880],"length":1,"stats":{"Line":2}},{"line":107,"address":[10132899],"length":1,"stats":{"Line":2}},{"line":113,"address":[10133137,10132944],"length":1,"stats":{"Line":5}},{"line":114,"address":[9063934,9063846],"length":1,"stats":{"Line":6}},{"line":116,"address":[8811488,8811514],"length":1,"stats":{"Line":6}},{"line":122,"address":[9064000,9064393,9064418],"length":1,"stats":{"Line":5}},{"line":123,"address":[10133214],"length":1,"stats":{"Line":5}},{"line":124,"address":[10133259],"length":1,"stats":{"Line":2}},{"line":127,"address":[10133276],"length":1,"stats":{"Line":1}},{"line":128,"address":[10133336,10133412],"length":1,"stats":{"Line":6}},{"line":129,"address":[9064247],"length":1,"stats":{"Line":5}},{"line":131,"address":[10133552],"length":1,"stats":{"Line":1}},{"line":135,"address":[10133616],"length":1,"stats":{"Line":5}},{"line":136,"address":[10133635],"length":1,"stats":{"Line":3}},{"line":142,"address":[9064496],"length":1,"stats":{"Line":0}},{"line":143,"address":[10133699],"length":1,"stats":{"Line":0}},{"line":150,"address":[10133993,10134022,10133744],"length":1,"stats":{"Line":2}},{"line":151,"address":[10133782,10133945],"length":1,"stats":{"Line":4}},{"line":152,"address":[10133969,10133798,10133866],"length":1,"stats":{"Line":7}},{"line":156,"address":[10134694,10134032],"length":1,"stats":{"Line":0}},{"line":157,"address":[10134062],"length":1,"stats":{"Line":0}},{"line":162,"address":[10134117,10134363,10134667,10134265],"length":1,"stats":{"Line":0}},{"line":163,"address":[10134467],"length":1,"stats":{"Line":0}},{"line":164,"address":[9065333],"length":1,"stats":{"Line":0}},{"line":167,"address":[10134318],"length":1,"stats":{"Line":0}},{"line":168,"address":[10134337],"length":1,"stats":{"Line":0}},{"line":172,"address":[10135271,10135300,10134720],"length":1,"stats":{"Line":1}},{"line":173,"address":[9065558,9065642,9065768],"length":1,"stats":{"Line":3}},{"line":174,"address":[10134993,10135168],"length":1,"stats":{"Line":2}},{"line":175,"address":[9066010],"length":1,"stats":{"Line":1}},{"line":179,"address":[10134954,10135109],"length":1,"stats":{"Line":2}},{"line":180,"address":[10135136,10134963,10135030],"length":1,"stats":{"Line":3}},{"line":185,"address":[10135312],"length":1,"stats":{"Line":0}},{"line":186,"address":[9066105],"length":1,"stats":{"Line":0}},{"line":188,"address":[9771248,9771265],"length":1,"stats":{"Line":0}},{"line":190,"address":[9066144],"length":1,"stats":{"Line":0}},{"line":195,"address":[9067073,9066192],"length":1,"stats":{"Line":0}},{"line":196,"address":[10135569,10135620,10135455],"length":1,"stats":{"Line":0}},{"line":199,"address":[10136377,10135497,10135612],"length":1,"stats":{"Line":0}},{"line":201,"address":[10136000,10135848,10136131],"length":1,"stats":{"Line":0}},{"line":202,"address":[9066918,9066890],"length":1,"stats":{"Line":0}},{"line":203,"address":[9066980],"length":1,"stats":{"Line":0}},{"line":205,"address":[10136267],"length":1,"stats":{"Line":0}},{"line":209,"address":[10136336],"length":1,"stats":{"Line":0}},{"line":217,"address":[10136915,10136944,10136400],"length":1,"stats":{"Line":1}},{"line":218,"address":[9067312,9067158,9067237],"length":1,"stats":{"Line":5}},{"line":220,"address":[9067290],"length":1,"stats":{"Line":2}},{"line":221,"address":[10136616,10136721],"length":1,"stats":{"Line":4}},{"line":223,"address":[9067399],"length":1,"stats":{"Line":2}},{"line":225,"address":[10136867,10136742],"length":1,"stats":{"Line":3}},{"line":226,"address":[10136891,10136750],"length":1,"stats":{"Line":4}},{"line":230,"address":[10136960,10137791],"length":1,"stats":{"Line":1}},{"line":231,"address":[9067679],"length":1,"stats":{"Line":1}},{"line":235,"address":[10137279,10137172],"length":1,"stats":{"Line":2}},{"line":236,"address":[9068032,9068064],"length":1,"stats":{"Line":2}},{"line":238,"address":[10137401,10137377],"length":1,"stats":{"Line":2}},{"line":239,"address":[10137475,10137515],"length":1,"stats":{"Line":2}},{"line":241,"address":[10137679,10137735,10137517,10137496],"length":1,"stats":{"Line":3}},{"line":242,"address":[9068428,9068398],"length":1,"stats":{"Line":0}},{"line":249,"address":[9068496,9069245],"length":1,"stats":{"Line":0}},{"line":250,"address":[9068539,9068707,9068649],"length":1,"stats":{"Line":0}},{"line":251,"address":[9068962,9068902,9069131],"length":1,"stats":{"Line":0}},{"line":252,"address":[10138197],"length":1,"stats":{"Line":0}},{"line":253,"address":[10138292],"length":1,"stats":{"Line":0}},{"line":257,"address":[9069190],"length":1,"stats":{"Line":0}},{"line":258,"address":[9069171,9069045],"length":1,"stats":{"Line":0}},{"line":263,"address":[9068699],"length":1,"stats":{"Line":0}},{"line":267,"address":[9069280],"length":1,"stats":{"Line":0}},{"line":268,"address":[9069312],"length":1,"stats":{"Line":0}},{"line":270,"address":[9771331,9771312],"length":1,"stats":{"Line":0}},{"line":275,"address":[9069360],"length":1,"stats":{"Line":0}},{"line":276,"address":[10138795],"length":1,"stats":{"Line":0}},{"line":278,"address":[8811808,8811825],"length":1,"stats":{"Line":0}},{"line":284,"address":[10138848,10139529,10139558],"length":1,"stats":{"Line":1}},{"line":285,"address":[10138878],"length":1,"stats":{"Line":1}},{"line":286,"address":[10138977,10138913,10139116],"length":1,"stats":{"Line":2}},{"line":290,"address":[10139370,10139137],"length":1,"stats":{"Line":0}},{"line":291,"address":[10139424],"length":1,"stats":{"Line":0}},{"line":295,"address":[10139493],"length":1,"stats":{"Line":0}},{"line":299,"address":[10139096,10139156],"length":1,"stats":{"Line":2}},{"line":300,"address":[10139334,10139193],"length":1,"stats":{"Line":2}},{"line":301,"address":[10139214,10139167],"length":1,"stats":{"Line":0}},{"line":302,"address":[9069892,9069831],"length":1,"stats":{"Line":0}},{"line":307,"address":[10140531,10139568],"length":1,"stats":{"Line":0}},{"line":308,"address":[10139612,10139752,10139922],"length":1,"stats":{"Line":0}},{"line":309,"address":[10140558,10139938],"length":1,"stats":{"Line":0}},{"line":312,"address":[9070338,9070757,9070587,9070530],"length":1,"stats":{"Line":0}},{"line":313,"address":[10140553,10140257],"length":1,"stats":{"Line":0}},{"line":316,"address":[10140124,10140387,10140456,10140314],"length":1,"stats":{"Line":0}},{"line":317,"address":[10140472],"length":1,"stats":{"Line":0}},{"line":323,"address":[10140950,10140576],"length":1,"stats":{"Line":2}},{"line":324,"address":[10140604],"length":1,"stats":{"Line":2}},{"line":325,"address":[10140614,10140674,10140894,10140838],"length":1,"stats":{"Line":8}},{"line":326,"address":[10140910,10140945],"length":1,"stats":{"Line":4}}],"covered":68,"coverable":116},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","mod.rs"],"content":"//! Contains all structs used to represent the metro map within the algorithm.\n\nmod edge;\nmod grid_node;\nmod line;\nmod map;\nmod selected_line;\nmod selected_station;\nmod station;\n\npub use edge::{\n    Edge,\n    EdgeID,\n};\npub use grid_node::GridNode;\npub use line::{\n    Line,\n    LineID,\n};\npub use map::Map;\npub use selected_line::SelectedLine;\npub use selected_station::SelectedStation;\npub use station::{\n    Station,\n    StationID,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","selected_line.rs"],"content":"//! Contains the [`SelectedLine`] struct and all its methods.\n\nuse super::{\n    GridNode,\n    Line,\n    LineID,\n    Map,\n    StationID,\n};\nuse crate::{\n    algorithm::{\n        drawing::{\n            draw_edge,\n            CanvasContext,\n        },\n        run_a_star,\n    },\n    components::CanvasState,\n};\n\n/// Holds information about the currently selected [`Line`].\n#[derive(Debug, Copy, Clone)]\npub struct SelectedLine {\n    /// The selected line.\n    line: LineID,\n    /// The coordinate the line was grabbed at.\n    grabbed_at: Option\u003cGridNode\u003e,\n    /// The stations before and after the point the line was grabbed if\n    /// applicable.\n    before_after: (Option\u003cStationID\u003e, Option\u003cStationID\u003e),\n    /// The grid coordinate the user is currently hovering over.\n    current_hover: GridNode,\n}\n\nimpl SelectedLine {\n    /// Select a line.\n    pub fn new(\n        line: \u0026Line,\n        map: \u0026Map,\n        current_hover: GridNode,\n        grabbed_at: Option\u003cGridNode\u003e,\n    ) -\u003e Self {\n        let mut before_after = (None, None);\n        if let Some(grabbed_node) = grabbed_at {\n            before_after = line.get_edge_stations(map, grabbed_node);\n        }\n\n        Self {\n            line: line.get_id(),\n            grabbed_at,\n            before_after,\n            current_hover,\n        }\n    }\n\n    /// Select a newly created line.\n    pub fn new_line(map: \u0026mut Map) -\u003e Self {\n        let line = Line::new(None);\n        let line_id = line.get_id();\n        map.add_line(line);\n\n        Self {\n            line: line_id,\n            current_hover: GridNode::from((i32::MIN, i32::MIN)),\n            before_after: (None, None),\n            grabbed_at: None,\n        }\n    }\n\n    /// Get the current hover coordinate.\n    #[inline]\n    pub fn get_current_hover(\u0026self) -\u003e GridNode {\n        self.current_hover\n    }\n\n    /// Set the current hover coordinate.\n    pub fn set_current_hover(\u0026mut self, at: GridNode) {\n        self.current_hover = at;\n    }\n\n    /// Get the underlying selected line.\n    #[inline]\n    pub fn get_line(\u0026self) -\u003e LineID {\n        self.line\n    }\n\n    /// Get the coordinate the line was grabbet at.\n    #[inline]\n    pub fn get_grabbed_at(\u0026self) -\u003e Option\u003cGridNode\u003e {\n        self.grabbed_at\n    }\n\n    /// Get the stations before and after the point the line was grabbed.\n    #[inline]\n    pub fn get_before_after(\u0026self) -\u003e (Option\u003cStationID\u003e, Option\u003cStationID\u003e) {\n        self.before_after\n    }\n\n    /// Set the station that came before the point the line was grabbed.\n    pub fn set_before(\u0026mut self, before: StationID) {\n        self.before_after\n            .0 = Some(before);\n    }\n\n    /// Set the station that came after the point the line was grabbed.\n    pub fn set_after(\u0026mut self, after: StationID) {\n        self.before_after\n            .1 = Some(after);\n    }\n\n    /// Draw the selected line to the given canvas.\n    pub fn draw(\u0026self, map: \u0026Map, canvas: \u0026CanvasContext\u003c'_\u003e, state: CanvasState) {\n        let (hover_x, hover_y) = self\n            .get_current_hover()\n            .to_canvas_pos(state);\n        let half_square = state.drawn_square_size() / 2.0;\n        let line = map\n            .get_line(self.get_line())\n            .expect(\"drawing invalid line id\");\n\n        canvas.set_line_width(3.0);\n        canvas.set_stroke_style_str(\u0026format!(\n            \"rgb({} {} {})\",\n            line.get_color()\n                .0,\n            line.get_color()\n                .1,\n            line.get_color()\n                .2\n        ));\n        canvas.set_global_alpha(0.5);\n        canvas.begin_path();\n\n        canvas.move_to(hover_x, hover_y + half_square);\n        canvas.line_to(hover_x, hover_y - half_square);\n        canvas.move_to(hover_x + half_square, hover_y);\n        canvas.line_to(hover_x - half_square, hover_y);\n\n        let draw_before = |before: StationID| {\n            let before_station = map\n                .get_station(before)\n                .expect(\"invalid station id\");\n            draw_edge(\n                self.get_current_hover(),\n                before_station.get_pos(),\n                \u0026run_a_star(\n                    self.get_current_hover(),\n                    before_station.get_pos(),\n                ),\n                canvas,\n                state,\n                0.0,\n            );\n        };\n        let draw_after = |after: StationID| {\n            let after_station = map\n                .get_station(after)\n                .expect(\"invalid station id\");\n            draw_edge(\n                after_station.get_pos(),\n                self.get_current_hover(),\n                \u0026run_a_star(\n                    after_station.get_pos(),\n                    self.get_current_hover(),\n                ),\n                canvas,\n                state,\n                0.0,\n            );\n        };\n\n        match self.get_before_after() {\n            (None, None) =\u003e {},\n            (Some(before), None) =\u003e {\n                draw_before(before);\n            },\n            (None, Some(after)) =\u003e {\n                draw_after(after);\n            },\n            (Some(before), Some(after)) =\u003e {\n                draw_before(before);\n                draw_after(after);\n            },\n        }\n\n        canvas.stroke();\n        canvas.begin_path();\n\n        if let Some(origin) = self.get_grabbed_at() {\n            canvas\n                .set_line_dash(\u0026[5u8, 5])\n                .unwrap();\n\n            let (origin_x, origin_y) = origin.to_canvas_pos(state);\n            canvas.move_to(origin_x, origin_y);\n            canvas.line_to(hover_x, hover_y);\n\n            canvas.stroke();\n        }\n    }\n}\n","traces":[{"line":37,"address":[7968112],"length":1,"stats":{"Line":0}},{"line":43,"address":[8471960],"length":1,"stats":{"Line":0}},{"line":44,"address":[8472018],"length":1,"stats":{"Line":0}},{"line":45,"address":[8472064],"length":1,"stats":{"Line":0}},{"line":49,"address":[8472129],"length":1,"stats":{"Line":0}},{"line":57,"address":[8472824,8472853,8472304],"length":1,"stats":{"Line":0}},{"line":58,"address":[7968558],"length":1,"stats":{"Line":0}},{"line":59,"address":[8472402,8472465],"length":1,"stats":{"Line":0}},{"line":60,"address":[7968693],"length":1,"stats":{"Line":0}},{"line":64,"address":[8472581],"length":1,"stats":{"Line":0}},{"line":65,"address":[8472630],"length":1,"stats":{"Line":0}},{"line":72,"address":[8472864],"length":1,"stats":{"Line":0}},{"line":73,"address":[7969077],"length":1,"stats":{"Line":0}},{"line":77,"address":[8472880],"length":1,"stats":{"Line":0}},{"line":78,"address":[8472893],"length":1,"stats":{"Line":0}},{"line":83,"address":[8472912],"length":1,"stats":{"Line":0}},{"line":84,"address":[8472917],"length":1,"stats":{"Line":0}},{"line":89,"address":[8472928],"length":1,"stats":{"Line":0}},{"line":90,"address":[8472936],"length":1,"stats":{"Line":0}},{"line":95,"address":[8472960],"length":1,"stats":{"Line":0}},{"line":96,"address":[8472968],"length":1,"stats":{"Line":0}},{"line":100,"address":[8473008],"length":1,"stats":{"Line":0}},{"line":101,"address":[8473032],"length":1,"stats":{"Line":0}},{"line":102,"address":[8473018],"length":1,"stats":{"Line":0}},{"line":106,"address":[8473056],"length":1,"stats":{"Line":0}},{"line":107,"address":[8473080],"length":1,"stats":{"Line":0}},{"line":108,"address":[8473066],"length":1,"stats":{"Line":0}},{"line":112,"address":[8473104,8475048],"length":1,"stats":{"Line":0}},{"line":113,"address":[8473155],"length":1,"stats":{"Line":0}},{"line":116,"address":[8473262],"length":1,"stats":{"Line":0}},{"line":117,"address":[8473316],"length":1,"stats":{"Line":0}},{"line":118,"address":[8473303],"length":1,"stats":{"Line":0}},{"line":121,"address":[8473374],"length":1,"stats":{"Line":0}},{"line":122,"address":[8473835,8473984,8473418,8474072,8473641],"length":1,"stats":{"Line":0}},{"line":124,"address":[8473430],"length":1,"stats":{"Line":0}},{"line":126,"address":[8473570],"length":1,"stats":{"Line":0}},{"line":128,"address":[8473705],"length":1,"stats":{"Line":0}},{"line":131,"address":[8474102],"length":1,"stats":{"Line":0}},{"line":132,"address":[8474130],"length":1,"stats":{"Line":0}},{"line":134,"address":[8474150],"length":1,"stats":{"Line":0}},{"line":135,"address":[8474192],"length":1,"stats":{"Line":0}},{"line":136,"address":[8474234],"length":1,"stats":{"Line":0}},{"line":137,"address":[8474276],"length":1,"stats":{"Line":0}},{"line":139,"address":[8477430,8477056],"length":1,"stats":{"Line":0}},{"line":140,"address":[7967228],"length":1,"stats":{"Line":0}},{"line":144,"address":[8477145],"length":1,"stats":{"Line":0}},{"line":145,"address":[8477167],"length":1,"stats":{"Line":0}},{"line":146,"address":[7967371],"length":1,"stats":{"Line":0}},{"line":147,"address":[8477185],"length":1,"stats":{"Line":0}},{"line":148,"address":[8477207],"length":1,"stats":{"Line":0}},{"line":150,"address":[7967466],"length":1,"stats":{"Line":0}},{"line":151,"address":[7967470],"length":1,"stats":{"Line":0}},{"line":155,"address":[7967584,7967931],"length":1,"stats":{"Line":0}},{"line":156,"address":[8477484],"length":1,"stats":{"Line":0}},{"line":160,"address":[7967663],"length":1,"stats":{"Line":0}},{"line":161,"address":[8477561],"length":1,"stats":{"Line":0}},{"line":162,"address":[7967753],"length":1,"stats":{"Line":0}},{"line":163,"address":[8477583],"length":1,"stats":{"Line":0}},{"line":164,"address":[7967721],"length":1,"stats":{"Line":0}},{"line":166,"address":[7967848],"length":1,"stats":{"Line":0}},{"line":167,"address":[8477744],"length":1,"stats":{"Line":0}},{"line":172,"address":[8474397],"length":1,"stats":{"Line":0}},{"line":174,"address":[8474561],"length":1,"stats":{"Line":0}},{"line":175,"address":[8474577],"length":1,"stats":{"Line":0}},{"line":177,"address":[8474530],"length":1,"stats":{"Line":0}},{"line":178,"address":[8474546],"length":1,"stats":{"Line":0}},{"line":180,"address":[8474595],"length":1,"stats":{"Line":0}},{"line":181,"address":[8474632],"length":1,"stats":{"Line":0}},{"line":182,"address":[7970687],"length":1,"stats":{"Line":0}},{"line":186,"address":[8474455],"length":1,"stats":{"Line":0}},{"line":187,"address":[7970525],"length":1,"stats":{"Line":0}},{"line":189,"address":[8474495,8474673],"length":1,"stats":{"Line":0}},{"line":190,"address":[8474709],"length":1,"stats":{"Line":0}},{"line":194,"address":[8474886],"length":1,"stats":{"Line":0}},{"line":195,"address":[8474961],"length":1,"stats":{"Line":0}},{"line":196,"address":[8474993],"length":1,"stats":{"Line":0}},{"line":198,"address":[8475025],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","selected_station.rs"],"content":"//! Contains the [`SelectedStation`] struct and all its methods.\n\nuse super::{\n    GridNode,\n    Map,\n    Station,\n    StationID,\n};\nuse crate::{\n    algorithm::{\n        drawing::{\n            draw_edge,\n            CanvasContext,\n        },\n        run_a_star,\n    },\n    components::CanvasState,\n};\n\n/// Holds information about the currently selected [`Station`].\n#[derive(Debug, Clone)]\npub struct SelectedStation {\n    /// The selected station.\n    station: Station,\n    /// The stations before and after the station that was grabbed if\n    /// applicable.\n    before_after: (Vec\u003cStationID\u003e, Vec\u003cStationID\u003e),\n}\n\nimpl SelectedStation {\n    /// Select a station.\n    pub fn new(mut station: Station) -\u003e Self {\n        station.set_is_ghost(true);\n        Self {\n            station,\n            before_after: (Vec::new(), Vec::new()),\n        }\n    }\n\n    /// Select a newly created station.\n    pub fn new_station() -\u003e Self {\n        let mut station = Station::new((i32::MIN, i32::MIN).into(), None);\n        station.set_is_ghost(true);\n        Self {\n            station,\n            before_after: (Vec::new(), Vec::new()),\n        }\n    }\n\n    /// Get the station that is currently selected.\n    pub fn get_station(\u0026self) -\u003e \u0026Station {\n        \u0026self.station\n    }\n\n    /// Get the stations before and after the station that was grabbed.\n    pub fn get_before_after(\u0026self) -\u003e (\u0026[StationID], \u0026[StationID]) {\n        let (before, after) = \u0026self.before_after;\n        (before.as_ref(), after.as_ref())\n    }\n\n    /// Add a station that came before the station that was grabbed.\n    pub fn add_before(\u0026mut self, mut before: Vec\u003cStationID\u003e) {\n        self.before_after\n            .0\n            .append(\u0026mut before);\n    }\n\n    /// Add a station that came after the station that was grabbed.\n    pub fn add_after(\u0026mut self, mut after: Vec\u003cStationID\u003e) {\n        self.before_after\n            .1\n            .append(\u0026mut after);\n    }\n\n    /// Update the current grid position of the station.\n    pub fn update_pos(\u0026mut self, new_pos: GridNode) {\n        self.station\n            .set_pos(new_pos);\n    }\n\n    /// A getter for the current grid position of the station.\n    pub fn get_pos(\u0026self) -\u003e GridNode {\n        self.station\n            .get_pos()\n    }\n\n    /// Deselects the station and returns it.\n    pub fn deselect(mut self) -\u003e Station {\n        self.station\n            .set_is_ghost(false);\n        self.station\n    }\n\n    /// Draw the selected station to the given canvas.\n    pub fn draw(\u0026self, map: \u0026Map, canvas: \u0026CanvasContext\u003c'_\u003e, state: CanvasState) {\n        self.station\n            .draw(canvas, state);\n\n        canvas.set_line_width(3.0);\n        canvas.set_stroke_style_str(\"black\");\n        canvas.set_global_alpha(0.5);\n        canvas.begin_path();\n\n        for before_id in self\n            .get_before_after()\n            .0\n        {\n            let before = map\n                .get_station(*before_id)\n                .expect(\"invalid id\");\n            draw_edge(\n                before.get_pos(),\n                self.station\n                    .get_pos(),\n                \u0026run_a_star(\n                    before.get_pos(),\n                    self.station\n                        .get_pos(),\n                ),\n                canvas,\n                state,\n                0.0,\n            );\n        }\n\n        for after_id in self\n            .get_before_after()\n            .1\n        {\n            let after = map\n                .get_station(*after_id)\n                .expect(\"invalid id\");\n            draw_edge(\n                self.station\n                    .get_pos(),\n                after.get_pos(),\n                \u0026run_a_star(\n                    self.station\n                        .get_pos(),\n                    after.get_pos(),\n                ),\n                canvas,\n                state,\n                0.0,\n            );\n        }\n\n        canvas.stroke();\n    }\n}\n","traces":[{"line":32,"address":[8922793,8922368],"length":1,"stats":{"Line":0}},{"line":33,"address":[8485998],"length":1,"stats":{"Line":0}},{"line":36,"address":[8486197,8486137],"length":1,"stats":{"Line":0}},{"line":41,"address":[8486464,8486995],"length":1,"stats":{"Line":0}},{"line":42,"address":[8486480],"length":1,"stats":{"Line":0}},{"line":43,"address":[8486564],"length":1,"stats":{"Line":0}},{"line":46,"address":[8923071,8923126],"length":1,"stats":{"Line":0}},{"line":51,"address":[8487040],"length":1,"stats":{"Line":0}},{"line":56,"address":[8487056],"length":1,"stats":{"Line":0}},{"line":57,"address":[8487086],"length":1,"stats":{"Line":0}},{"line":58,"address":[8487112],"length":1,"stats":{"Line":0}},{"line":62,"address":[8487261,8487184],"length":1,"stats":{"Line":0}},{"line":63,"address":[8487198],"length":1,"stats":{"Line":0}},{"line":69,"address":[8487280,8487357],"length":1,"stats":{"Line":0}},{"line":70,"address":[8487294],"length":1,"stats":{"Line":0}},{"line":76,"address":[8487376],"length":1,"stats":{"Line":0}},{"line":77,"address":[8487393],"length":1,"stats":{"Line":0}},{"line":82,"address":[8487408],"length":1,"stats":{"Line":0}},{"line":83,"address":[8487413],"length":1,"stats":{"Line":0}},{"line":88,"address":[8923760,8923863],"length":1,"stats":{"Line":0}},{"line":89,"address":[8487449],"length":1,"stats":{"Line":0}},{"line":91,"address":[8487502],"length":1,"stats":{"Line":0}},{"line":95,"address":[8487568,8488671],"length":1,"stats":{"Line":0}},{"line":96,"address":[8923970],"length":1,"stats":{"Line":0}},{"line":99,"address":[8487706],"length":1,"stats":{"Line":0}},{"line":100,"address":[8924046],"length":1,"stats":{"Line":0}},{"line":101,"address":[8487772],"length":1,"stats":{"Line":0}},{"line":102,"address":[8487803],"length":1,"stats":{"Line":0}},{"line":104,"address":[8924276,8924105],"length":1,"stats":{"Line":0}},{"line":108,"address":[8488021],"length":1,"stats":{"Line":0}},{"line":109,"address":[8924292],"length":1,"stats":{"Line":0}},{"line":112,"address":[8488077],"length":1,"stats":{"Line":0}},{"line":113,"address":[8924364],"length":1,"stats":{"Line":0}},{"line":115,"address":[8488155],"length":1,"stats":{"Line":0}},{"line":116,"address":[8924382],"length":1,"stats":{"Line":0}},{"line":117,"address":[8488137],"length":1,"stats":{"Line":0}},{"line":126,"address":[8487937,8488206,8488296],"length":1,"stats":{"Line":0}},{"line":130,"address":[8488315],"length":1,"stats":{"Line":0}},{"line":131,"address":[8924559],"length":1,"stats":{"Line":0}},{"line":134,"address":[8488376],"length":1,"stats":{"Line":0}},{"line":136,"address":[8488394],"length":1,"stats":{"Line":0}},{"line":137,"address":[8488451],"length":1,"stats":{"Line":0}},{"line":138,"address":[8488415],"length":1,"stats":{"Line":0}},{"line":140,"address":[8488433],"length":1,"stats":{"Line":0}},{"line":148,"address":[8488265],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","models","station.rs"],"content":"//! Contains the [`Station`] struct and all its methods.\n\nuse std::{\n    f64,\n    fmt::Display,\n    sync::atomic::{\n        AtomicU64,\n        Ordering,\n    },\n};\n\nuse leptos::logging;\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse super::{\n    EdgeID,\n    GridNode,\n};\nuse crate::{\n    algorithm::drawing::CanvasContext,\n    components::CanvasState,\n    utils::IDManager,\n};\n/// An identifier for a station.\n#[derive(Clone, Debug, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\n#[serde(transparent)]\npub struct StationID(u64);\n\nimpl From\u003cu64\u003e for StationID {\n    fn from(value: u64) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl From\u003cStationID\u003e for u64 {\n    fn from(value: StationID) -\u003e Self {\n        value.0\n    }\n}\n\nimpl Display for StationID {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Represents a metro station, including its grid position on the map, its id,\n/// name and if the station should be greyed out when drawn to the canvas.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct Station {\n    /// Position of the station.\n    pos: GridNode,\n    /// The position of the station when it first was created.\n    original_pos: GridNode,\n    /// ID of the station.\n    id: StationID,\n    /// If when drawn the station should be greyed out (like when moving).\n    is_ghost: bool,\n    /// The station name.\n    name: String,\n    /// The edges that are connected to this station.\n    edges: Vec\u003cEdgeID\u003e,\n    /// Marks the location of the station as locked by the user in the\n    /// algorithm.\n    is_locked: bool,\n    /// Marks the location of the station as settled in the algorithm.\n    is_settled: bool,\n    /// The total cost of all the edges attached to the station, used in the\n    /// local search algorithm.\n    cost: f64,\n}\n\nimpl Station {\n    /// Create a new [`Station`] at the given grid coordinate.\n    /// If id is None, the next sequential id is used.\n    pub fn new(pos: GridNode, id: Option\u003cStationID\u003e) -\u003e Self {\n        if let Some(new_id) = id {\n            IDManager::update_station_id(new_id);\n        }\n\n        Self {\n            pos,\n            original_pos: pos,\n            id: id.unwrap_or_else(IDManager::next_station_id),\n            is_ghost: false,\n            name: String::new(),\n            edges: Vec::new(),\n            is_locked: false,\n            is_settled: false,\n            cost: 0.0,\n        }\n    }\n\n    /// A getter for the id.\n    #[inline]\n    pub fn get_id(\u0026self) -\u003e StationID {\n        self.id\n    }\n\n    /// A getter for the grid position.\n    #[inline]\n    pub fn get_pos(\u0026self) -\u003e GridNode {\n        self.pos\n    }\n\n    /// A setter for if the stations should be greyed out.\n    pub fn set_is_ghost(\u0026mut self, ghost: bool) {\n        self.is_ghost = ghost;\n    }\n\n    /// A setter for the grid position of the station.\n    pub fn set_pos(\u0026mut self, pos: GridNode) {\n        self.pos = pos;\n    }\n\n    /// A getter for the original grid position.\n    #[inline]\n    pub fn get_original_pos(\u0026self) -\u003e GridNode {\n        self.original_pos\n    }\n\n    /// A setter for the original grid position.\n    /// This is used when the station is moved manually.\n    pub fn set_original_pos(\u0026mut self, pos: GridNode) {\n        self.original_pos = pos;\n    }\n\n    /// The location of the station on the canvas, given the size of a grid\n    /// square.\n    pub fn get_canvas_pos(\u0026self, state: CanvasState) -\u003e (f64, f64) {\n        self.get_pos()\n            .to_canvas_pos(state)\n    }\n\n    /// A setter for the name.\n    pub fn set_name(\u0026mut self, name: \u0026impl ToString) {\n        self.name = name.to_string();\n    }\n\n    /// A getter for the name.\n    pub fn get_name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// Lock the position of the station.\n    pub fn lock(\u0026mut self) {\n        self.is_locked = true;\n    }\n\n    /// Unlock the position of the station.\n    pub fn unlock(\u0026mut self) {\n        self.is_locked = false;\n    }\n\n    /// Settle the station onto the given grid node.\n    pub fn settle(\u0026mut self, pos: GridNode) {\n        self.set_pos(pos);\n        self.is_settled = true;\n    }\n\n    /// Unsettle the station.\n    pub fn unsettle(\u0026mut self) {\n        self.is_settled = false;\n    }\n\n    /// Check if the station is settled.\n    #[inline]\n    pub fn is_settled(\u0026self) -\u003e bool {\n        self.is_settled || self.is_locked()\n    }\n\n    /// Check if the station is locked.\n    #[inline]\n    pub fn is_locked(\u0026self) -\u003e bool {\n        self.is_locked\n    }\n\n    /// Get the cost of the station.\n    #[inline]\n    pub fn get_cost(\u0026self) -\u003e f64 {\n        self.cost\n    }\n\n    /// Set the cost of the station.\n    pub fn set_cost(\u0026mut self, cost: f64) {\n        self.cost = cost;\n    }\n\n    /// Add to the cost of the station.\n    pub fn add_cost(\u0026mut self, cost: f64) {\n        self.cost += cost;\n    }\n\n    /// If the given node is a neighboring grid node to the station.\n    pub fn is_neighbor(\u0026self, node: GridNode) -\u003e bool {\n        self.get_pos()\n            .get_neighbors()\n            .contains(\u0026node)\n    }\n\n    /// Add an edge to the station.\n    pub fn add_edge(\u0026mut self, edge: EdgeID) {\n        if self\n            .edges\n            .contains(\u0026edge)\n        {\n            return;\n        }\n\n        self.edges\n            .push(edge);\n    }\n\n    /// Remove an edge from the station.\n    pub fn remove_edge(\u0026mut self, edge: EdgeID) {\n        self.edges\n            .retain(|e| *e != edge);\n    }\n\n    /// Get the edges connected to the station.\n    pub fn get_edges(\u0026self) -\u003e \u0026[EdgeID] {\n        \u0026self.edges\n    }\n\n    /// Clear all edges from the station.\n    pub fn clear_edges(\u0026mut self) {\n        self.edges\n            .clear();\n    }\n\n    #[allow(dead_code)]\n    pub fn print_info(\u0026self) {\n        logging::log!(\n            \"Station: {}({}) at {:?} with edges [{:?}]\",\n            self.get_name(),\n            self.get_id(),\n            self.get_pos(),\n            self.get_edges()\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003cString\u003e\u003e()\n                .join(\", \")\n        );\n    }\n\n    /// Draw the station to the given canvas.\n    pub fn draw(\u0026self, canvas: \u0026CanvasContext\u003c'_\u003e, state: CanvasState) {\n        if !state.is_on_canvas(self.get_pos()) {\n            return;\n        }\n\n        let canvas_pos = self.get_canvas_pos(state);\n\n        let mut width = state.drawn_square_size() / 10.0 + 1.0;\n        if width \u003c 2.0 {\n            width = 2.0;\n        }\n\n        canvas.set_line_width(width);\n        if self.is_ghost {\n            canvas.set_global_alpha(0.5);\n        } else {\n            canvas.set_global_alpha(1.0);\n        }\n        canvas.set_stroke_style_str(\"black\");\n        canvas.begin_path();\n        canvas\n            .arc(\n                canvas_pos.0,\n                canvas_pos.1,\n                state.drawn_square_size() / 3.0,\n                0.0,\n                2.0 * f64::consts::PI,\n            )\n            .unwrap();\n        canvas.stroke();\n\n        if self.is_locked() {\n            canvas.set_stroke_style_str(\"grey\");\n            canvas.begin_path();\n            canvas\n                .arc(\n                    canvas_pos.0 + (state.drawn_square_size() / 4.0),\n                    canvas_pos.1 - (state.drawn_square_size() / 4.0),\n                    state.drawn_square_size() / 3.0 / 5.0,\n                    0.0,\n                    2.0 * f64::consts::PI,\n                )\n                .unwrap();\n            canvas.set_fill_style_str(\"grey\");\n            canvas.fill();\n            canvas.stroke();\n        }\n    }\n}\n\nimpl PartialEq for Station {\n    fn eq(\u0026self, other: \u0026Station) -\u003e bool {\n        other.id == self.id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_station() {\n        let before_id = IDManager::next_station_id();\n\n        let first_station = Station::new((2, 3).into(), None);\n        let second_station = Station::new(\n            (2, 3).into(),\n            Some(StationID(u64::from(before_id) + 5)),\n        );\n\n        let after_id = IDManager::next_station_id();\n\n        assert_eq!(\n            StationID(u64::from(before_id) + 6),\n            after_id\n        );\n        assert_eq!(\n            first_station.get_id(),\n            StationID(u64::from(before_id) + 1)\n        );\n        assert_eq!(\n            second_station.get_id(),\n            StationID(u64::from(before_id) + 5)\n        );\n    }\n}\n","traces":[{"line":33,"address":[10188112],"length":1,"stats":{"Line":1}},{"line":39,"address":[7761328],"length":1,"stats":{"Line":1}},{"line":45,"address":[10188144],"length":1,"stats":{"Line":2}},{"line":46,"address":[10188234],"length":1,"stats":{"Line":2}},{"line":79,"address":[10188304,10188586],"length":1,"stats":{"Line":1}},{"line":80,"address":[10188347],"length":1,"stats":{"Line":1}},{"line":81,"address":[10188365],"length":1,"stats":{"Line":5}},{"line":87,"address":[10188371],"length":1,"stats":{"Line":1}},{"line":89,"address":[10188407],"length":1,"stats":{"Line":4}},{"line":90,"address":[10188412],"length":1,"stats":{"Line":4}},{"line":99,"address":[10188608],"length":1,"stats":{"Line":2}},{"line":100,"address":[10188613],"length":1,"stats":{"Line":3}},{"line":105,"address":[10188624],"length":1,"stats":{"Line":1}},{"line":106,"address":[7761829],"length":1,"stats":{"Line":1}},{"line":110,"address":[10188640],"length":1,"stats":{"Line":0}},{"line":111,"address":[7761857],"length":1,"stats":{"Line":0}},{"line":115,"address":[10188672],"length":1,"stats":{"Line":0}},{"line":116,"address":[10188685],"length":1,"stats":{"Line":0}},{"line":121,"address":[10188704],"length":1,"stats":{"Line":1}},{"line":122,"address":[7761909],"length":1,"stats":{"Line":1}},{"line":127,"address":[7761920],"length":1,"stats":{"Line":0}},{"line":128,"address":[10188733],"length":1,"stats":{"Line":0}},{"line":133,"address":[7761952],"length":1,"stats":{"Line":1}},{"line":134,"address":[10188765],"length":1,"stats":{"Line":1}},{"line":139,"address":[8566467,8566400],"length":1,"stats":{"Line":2}},{"line":140,"address":[8566498,8566424],"length":1,"stats":{"Line":4}},{"line":144,"address":[10188832],"length":1,"stats":{"Line":1}},{"line":145,"address":[10188837],"length":1,"stats":{"Line":1}},{"line":149,"address":[10188848],"length":1,"stats":{"Line":0}},{"line":150,"address":[10188853],"length":1,"stats":{"Line":0}},{"line":154,"address":[10188864],"length":1,"stats":{"Line":0}},{"line":155,"address":[10188869],"length":1,"stats":{"Line":0}},{"line":159,"address":[10188880],"length":1,"stats":{"Line":0}},{"line":160,"address":[7762101],"length":1,"stats":{"Line":0}},{"line":161,"address":[10188911],"length":1,"stats":{"Line":0}},{"line":165,"address":[10188928],"length":1,"stats":{"Line":0}},{"line":166,"address":[10188933],"length":1,"stats":{"Line":0}},{"line":171,"address":[10188944],"length":1,"stats":{"Line":1}},{"line":172,"address":[10188957],"length":1,"stats":{"Line":1}},{"line":177,"address":[10189008],"length":1,"stats":{"Line":1}},{"line":178,"address":[10189013],"length":1,"stats":{"Line":1}},{"line":183,"address":[10189024],"length":1,"stats":{"Line":0}},{"line":184,"address":[10189029],"length":1,"stats":{"Line":0}},{"line":188,"address":[7762240],"length":1,"stats":{"Line":0}},{"line":189,"address":[7762251],"length":1,"stats":{"Line":0}},{"line":193,"address":[7762272],"length":1,"stats":{"Line":0}},{"line":194,"address":[7762283],"length":1,"stats":{"Line":0}},{"line":198,"address":[10189257,10189104],"length":1,"stats":{"Line":1}},{"line":199,"address":[7762321,7762408],"length":1,"stats":{"Line":2}},{"line":205,"address":[10189280],"length":1,"stats":{"Line":1}},{"line":206,"address":[7762482],"length":1,"stats":{"Line":1}},{"line":213,"address":[10189333],"length":1,"stats":{"Line":1}},{"line":218,"address":[10189360],"length":1,"stats":{"Line":1}},{"line":219,"address":[10189374],"length":1,"stats":{"Line":1}},{"line":220,"address":[9376080,9376105],"length":1,"stats":{"Line":2}},{"line":224,"address":[10189408],"length":1,"stats":{"Line":1}},{"line":225,"address":[7762597],"length":1,"stats":{"Line":1}},{"line":229,"address":[10189440],"length":1,"stats":{"Line":0}},{"line":230,"address":[7762613],"length":1,"stats":{"Line":0}},{"line":235,"address":[7762624,7763494],"length":1,"stats":{"Line":0}},{"line":236,"address":[7762999,7763197],"length":1,"stats":{"Line":0}},{"line":250,"address":[10190384],"length":1,"stats":{"Line":0}},{"line":251,"address":[10190416],"length":1,"stats":{"Line":0}},{"line":255,"address":[7763586],"length":1,"stats":{"Line":0}},{"line":257,"address":[7763651],"length":1,"stats":{"Line":0}},{"line":258,"address":[7763745,7763686],"length":1,"stats":{"Line":0}},{"line":259,"address":[7763731],"length":1,"stats":{"Line":0}},{"line":262,"address":[10190574],"length":1,"stats":{"Line":0}},{"line":263,"address":[7763723],"length":1,"stats":{"Line":0}},{"line":264,"address":[10190659],"length":1,"stats":{"Line":0}},{"line":266,"address":[7763752],"length":1,"stats":{"Line":0}},{"line":268,"address":[10190687],"length":1,"stats":{"Line":0}},{"line":269,"address":[10190719],"length":1,"stats":{"Line":0}},{"line":270,"address":[10190793,10190739],"length":1,"stats":{"Line":0}},{"line":274,"address":[7763822],"length":1,"stats":{"Line":0}},{"line":279,"address":[10190969],"length":1,"stats":{"Line":0}},{"line":281,"address":[7764044],"length":1,"stats":{"Line":0}},{"line":282,"address":[10191008],"length":1,"stats":{"Line":0}},{"line":283,"address":[7764085],"length":1,"stats":{"Line":0}},{"line":284,"address":[10191060,10191208],"length":1,"stats":{"Line":0}},{"line":286,"address":[7764095],"length":1,"stats":{"Line":0}},{"line":287,"address":[10191117],"length":1,"stats":{"Line":0}},{"line":288,"address":[10191159],"length":1,"stats":{"Line":0}},{"line":293,"address":[10191381],"length":1,"stats":{"Line":0}},{"line":294,"address":[10191413],"length":1,"stats":{"Line":0}},{"line":295,"address":[10191433],"length":1,"stats":{"Line":0}},{"line":301,"address":[10191472],"length":1,"stats":{"Line":0}},{"line":302,"address":[10191497],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":88},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","error.rs"],"content":"//! Contains the custom [`Error`] type and the [`Result`] type alias.\n\nuse std::{\n    fmt::Display,\n    sync::Arc,\n};\n\nuse leptos::logging;\nuse ordered_float::FloatIsNan;\nuse serde::{\n    de::{\n        value,\n        Error as DeError,\n    },\n    Deserialize,\n    Serialize,\n};\nuse serde_json::Map;\nuse wasm_bindgen::JsValue;\n\n/// A custom error type for the application.\n#[derive(Debug, Clone)]\npub enum Error {\n    Json(Arc\u003cserde_json::Error\u003e),\n    GraphML(quick_xml::DeError),\n    InvalidFloat(FloatIsNan),\n    EarlyAbort,\n    DecodeError(String),\n    Other(String),\n}\n\nimpl Error {\n    /// Creates a new [`Error::DecodeError`] with the given message.\n    pub fn decode_error\u003cT: Display\u003e(e: T) -\u003e Self {\n        Self::DecodeError(e.to_string())\n    }\n\n    /// Creates a new [`Error::Other`] error with the given message.\n    pub fn other\u003cT: Display\u003e(e: T) -\u003e Self {\n        Self::Other(e.to_string())\n    }\n\n    /// Prints the error to the console.\n    pub fn print_error(self) {\n        logging::error!(\"{}\", self);\n    }\n\n    /// Returns the type of the error as a string.\n    fn get_type(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Json(_) =\u003e \"json\",\n            Self::GraphML(_) =\u003e \"graphml\",\n            Self::InvalidFloat(_) =\u003e \"invalid_float\",\n            Self::EarlyAbort =\u003e \"early_abort\",\n            Self::DecodeError(_) =\u003e \"decode_error\",\n            Self::Other(_) =\u003e \"other\",\n        }\n    }\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Json(e) =\u003e write!(f, \"JSON error: {e}\"),\n            Self::GraphML(e) =\u003e write!(f, \"GraphML error: {e}\"),\n            Self::InvalidFloat(e) =\u003e write!(f, \"Invalid float error: {e}\"),\n            Self::EarlyAbort =\u003e {\n                write!(\n                    f,\n                    \"Aborting algorithm early as no possible improvement can be reached.\"\n                )\n            },\n            Self::DecodeError(e) =\u003e write!(f, \"Decode error: {e}\"),\n            Self::Other(e) =\u003e write!(f, \"Other error: {e}\"),\n        }\n    }\n}\n\nimpl From\u003cquick_xml::DeError\u003e for Error {\n    fn from(e: quick_xml::DeError) -\u003e Self {\n        Self::GraphML(e)\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for Error {\n    fn from(e: serde_json::Error) -\u003e Self {\n        Self::Json(Arc::new(e))\n    }\n}\n\nimpl From\u003cFloatIsNan\u003e for Error {\n    fn from(e: FloatIsNan) -\u003e Self {\n        Self::InvalidFloat(e)\n    }\n}\n\nimpl From\u003ccsscolorparser::ParseColorError\u003e for Error {\n    fn from(e: csscolorparser::ParseColorError) -\u003e Self {\n        Self::DecodeError(format!(\"Failed to parse color: {e}\"))\n    }\n}\n\nimpl From\u003cJsValue\u003e for Error {\n    fn from(e: JsValue) -\u003e Self {\n        Self::Other(\n            e.as_string()\n                .unwrap_or_else(|| format!(\"{e:?}\")),\n        )\n    }\n}\n\nimpl std::error::Error for Error {}\n\nimpl PartialEq\u003cError\u003e for Error {\n    fn eq(\u0026self, other: \u0026Error) -\u003e bool {\n        match (self, other) {\n            (Self::Json(e1), Self::Json(e2)) =\u003e e1.to_string() == e2.to_string(),\n            (Self::GraphML(e1), Self::GraphML(e2)) =\u003e e1.to_string() == e2.to_string(),\n            (Self::InvalidFloat(e1), Self::InvalidFloat(e2)) =\u003e e1 == e2,\n            (Self::DecodeError(e1), Self::DecodeError(e2)) | (Self::Other(e1), Self::Other(e2)) =\u003e {\n                e1 == e2\n            },\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl Serialize for Error {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e std::result::Result\u003cS::Ok, S::Error\u003e\n    where\n        S: serde::Serializer,\n    {\n        let mut map = Map::new();\n        map.insert(\n            \"type\".to_owned(),\n            self.get_type()\n                .into(),\n        );\n\n        map.insert(\n            \"data\".to_owned(),\n            match self {\n                Self::Json(e) =\u003e e.to_string(),\n                Self::GraphML(e) =\u003e e.to_string(),\n                Self::InvalidFloat(e) =\u003e e.to_string(),\n                Self::EarlyAbort =\u003e {\n                    self.get_type()\n                        .to_string()\n                },\n                Self::DecodeError(e) | Self::Other(e) =\u003e e.to_string(),\n            }\n            .into(),\n        );\n\n        map.serialize(serializer)\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Error {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e std::result::Result\u003cSelf, D::Error\u003e\n    where\n        D: serde::Deserializer\u003c'de\u003e,\n    {\n        let value = serde_json::Value::deserialize(deserializer)?;\n        let map = value\n            .as_object()\n            .ok_or(D::Error::custom(\n                \"expected object for error\",\n            ))?;\n        match map\n            .get(\"type\")\n            .ok_or(D::Error::custom(\n                \"error object must have type\",\n            ))?\n            .as_str()\n            .ok_or(D::Error::custom(\n                \"error type must be a string\",\n            ))? {\n            \"json\" =\u003e {\n                let e = value\n                    .get(\"data\")\n                    .ok_or(D::Error::custom(\n                        \"json error must have data\",\n                    ))?\n                    .as_str()\n                    .ok_or(D::Error::custom(\n                        \"json error data must be a string\",\n                    ))?;\n                Ok(Self::Json(Arc::new(\n                    serde_json::Error::custom(e),\n                )))\n            },\n            \"graphml\" =\u003e {\n                let e = value\n                    .get(\"data\")\n                    .ok_or(D::Error::custom(\n                        \"graphml error must have data\",\n                    ))?\n                    .as_str()\n                    .ok_or(D::Error::custom(\n                        \"graphml error data must be a string\",\n                    ))?;\n                Ok(Self::GraphML(\n                    quick_xml::DeError::custom(e),\n                ))\n            },\n            \"invalid_float\" =\u003e {\n                let e = value\n                    .get(\"data\")\n                    .ok_or(D::Error::custom(\n                        \"invalid float error must have data\",\n                    ))?\n                    .as_str()\n                    .ok_or(D::Error::custom(\n                        \"invalid float error data must be a string\",\n                    ))?;\n                Ok(Self::InvalidFloat(FloatIsNan))\n            },\n            \"decode_error\" =\u003e {\n                let e = value\n                    .get(\"data\")\n                    .ok_or(D::Error::custom(\n                        \"decode error must have data\",\n                    ))?\n                    .as_str()\n                    .ok_or(D::Error::custom(\n                        \"decode error data must be a string\",\n                    ))?;\n                Ok(Self::DecodeError(e.to_string()))\n            },\n            \"other\" =\u003e {\n                let e = value\n                    .get(\"data\")\n                    .ok_or(D::Error::custom(\n                        \"other error must have data\",\n                    ))?\n                    .as_str()\n                    .ok_or(D::Error::custom(\n                        \"other error data must be a string\",\n                    ))?;\n                Ok(Self::Other(e.to_string()))\n            },\n            \"early_abort\" =\u003e Ok(Self::EarlyAbort),\n            _ =\u003e Err(D::Error::custom(\"unknown error type\")),\n        }\n    }\n}\n\n/// A custom [`Result`] type for the application using the [`Error`] type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n/// Unwraps the given [`Result`] and returns the value if it is `Ok`, otherwise\n/// prints the error and returns without panicing.\n#[macro_export]\nmacro_rules! unwrap_or_return {\n    ($e:expr) =\u003e {\n        match $e {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                $crate::Error::from(e).print_error();\n                return;\n            },\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_error_serde() {\n        let error_json: Result\u003c()\u003e = Err(Error::Json(Arc::new(\n            serde_json::Error::custom(\"test\"),\n        )));\n        let serialized_json = serde_json::to_string(\u0026error_json).unwrap();\n        let deserialized_json = serde_json::from_str(\u0026serialized_json).unwrap();\n        assert_eq!(error_json, deserialized_json);\n\n        let error_graphml = Error::GraphML(quick_xml::DeError::custom(\"test\"));\n        let serialized_graphml = serde_json::to_string(\u0026error_graphml).unwrap();\n        let deserialized_graphml: crate::Error = serde_json::from_str(\u0026serialized_graphml).unwrap();\n        assert_eq!(error_graphml, deserialized_graphml);\n\n        let error_invalid_float = Error::InvalidFloat(FloatIsNan);\n        let serialized_invalid_float = serde_json::to_string(\u0026error_invalid_float).unwrap();\n        let deserialized_invalid_float: crate::Error =\n            serde_json::from_str(\u0026serialized_invalid_float).unwrap();\n        assert_eq!(\n            error_invalid_float,\n            deserialized_invalid_float\n        );\n\n        let error_decode = Error::DecodeError(\"test\".to_string());\n        let serialized_decode = serde_json::to_string(\u0026error_decode).unwrap();\n        let deserialized_decode: crate::Error = serde_json::from_str(\u0026serialized_decode).unwrap();\n        assert_eq!(error_decode, deserialized_decode);\n\n        let error_other: Result\u003ccrate::models::Station\u003e = Err(Error::Other(\"test\".to_string()));\n        let serialized_other = serde_json::to_string(\u0026error_other).unwrap();\n        let deserialized_other = serde_json::from_str(\u0026serialized_other).unwrap();\n        assert_eq!(error_other, deserialized_other);\n    }\n}\n","traces":[{"line":34,"address":[8985496,8985312,8985456,8985431],"length":1,"stats":{"Line":2}},{"line":35,"address":[9150137,9150241,9150088,9150283],"length":1,"stats":{"Line":4}},{"line":39,"address":[8985568,8985608,8985799,8985680],"length":1,"stats":{"Line":3}},{"line":40,"address":[8985643,8985704,8985753,8985601],"length":1,"stats":{"Line":6}},{"line":44,"address":[10211107,10210800],"length":1,"stats":{"Line":0}},{"line":45,"address":[9192579],"length":1,"stats":{"Line":0}},{"line":49,"address":[10211136],"length":1,"stats":{"Line":1}},{"line":50,"address":[10211141],"length":1,"stats":{"Line":1}},{"line":51,"address":[10211187],"length":1,"stats":{"Line":1}},{"line":52,"address":[10211210],"length":1,"stats":{"Line":1}},{"line":53,"address":[10211233],"length":1,"stats":{"Line":1}},{"line":54,"address":[10211256],"length":1,"stats":{"Line":0}},{"line":55,"address":[10211279],"length":1,"stats":{"Line":1}},{"line":56,"address":[10211302],"length":1,"stats":{"Line":1}},{"line":62,"address":[10211344],"length":1,"stats":{"Line":0}},{"line":63,"address":[10211377],"length":1,"stats":{"Line":0}},{"line":64,"address":[10211532,10211428],"length":1,"stats":{"Line":0}},{"line":65,"address":[9193254,9193372],"length":1,"stats":{"Line":0}},{"line":66,"address":[10211937,10211819],"length":1,"stats":{"Line":0}},{"line":68,"address":[10212027],"length":1,"stats":{"Line":0}},{"line":73,"address":[10212082,10212204],"length":1,"stats":{"Line":0}},{"line":74,"address":[10212299,10212421],"length":1,"stats":{"Line":0}},{"line":80,"address":[10212528],"length":1,"stats":{"Line":0}},{"line":81,"address":[9194184],"length":1,"stats":{"Line":0}},{"line":86,"address":[10212560],"length":1,"stats":{"Line":0}},{"line":87,"address":[10212592],"length":1,"stats":{"Line":0}},{"line":92,"address":[10212624],"length":1,"stats":{"Line":0}},{"line":93,"address":[9194275],"length":1,"stats":{"Line":0}},{"line":98,"address":[10212640],"length":1,"stats":{"Line":0}},{"line":99,"address":[10212765,10212878],"length":1,"stats":{"Line":0}},{"line":104,"address":[10212928,10213082],"length":1,"stats":{"Line":0}},{"line":106,"address":[10212955,10212994],"length":1,"stats":{"Line":0}},{"line":107,"address":[8985845,8985930,8985824,8986023],"length":1,"stats":{"Line":0}},{"line":115,"address":[10213622,10213186,10213104],"length":1,"stats":{"Line":1}},{"line":116,"address":[10213188,10214036,10213127],"length":1,"stats":{"Line":3}},{"line":117,"address":[10213394],"length":1,"stats":{"Line":1}},{"line":118,"address":[10213644],"length":1,"stats":{"Line":1}},{"line":119,"address":[10213876],"length":1,"stats":{"Line":1}},{"line":120,"address":[10213935,10214002],"length":1,"stats":{"Line":2}},{"line":121,"address":[10213969],"length":1,"stats":{"Line":1}},{"line":123,"address":[10213384],"length":1,"stats":{"Line":0}},{"line":129,"address":[9150784,9151648,9151676],"length":1,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[9151126],"length":1,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[9151696,9156026],"length":1,"stats":{"Line":1}},{"line":164,"address":[9151886,9151727],"length":1,"stats":{"Line":1}},{"line":165,"address":[9152006,9151851,9152182],"length":1,"stats":{"Line":2}},{"line":167,"address":[9151963],"length":1,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[9152507],"length":1,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[9152673,9152791],"length":1,"stats":{"Line":2}},{"line":180,"address":[9155785,9155559,9155701,9155912,9156011,9152839],"length":1,"stats":{"Line":3}},{"line":182,"address":[9155522],"length":1,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[9155931],"length":1,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[9155264],"length":1,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[9153025,9154828,9154720,9154982,9154548],"length":1,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[9154769],"length":1,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":222,"address":[9153941],"length":1,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":3}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[9153786,9153839],"length":1,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[10035835],"length":1,"stats":{"Line":0}},{"line":258,"address":[9066415],"length":1,"stats":{"Line":0}},{"line":259,"address":[9635512],"length":1,"stats":{"Line":0}},{"line":260,"address":[8886467,8888473,8888376,8888433,8888310,8886991,8887424,8888196,8887185],"length":1,"stats":{"Line":0}}],"covered":65,"coverable":114},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","graphml","decode.rs"],"content":"//! Contains the functions used to decode a [`GraphMlMap`] and all its child\n//! objects into a [`Map`].\n\nuse std::num::ParseIntError;\n\nuse super::graphml_map::{\n    GraphItem,\n    GraphMlMap,\n    Key,\n    Node,\n};\nuse crate::{\n    components::CanvasState,\n    models::{\n        GridNode,\n        Line,\n        Map,\n        Station,\n    },\n    utils::{\n        parsing::{\n            normalize_coords,\n            parse_id,\n        },\n        Error,\n        Result,\n    },\n};\n\n/// Transforms an edge represented by a [`Key`] to a [`Line`].\nfn edge_to_line(edge: \u0026Key) -\u003e Result\u003cLine\u003e {\n    let mut line = Line::new(Some(parse_id(\u0026edge.id).into()));\n    line.set_name(\u0026edge.name);\n    line.set_color((\n        edge.r\n            .as_ref()\n            .ok_or(Error::decode_error(\n                \"missing r color value\",\n            ))\n            .and_then(|r| {\n                r.parse::\u003cu8\u003e()\n                    .map_err(|e: ParseIntError| {\n                        Error::decode_error(format!(\n                            \"Invalid value for r color value: {e}\"\n                        ))\n                    })\n            })?,\n        edge.g\n            .as_ref()\n            .ok_or(Error::decode_error(\n                \"missing g color value\",\n            ))\n            .and_then(|r| {\n                r.parse::\u003cu8\u003e()\n                    .map_err(|e: ParseIntError| {\n                        Error::decode_error(format!(\n                            \"Invalid value for g color value: {e}\"\n                        ))\n                    })\n            })?,\n        edge.b\n            .as_ref()\n            .ok_or(Error::decode_error(\n                \"missing b color value\",\n            ))\n            .and_then(|r| {\n                r.parse::\u003cu8\u003e()\n                    .map_err(|e: ParseIntError| {\n                        Error::decode_error(format!(\n                            \"Invalid value for b color value: {e}\"\n                        ))\n                    })\n            })?,\n    ));\n\n    Ok(line)\n}\n\n/// Get the coordinates of a node from its data.\nfn get_node_coords(node: \u0026Node) -\u003e Result\u003c(f64, f64)\u003e {\n    Ok((\n        node.data\n            .iter()\n            .find(|d| d.key == \"x\")\n            .ok_or(Error::decode_error(\n                \"no x coordinate provided\",\n            ))?\n            .value\n            .parse()\n            .map_err(|_| Error::decode_error(\"x coordinate is invalid\"))?,\n        node.data\n            .iter()\n            .find(|d| d.key == \"y\")\n            .ok_or(Error::decode_error(\n                \"no x coordinate provided\",\n            ))?\n            .value\n            .parse()\n            .map_err(|_| Error::decode_error(\"y coordinate is invalid\"))?,\n    ))\n}\n\n/// Transforms a [`Node`] into a [`Station`].\nfn node_to_station(node: \u0026Node, state: CanvasState) -\u003e Result\u003cStation\u003e {\n    let coords = get_node_coords(node)?;\n    let station_loc = GridNode::from_canvas_pos(coords, state);\n\n    let mut station = Station::new(\n        station_loc,\n        Some(parse_id(\u0026node.id).into()),\n    );\n    station.set_name(\n        \u0026node\n            .data\n            .iter()\n            .find(|d| d.key == \"label\")\n            .ok_or(Error::decode_error(\n                \"no station name provided\",\n            ))?\n            .value\n            .clone(),\n    );\n\n    Ok(station)\n}\n\n/// GraphML sometimes has maps/stations located in weird places (like all x\n/// coordinates being negative or only difference being in the decimals), this\n/// normalizes them so they fit within the canvas as it currently is.\nfn normalize_stations(mut items: Vec\u003cGraphItem\u003e, state: CanvasState) -\u003e Result\u003cVec\u003cGraphItem\u003e\u003e {\n    let mut coords = items\n        .iter()\n        .filter_map(|item| {\n            if let GraphItem::Node(node) = item {\n                Some(get_node_coords(node))\n            } else {\n                None\n            }\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n    coords = normalize_coords(coords, state);\n\n    for (item, (x, y)) in items\n        .iter_mut()\n        .filter(|item| matches!(item, GraphItem::Node(_)))\n        .zip(coords)\n    {\n        if let GraphItem::Node(node) = item {\n            node.data\n                .iter_mut()\n                .find(|d| d.key == \"x\")\n                .ok_or(Error::decode_error(\n                    \"no x coordinate provided\",\n                ))?\n                .value = format!(\"{x}\");\n            node.data\n                .iter_mut()\n                .find(|d| d.key == \"y\")\n                .ok_or(Error::decode_error(\n                    \"no y coordinate provided\",\n                ))?\n                .value = format!(\"{y}\");\n        }\n    }\n\n    Ok(items)\n}\n\n/// Translates the [`GraphMlMap`] to a [`Map`]\npub fn graphml_to_map(mut graph: GraphMlMap, mut state: CanvasState) -\u003e Result\u003cMap\u003e {\n    state.set_zoom_factor(1.0);\n    let mut map = Map::new();\n\n    // First add a Line for every edge defined\n    for key in \u0026graph.key {\n        if key.for_item == \"edge\" {\n            map.add_line(edge_to_line(key)?);\n        }\n    }\n\n    // Ensure the location of the stations is correct\n    graph\n        .graph\n        .content = normalize_stations(\n        graph\n            .graph\n            .content,\n        state,\n    )?;\n\n    // Load in all the stations\n    for item in \u0026graph\n        .graph\n        .content\n    {\n        if let GraphItem::Node(n) = item {\n            map.add_station(node_to_station(n, state)?);\n        }\n    }\n\n    // Check there is no station overlap\n    // FIXME: instead of erroring, it should look for a free spot in its neighbors\n    for station in map.get_stations() {\n        if let Some(other) = map\n            .get_stations()\n            .iter()\n            .filter(|s| s.get_id() != station.get_id())\n            .find(|s| s.get_pos() == station.get_pos())\n        {\n            return Err(Error::decode_error(format!(\n                \"station {}({}) has the same position as another station {}({}) on this map of size {:?} with squares of size {}\",\n                station.get_name(),\n                station.get_id(),\n                other.get_name(),\n                other.get_id(),\n                state.get_size(),\n                state.get_square_size()\n            )));\n        }\n    }\n\n    // Only load all the lines once we have loaded the stations they reference\n    for item in \u0026graph\n        .graph\n        .content\n    {\n        if let GraphItem::Edge(e) = item {\n            for data in \u0026e.data {\n                let mut line = map\n                    .get_mut_line(parse_id(\u0026data.key).into())\n                    .ok_or(Error::decode_error(format!(\n                        \"edge {} referenced non-existant line {}\",\n                        e.id, data.key\n                    )))?\n                    .clone();\n                line.add_station(\n                    \u0026mut map,\n                    parse_id(\u0026e.source).into(),\n                    Some(parse_id(\u0026e.target).into()),\n                    None,\n                );\n                map.add_line(line);\n            }\n        }\n    }\n\n    Ok(map)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::utils::graphml::graphml_map::{\n        Data,\n        Edge,\n        Graph,\n    };\n\n    #[test]\n    fn test_edge_to_line() {\n        let input = Key {\n            id: \"2\".to_owned(),\n            for_item: \"edge\".to_owned(),\n            r: Some(\"30\".to_owned()),\n            g: Some(\"0\".to_owned()),\n            b: Some(\"235\".to_owned()),\n            name: \"test line\".to_owned(),\n        };\n\n        let result = edge_to_line(\u0026input).unwrap();\n\n        let mut example = Line::new(Some(2.into()));\n        example.set_color((30, 0, 235));\n        example.set_name(\u0026\"test line\");\n\n        assert_eq!(result.get_id(), example.get_id());\n        assert_eq!(result.get_color(), example.get_color());\n        assert_eq!(result.get_name(), example.get_name());\n    }\n\n    #[test]\n    fn test_node_to_station() {\n        let node = Node {\n            id: \"2\".to_owned(),\n            data: vec![\n                Data {\n                    key: \"x\".to_owned(),\n                    value: \"120.0\".to_owned(),\n                },\n                Data {\n                    key: \"label\".to_owned(),\n                    value: \"test station\".to_owned(),\n                },\n                Data {\n                    key: \"y\".to_owned(),\n                    value: \"155\".to_owned(),\n                },\n            ],\n        };\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let result = node_to_station(\u0026node, canvas).unwrap();\n\n        let mut example = Station::new((24, 31).into(), Some(2.into()));\n        example.set_name(\u0026\"test station\");\n\n        assert_eq!(result.get_id(), example.get_id());\n        assert_eq!(result.get_pos(), example.get_pos());\n        assert_eq!(result.get_name(), example.get_name());\n    }\n\n    #[test]\n    fn test_normalize_stations() {\n        let items = vec![\n            GraphItem::Node(Node {\n                id: \"n0\".to_owned(),\n                data: vec![\n                    Data {\n                        key: \"x\".to_owned(),\n                        value: \"90\".to_owned(),\n                    },\n                    Data {\n                        key: \"label\".to_owned(),\n                        value: \"test 1\".to_owned(),\n                    },\n                    Data {\n                        key: \"y\".to_owned(),\n                        value: \"200\".to_owned(),\n                    },\n                ],\n            }),\n            GraphItem::Node(Node {\n                id: \"n1\".to_owned(),\n                data: vec![\n                    Data {\n                        key: \"x\".to_owned(),\n                        value: \"150\".to_owned(),\n                    },\n                    Data {\n                        key: \"label\".to_owned(),\n                        value: \"test 2\".to_owned(),\n                    },\n                    Data {\n                        key: \"y\".to_owned(),\n                        value: \"120\".to_owned(),\n                    },\n                ],\n            }),\n            GraphItem::Node(Node {\n                id: \"n2\".to_owned(),\n                data: vec![\n                    Data {\n                        key: \"x\".to_owned(),\n                        value: \"210\".to_owned(),\n                    },\n                    Data {\n                        key: \"label\".to_owned(),\n                        value: \"test 3\".to_owned(),\n                    },\n                    Data {\n                        key: \"y\".to_owned(),\n                        value: \"100\".to_owned(),\n                    },\n                ],\n            }),\n            GraphItem::Edge(Edge {\n                id: \"e0\".to_owned(),\n                source: \"n0\".to_owned(),\n                target: \"n1\".to_owned(),\n                data: vec![Data {\n                    key: \"l0\".to_owned(),\n                    value: \"true\".to_owned(),\n                }],\n            }),\n            GraphItem::Edge(Edge {\n                id: \"e1\".to_owned(),\n                source: \"n1\".to_owned(),\n                target: \"n2\".to_owned(),\n                data: vec![Data {\n                    key: \"l0\".to_owned(),\n                    value: \"true\".to_owned(),\n                }],\n            }),\n        ];\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let result = normalize_stations(items, canvas).unwrap();\n\n        if let GraphItem::Node(node) = \u0026result[0] {\n            assert_eq!(\n                get_node_coords(\u0026node),\n                Ok((10.0, 290.0))\n            );\n        }\n        if let GraphItem::Node(node) = \u0026result[1] {\n            assert_eq!(\n                get_node_coords(\u0026node),\n                Ok((150.0, 66.0))\n            );\n        }\n        if let GraphItem::Node(node) = \u0026result[2] {\n            assert_eq!(\n                get_node_coords(\u0026node),\n                Ok((290.0, 10.0))\n            );\n        }\n    }\n\n    #[test]\n    fn test_graphml_to_map() {\n        let graphml = GraphMlMap {\n            key: vec![\n                Key {\n                    id: \"x\".to_owned(),\n                    for_item: \"node\".to_owned(),\n                    name: \"x coordinate\".to_owned(),\n                    r: None,\n                    g: None,\n                    b: None,\n                },\n                Key {\n                    id: \"x\".to_owned(),\n                    for_item: \"node\".to_owned(),\n                    name: \"x coordinate\".to_owned(),\n                    r: None,\n                    g: None,\n                    b: None,\n                },\n                Key {\n                    id: \"x\".to_owned(),\n                    for_item: \"node\".to_owned(),\n                    name: \"x coordinate\".to_owned(),\n                    r: None,\n                    g: None,\n                    b: None,\n                },\n                Key {\n                    id: \"l0\".to_owned(),\n                    for_item: \"edge\".to_owned(),\n                    name: \"lineU1\".to_owned(),\n                    r: Some(\"84\".to_owned()),\n                    g: Some(\"167\".to_owned()),\n                    b: Some(\"33\".to_owned()),\n                },\n            ],\n            graph: Graph {\n                content: vec![\n                    GraphItem::Node(Node {\n                        id: \"n0\".to_owned(),\n                        data: vec![\n                            Data {\n                                key: \"x\".to_owned(),\n                                value: \"90\".to_owned(),\n                            },\n                            Data {\n                                key: \"label\".to_owned(),\n                                value: \"test 1\".to_owned(),\n                            },\n                            Data {\n                                key: \"y\".to_owned(),\n                                value: \"155\".to_owned(),\n                            },\n                        ],\n                    }),\n                    GraphItem::Node(Node {\n                        id: \"n1\".to_owned(),\n                        data: vec![\n                            Data {\n                                key: \"x\".to_owned(),\n                                value: \"150\".to_owned(),\n                            },\n                            Data {\n                                key: \"label\".to_owned(),\n                                value: \"test 2\".to_owned(),\n                            },\n                            Data {\n                                key: \"y\".to_owned(),\n                                value: \"126\".to_owned(),\n                            },\n                        ],\n                    }),\n                    GraphItem::Node(Node {\n                        id: \"n2\".to_owned(),\n                        data: vec![\n                            Data {\n                                key: \"x\".to_owned(),\n                                value: \"210\".to_owned(),\n                            },\n                            Data {\n                                key: \"label\".to_owned(),\n                                value: \"test 3\".to_owned(),\n                            },\n                            Data {\n                                key: \"y\".to_owned(),\n                                value: \"100\".to_owned(),\n                            },\n                        ],\n                    }),\n                    GraphItem::Edge(Edge {\n                        id: \"e0\".to_owned(),\n                        source: \"n0\".to_owned(),\n                        target: \"n1\".to_owned(),\n                        data: vec![Data {\n                            key: \"l0\".to_owned(),\n                            value: \"true\".to_owned(),\n                        }],\n                    }),\n                    GraphItem::Edge(Edge {\n                        id: \"e1\".to_owned(),\n                        source: \"n1\".to_owned(),\n                        target: \"n2\".to_owned(),\n                        data: vec![Data {\n                            key: \"l0\".to_owned(),\n                            value: \"true\".to_owned(),\n                        }],\n                    }),\n                ],\n            },\n        };\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let map = graphml_to_map(graphml, canvas).unwrap();\n\n        let result_line = map\n            .get_line(0.into())\n            .expect(\"no line with id 0\");\n        assert_eq!(result_line.get_color(), (84, 167, 33));\n        assert_eq!(result_line.get_name(), \"lineU1\");\n\n        let result_station = map\n            .get_station(1.into())\n            .expect(\"no station with id 1\");\n        assert_eq!(result_station.get_pos(), (30, 28));\n        assert_eq!(result_station.get_name(), \"test 2\");\n    }\n}\n","traces":[{"line":31,"address":[9868634,9867424],"length":1,"stats":{"Line":1}},{"line":32,"address":[9523094],"length":1,"stats":{"Line":1}},{"line":33,"address":[9867562],"length":1,"stats":{"Line":1}},{"line":34,"address":[9868373],"length":1,"stats":{"Line":1}},{"line":35,"address":[9867897,9868632,9867679,9867623],"length":1,"stats":{"Line":2}},{"line":37,"address":[9867643],"length":1,"stats":{"Line":1}},{"line":40,"address":[9952816],"length":1,"stats":{"Line":1}},{"line":41,"address":[9952846],"length":1,"stats":{"Line":1}},{"line":42,"address":[9952896],"length":1,"stats":{"Line":0}},{"line":43,"address":[9953020,9953121],"length":1,"stats":{"Line":0}},{"line":48,"address":[9868180,9867808,9868630,9867962],"length":1,"stats":{"Line":3}},{"line":50,"address":[9867926],"length":1,"stats":{"Line":2}},{"line":53,"address":[9953152],"length":1,"stats":{"Line":2}},{"line":54,"address":[9953182],"length":1,"stats":{"Line":2}},{"line":55,"address":[9953232],"length":1,"stats":{"Line":0}},{"line":56,"address":[10191692,10191793],"length":1,"stats":{"Line":0}},{"line":61,"address":[9868615,9868245,9868091,9868530],"length":1,"stats":{"Line":4}},{"line":63,"address":[9868209],"length":1,"stats":{"Line":2}},{"line":66,"address":[9953488],"length":1,"stats":{"Line":2}},{"line":67,"address":[10191854],"length":1,"stats":{"Line":2}},{"line":68,"address":[9953568],"length":1,"stats":{"Line":0}},{"line":69,"address":[9953692,9953793],"length":1,"stats":{"Line":0}},{"line":76,"address":[9868556],"length":1,"stats":{"Line":2}},{"line":80,"address":[9868656],"length":1,"stats":{"Line":1}},{"line":81,"address":[9869448],"length":1,"stats":{"Line":1}},{"line":82,"address":[9868986,9869227,9868694,9868782],"length":1,"stats":{"Line":2}},{"line":84,"address":[9953824,9953838],"length":1,"stats":{"Line":2}},{"line":85,"address":[9868751],"length":1,"stats":{"Line":1}},{"line":90,"address":[9869199],"length":1,"stats":{"Line":0}},{"line":91,"address":[9869125,9869494,9869037,9869253,9869397],"length":1,"stats":{"Line":3}},{"line":93,"address":[9953936,9953950],"length":1,"stats":{"Line":2}},{"line":94,"address":[9869094],"length":1,"stats":{"Line":1}},{"line":99,"address":[9953984,9954005],"length":1,"stats":{"Line":0}},{"line":104,"address":[9870450,9870475,9869536],"length":1,"stats":{"Line":1}},{"line":105,"address":[9869571,9869869],"length":1,"stats":{"Line":1}},{"line":106,"address":[9869664],"length":1,"stats":{"Line":1}},{"line":110,"address":[9869743],"length":1,"stats":{"Line":1}},{"line":112,"address":[9525804],"length":1,"stats":{"Line":1}},{"line":113,"address":[9870082,9869844,9869977,9870269],"length":1,"stats":{"Line":3}},{"line":116,"address":[9954048,9954062],"length":1,"stats":{"Line":2}},{"line":117,"address":[9870047],"length":1,"stats":{"Line":1}},{"line":124,"address":[9870388],"length":1,"stats":{"Line":1}},{"line":130,"address":[9873597,9870496,9873449],"length":1,"stats":{"Line":1}},{"line":131,"address":[9526137,9526543,9526034,9528958],"length":1,"stats":{"Line":2}},{"line":133,"address":[9954096],"length":1,"stats":{"Line":1}},{"line":134,"address":[9954124,9954197],"length":1,"stats":{"Line":2}},{"line":135,"address":[9954167],"length":1,"stats":{"Line":1}},{"line":137,"address":[9954204],"length":1,"stats":{"Line":1}},{"line":142,"address":[9871157,9870898],"length":1,"stats":{"Line":2}},{"line":144,"address":[9871354,9871553,9871197,9871505],"length":1,"stats":{"Line":5}},{"line":146,"address":[10192528,10192538],"length":1,"stats":{"Line":3}},{"line":147,"address":[9871314],"length":1,"stats":{"Line":1}},{"line":149,"address":[9871764,9871610,9873339],"length":1,"stats":{"Line":4}},{"line":150,"address":[9872401,9872211,9872025,9872104],"length":1,"stats":{"Line":5}},{"line":152,"address":[9954288,9954302],"length":1,"stats":{"Line":3}},{"line":153,"address":[9872175],"length":1,"stats":{"Line":1}},{"line":156,"address":[9873551,9872555,9872050,9872017,9873458,9871891],"length":1,"stats":{"Line":4}},{"line":157,"address":[9872807,9872993,9873182,9872886],"length":1,"stats":{"Line":4}},{"line":159,"address":[10192654,10192640],"length":1,"stats":{"Line":3}},{"line":160,"address":[9872957],"length":1,"stats":{"Line":2}},{"line":163,"address":[9872673,9873344,9873427,9872832,9872799,9873331],"length":1,"stats":{"Line":4}},{"line":167,"address":[9871661],"length":1,"stats":{"Line":2}},{"line":171,"address":[9876520,9878881,9873616],"length":1,"stats":{"Line":1}},{"line":172,"address":[9529026],"length":1,"stats":{"Line":1}},{"line":173,"address":[9529114],"length":1,"stats":{"Line":1}},{"line":176,"address":[9874066,9873865,9873777],"length":1,"stats":{"Line":3}},{"line":177,"address":[9874090,9878459],"length":1,"stats":{"Line":2}},{"line":178,"address":[9878484],"length":1,"stats":{"Line":1}},{"line":183,"address":[9529546],"length":1,"stats":{"Line":2}},{"line":185,"address":[9874059,9874118,9874340,9878447],"length":1,"stats":{"Line":2}},{"line":186,"address":[9529309],"length":1,"stats":{"Line":1}},{"line":189,"address":[9874000],"length":1,"stats":{"Line":1}},{"line":193,"address":[9529820,9529577,9529713],"length":1,"stats":{"Line":3}},{"line":197,"address":[9529844,9533263],"length":1,"stats":{"Line":2}},{"line":198,"address":[9533275],"length":1,"stats":{"Line":1}},{"line":204,"address":[9874789,9874733,9874473,9874563],"length":1,"stats":{"Line":4}},{"line":205,"address":[9874813,9876559,9876642],"length":1,"stats":{"Line":3}},{"line":208,"address":[10192688,10192706],"length":1,"stats":{"Line":2}},{"line":209,"address":[10192768,10192786],"length":1,"stats":{"Line":2}},{"line":211,"address":[9877937,9877736],"length":1,"stats":{"Line":0}},{"line":213,"address":[9876803,9876856],"length":1,"stats":{"Line":0}},{"line":214,"address":[9876990],"length":1,"stats":{"Line":0}},{"line":215,"address":[9877130],"length":1,"stats":{"Line":0}},{"line":216,"address":[9877295],"length":1,"stats":{"Line":0}},{"line":217,"address":[9532644],"length":1,"stats":{"Line":0}},{"line":218,"address":[9877600],"length":1,"stats":{"Line":0}},{"line":224,"address":[9874851,9875050],"length":1,"stats":{"Line":2}},{"line":228,"address":[9875133,9875074],"length":1,"stats":{"Line":2}},{"line":229,"address":[9875141,9876493],"length":1,"stats":{"Line":2}},{"line":230,"address":[9875400,9875969,9875787],"length":1,"stats":{"Line":2}},{"line":231,"address":[9530587],"length":1,"stats":{"Line":1}},{"line":232,"address":[9875752,9875615],"length":1,"stats":{"Line":2}},{"line":237,"address":[9876289],"length":1,"stats":{"Line":1}},{"line":239,"address":[9876098,9876014],"length":1,"stats":{"Line":2}},{"line":240,"address":[9876155],"length":1,"stats":{"Line":1}},{"line":241,"address":[9876277],"length":1,"stats":{"Line":1}},{"line":243,"address":[9876354],"length":1,"stats":{"Line":1}},{"line":248,"address":[9874982],"length":1,"stats":{"Line":1}}],"covered":83,"coverable":98},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","graphml","graphml_map.rs"],"content":"//! Contains all objects that together represent the data in a GraphML file.\n\n// No need to document all fields on the model structs here.\n#![allow(clippy::missing_docs_in_private_items)]\n\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\n/// A key-value pair that contains information about its parent object.\n#[derive(Debug, Deserialize, Serialize)]\npub(super) struct Data {\n    #[serde(rename = \"@key\")]\n    pub(super) key: String,\n    #[serde(rename = \"$text\")]\n    pub(super) value: String,\n}\n\n/// Represents a station in the GraphML.\n#[derive(Debug, Deserialize, Serialize)]\npub(super) struct Node {\n    #[serde(rename = \"@id\")]\n    pub(super) id: String,\n    #[serde(default)]\n    pub(super) data: Vec\u003cData\u003e,\n}\n\n/// Represents an edge connecting two stations as part of a line.\n#[derive(Debug, Deserialize, Serialize)]\npub(super) struct Edge {\n    #[serde(rename = \"@id\")]\n    pub(super) id: String,\n    #[serde(rename = \"@source\")]\n    pub(super) source: String,\n    #[serde(rename = \"@target\")]\n    pub(super) target: String,\n    pub(super) data: Vec\u003cData\u003e,\n}\n\n/// This GraphML object can either be a [`Node`] (station) or [`Edge`] (edge\n/// connecting two stations).\n#[derive(Debug, Deserialize, Serialize)]\n#[serde(rename_all = \"snake_case\")]\npub(super) enum GraphItem {\n    Node(Node),\n    Edge(Edge),\n}\n\n/// The struct containing a list of either [`Edge`] or [`Node`]\n#[derive(Debug, Deserialize, Serialize)]\npub(super) struct Graph {\n    #[serde(rename = \"$value\")]\n    pub(super) content: Vec\u003cGraphItem\u003e,\n}\n\n/// A [`Key`] represents base information about either a line or what\n/// information is available about a station.\n#[derive(Debug, Deserialize, Serialize)]\npub(super) struct Key {\n    #[serde(rename = \"@id\")]\n    pub(super) id: String,\n    #[serde(rename = \"@for\")]\n    pub(super) for_item: String,\n    #[serde(rename = \"@color.r\")]\n    pub(super) r: Option\u003cString\u003e,\n    #[serde(rename = \"@color.g\")]\n    pub(super) g: Option\u003cString\u003e,\n    #[serde(rename = \"@color.b\")]\n    pub(super) b: Option\u003cString\u003e,\n    #[serde(rename = \"@attr.name\")]\n    pub(super) name: String,\n}\n\n/// The root struct that contains the map in a GraphML data file\n#[derive(Debug, Deserialize, Serialize)]\npub struct GraphMlMap {\n    pub(super) graph: Graph,\n    pub(super) key: Vec\u003cKey\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","graphml","mod.rs"],"content":"//! This module provides the capability of decoding valid GraphML data into the\n//! [`Map`] struct used in this project.\n\nuse quick_xml::de::from_str;\n\nmod decode;\nmod graphml_map;\n\nuse decode::graphml_to_map;\nuse graphml_map::GraphMlMap;\n\nuse super::Result;\nuse crate::{\n    components::CanvasState,\n    models::Map,\n};\n\n/// Decode the given GraphML string into a [`Map`] struct.\n/// This decoder also requires the target grid square size to know which station\n/// goes onto which grid node.\npub fn decode_map(input: \u0026str, state: CanvasState) -\u003e Result\u003cMap\u003e {\n    let decoded: GraphMlMap = from_str(input)?;\n\n    graphml_to_map(decoded, state)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decode_map() {\n        let test_file_content = std::fs::read_to_string(\"existing_maps/small_test.graphml\")\n            .expect(\"test data file does not exist\");\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let result = decode_map(\u0026test_file_content, canvas).expect(\"failed to decode graphml\");\n\n        let result_line = result\n            .get_line(0.into())\n            .expect(\"no line with id 0\");\n        assert_eq!(result_line.get_color(), (84, 167, 33));\n        assert_eq!(result_line.get_name(), \"lineU1\");\n\n        let result_station = result\n            .get_station(1.into())\n            .expect(\"no station with id 1\");\n        assert_eq!(result_station.get_pos(), (30, 28));\n        assert_eq!(result_station.get_name(), \"test 2\");\n    }\n}\n","traces":[{"line":21,"address":[9572128,9572551,9572580],"length":1,"stats":{"Line":1}},{"line":22,"address":[9572437,9572166],"length":1,"stats":{"Line":1}},{"line":24,"address":[9572332],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","id_manager.rs"],"content":"//! A module that contains the [`IDManager`] struct and everything else needed\n//! to manage the IDs in a way that works for communication between the main\n//! thread and the web-worker.\n\nuse std::sync::{\n    Arc,\n    Mutex,\n};\n\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\nuse crate::models::{\n    EdgeID,\n    LineID,\n    StationID,\n};\n\n/// A global instance of the [`IDManager`], only accessible through the static\n/// methods of the manager.\nstatic ID_MANAGER: IDManager = IDManager::new();\n\n/// A manager for the ids of stations, lines and edges. This ensures that all\n/// IDs are unique.\n#[derive(Debug)]\npub struct IDManager {\n    /// Holds the ID of the next station.\n    station_id: Mutex\u003cu64\u003e,\n    /// Holds the ID of the next line.\n    line_id: Mutex\u003cu64\u003e,\n    /// Holds the ID of the next edge.\n    edge_id: Mutex\u003cu64\u003e,\n}\n\nimpl IDManager {\n    /// Create a new [`IDManager`] with all ids starting at 1.\n    const fn new() -\u003e Self {\n        Self {\n            station_id: Mutex::new(1),\n            line_id: Mutex::new(1),\n            edge_id: Mutex::new(1),\n        }\n    }\n\n    /// Get the next station id. This is the next sequential id and should\n    /// therefore be unique.\n    pub fn next_station_id() -\u003e StationID {\n        let mut id_lock = ID_MANAGER\n            .station_id\n            .lock()\n            .unwrap();\n        let id = *id_lock;\n        *id_lock += 1;\n        StationID::from(id)\n    }\n\n    /// In the case that a station is created with a specific id, this function\n    /// can be used to ensure the next sequential id is higher than this given\n    /// id.\n    pub fn update_station_id(id: StationID) {\n        let mut id_lock = ID_MANAGER\n            .station_id\n            .lock()\n            .unwrap();\n        if u64::from(id) \u003e= *id_lock {\n            *id_lock = u64::from(id) + 1;\n        }\n    }\n\n    /// Get the next line id. This is the next sequential id and should\n    /// therefore be unique.\n    pub fn next_line_id() -\u003e LineID {\n        let mut id_lock = ID_MANAGER\n            .station_id\n            .lock()\n            .unwrap();\n        let id = *id_lock;\n        *id_lock += 1;\n        LineID::from(id)\n    }\n\n    /// In the case that a line is created with a specific id, this function can\n    /// be used to ensure the next sequential id is higher than this given id.\n    pub fn update_line_id(id: LineID) {\n        let mut id_lock = ID_MANAGER\n            .line_id\n            .lock()\n            .unwrap();\n        if u64::from(id) \u003e= *id_lock {\n            *id_lock = u64::from(id) + 1;\n        }\n    }\n\n    /// Get the next edge id. This is the next sequential id and should\n    /// therefore be unique.\n    pub fn next_edge_id() -\u003e EdgeID {\n        let mut id_lock = ID_MANAGER\n            .station_id\n            .lock()\n            .unwrap();\n        let id = *id_lock;\n        *id_lock += 1;\n        EdgeID::from(id)\n    }\n\n    /// In the case that an edge is created with a specific id, this function\n    /// can be used to ensure the next sequential id is higher than this given\n    /// id.\n    pub fn update_edge_id(id: EdgeID) {\n        let mut id_lock = ID_MANAGER\n            .edge_id\n            .lock()\n            .unwrap();\n        if u64::from(id) \u003e= *id_lock {\n            *id_lock = u64::from(id) + 1;\n        }\n    }\n\n    /// Convert the [`IDManager`] to a serializable struct.\n    pub fn to_data() -\u003e IDData {\n        let station_id = *ID_MANAGER\n            .station_id\n            .lock()\n            .unwrap();\n        let line_id = *ID_MANAGER\n            .line_id\n            .lock()\n            .unwrap();\n        let edge_id = *ID_MANAGER\n            .edge_id\n            .lock()\n            .unwrap();\n\n        IDData {\n            station_id,\n            line_id,\n            edge_id,\n        }\n    }\n\n    /// Update the [`IDManager`] with the data from the serializable struct.\n    pub fn from_data(data: IDData) {\n        Self::update_station_id(\n            data.station_id\n                .into(),\n        );\n        Self::update_line_id(\n            data.line_id\n                .into(),\n        );\n        Self::update_edge_id(\n            data.edge_id\n                .into(),\n        );\n    }\n}\n\n/// A serializable struct that contains the data of the [`IDManager`].\n/// This can be used to save the state of the [`IDManager`] and transfer it\n/// between the main thread and any web-workers.\n#[derive(Debug, Copy, Clone, Deserialize, Serialize)]\npub struct IDData {\n    /// The next station id.\n    station_id: u64,\n    /// The next line id.\n    line_id: u64,\n    /// The next edge id.\n    edge_id: u64,\n}\n","traces":[{"line":39,"address":[9475680],"length":1,"stats":{"Line":0}},{"line":41,"address":[9475694],"length":1,"stats":{"Line":0}},{"line":42,"address":[9475710],"length":1,"stats":{"Line":0}},{"line":43,"address":[9475726],"length":1,"stats":{"Line":0}},{"line":49,"address":[9475824,9476221],"length":1,"stats":{"Line":4}},{"line":50,"address":[9476017,9475831],"length":1,"stats":{"Line":5}},{"line":54,"address":[9476026,9476087],"length":1,"stats":{"Line":2}},{"line":55,"address":[9476100,9476177],"length":1,"stats":{"Line":1}},{"line":56,"address":[9476161],"length":1,"stats":{"Line":1}},{"line":62,"address":[9476673,9476256],"length":1,"stats":{"Line":5}},{"line":63,"address":[9476464,9476273],"length":1,"stats":{"Line":6}},{"line":67,"address":[9476524,9476671,9476473],"length":1,"stats":{"Line":3}},{"line":68,"address":[9476584],"length":1,"stats":{"Line":1}},{"line":74,"address":[9476704,9477101],"length":1,"stats":{"Line":1}},{"line":75,"address":[9476711,9476897],"length":1,"stats":{"Line":3}},{"line":79,"address":[10161734,10161782],"length":1,"stats":{"Line":2}},{"line":80,"address":[9476980,9477057],"length":1,"stats":{"Line":1}},{"line":81,"address":[9477041],"length":1,"stats":{"Line":1}},{"line":86,"address":[9477557,9477136],"length":1,"stats":{"Line":1}},{"line":87,"address":[10162139,10161953],"length":1,"stats":{"Line":2}},{"line":91,"address":[9477555,9477408,9477357],"length":1,"stats":{"Line":3}},{"line":92,"address":[9477468],"length":1,"stats":{"Line":1}},{"line":98,"address":[9477997,9477600],"length":1,"stats":{"Line":1}},{"line":99,"address":[9477607,9477793],"length":1,"stats":{"Line":2}},{"line":103,"address":[10162566,10162614],"length":1,"stats":{"Line":2}},{"line":104,"address":[9477953,9477876],"length":1,"stats":{"Line":1}},{"line":105,"address":[10162684],"length":1,"stats":{"Line":1}},{"line":111,"address":[9478032,9478453],"length":1,"stats":{"Line":0}},{"line":112,"address":[10162971,10162785],"length":1,"stats":{"Line":0}},{"line":116,"address":[9478253,9478304,9478451],"length":1,"stats":{"Line":0}},{"line":117,"address":[9478364],"length":1,"stats":{"Line":0}},{"line":122,"address":[9479505,9478496],"length":1,"stats":{"Line":0}},{"line":123,"address":[9478784,9478513,9478708],"length":1,"stats":{"Line":0}},{"line":126,"address":[9478738,9478800],"length":1,"stats":{"Line":0}},{"line":127,"address":[9479104,9478811,9479028],"length":1,"stats":{"Line":0}},{"line":130,"address":[9479120,9479058],"length":1,"stats":{"Line":0}},{"line":131,"address":[9479348,9479433,9479131],"length":1,"stats":{"Line":0}},{"line":134,"address":[9479387,9479448],"length":1,"stats":{"Line":0}},{"line":144,"address":[9479552],"length":1,"stats":{"Line":0}},{"line":146,"address":[9479557],"length":1,"stats":{"Line":0}},{"line":150,"address":[9479586],"length":1,"stats":{"Line":0}},{"line":154,"address":[9479616],"length":1,"stats":{"Line":0}}],"covered":23,"coverable":42},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","json","decode.rs"],"content":"//! Contains the functions used to decode a [`JSONMap`] and all its child\n//! objects into a [`Map`].\n\nuse super::json_models::{\n    JSONMap,\n    JSONStation,\n};\nuse crate::{\n    components::CanvasState,\n    models::{\n        GridNode,\n        Line,\n        Map,\n        Station,\n    },\n    utils::{\n        parsing::{\n            normalize_coords,\n            parse_color,\n            parse_id,\n        },\n        Error,\n        Result,\n    },\n};\n\n/// JSON data sometimes has maps/stations located in weird places (like all x\n/// coordinates being negative or only difference being in the decimals), this\n/// normalizes them so they fit within the canvas as it currently is.\nfn normalize_stations(mut stations: Vec\u003cJSONStation\u003e, state: CanvasState) -\u003e Vec\u003cJSONStation\u003e {\n    let coords = stations\n        .iter()\n        .map(|s| (s.x, s.y))\n        .collect();\n\n    let normalized_coords = normalize_coords(coords, state);\n\n    for (station, (x, y)) in stations\n        .iter_mut()\n        .zip(normalized_coords)\n    {\n        station.x = x;\n        station.y = y;\n    }\n\n    stations\n}\n\n/// Translates the [`JSONMap`] to a [`Map`]\npub fn json_to_map(mut graph: JSONMap, state: CanvasState) -\u003e Result\u003cMap\u003e {\n    let mut map = Map::new();\n\n    graph.stations = normalize_stations(graph.stations, state);\n\n    // Add stations\n    for json_station in graph\n        .stations\n        .drain(..)\n    {\n        let mut station = Station::new(\n            GridNode::from_canvas_pos((json_station.x, json_station.y), state),\n            Some(parse_id(\u0026json_station.id).into()),\n        );\n\n        if let Some(name) = json_station.name {\n            station.set_name(\u0026name);\n        }\n\n        map.add_station(station);\n    }\n\n    // Check there is no station overlap\n    // FIXME: instead of erroring, it should look for a free spot in its neighbors\n    for station in map.get_stations() {\n        if map\n            .get_stations()\n            .iter()\n            .filter(|s| s.get_id() != station.get_id())\n            .any(|s| s.get_pos() == station.get_pos())\n        {\n            return Err(Error::decode_error(format!(\n                \"station {}({}) has the same position as another station\",\n                station.get_name(),\n                station.get_id()\n            )));\n        }\n    }\n\n    // Add lines\n    for json_line in graph\n        .lines\n        .drain(..)\n    {\n        let mut line = Line::new(Some(parse_id(\u0026json_line.id).into()));\n\n        if let Some(name) = json_line.name {\n            line.set_name(\u0026name);\n        }\n\n        if let Some(color) = json_line.color {\n            line.set_color(parse_color(\u0026color)?);\n        }\n\n        map.add_line(line);\n    }\n\n    // Add edges\n    for json_edge in graph\n        .edges\n        .drain(..)\n    {\n        let edge_id = map.get_edge_id_between(\n            parse_id(\u0026json_edge.source).into(),\n            parse_id(\u0026json_edge.target).into(),\n        );\n\n        // Add edge to lines\n        for line_id in \u0026json_edge.lines {\n            let mut line = map\n                .get_line(parse_id(line_id).into())\n                .ok_or(Error::decode_error(format!(\n                    \"edge references non-existent line {line_id}\",\n                )))?\n                .clone();\n\n            line.add_edge(edge_id, \u0026mut map);\n            map.add_line(line);\n        }\n    }\n\n    Ok(map)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::utils::json::json_models::{\n        JSONEdge,\n        JSONLine,\n    };\n\n    #[test]\n    fn test_normalize_stations() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n        canvas.set_size((100, 100));\n\n        let result = normalize_stations(\n            vec![\n                JSONStation {\n                    id: \"1\".to_string(),\n                    name: None,\n                    x: -1.0,\n                    y: -3.0,\n                },\n                JSONStation {\n                    id: \"2\".to_string(),\n                    name: None,\n                    x: 1.0,\n                    y: 5.0,\n                },\n                JSONStation {\n                    id: \"3\".to_string(),\n                    name: None,\n                    x: 3.0,\n                    y: 1.0,\n                },\n            ],\n            canvas,\n        );\n\n        assert_eq!(\n            result,\n            vec![\n                JSONStation {\n                    id: \"1\".to_string(),\n                    name: None,\n                    x: 10.0,\n                    y: 10.0,\n                },\n                JSONStation {\n                    id: \"2\".to_string(),\n                    name: None,\n                    x: 50.0,\n                    y: 90.0,\n                },\n                JSONStation {\n                    id: \"3\".to_string(),\n                    name: None,\n                    x: 90.0,\n                    y: 50.0,\n                }\n            ]\n        );\n    }\n\n    #[test]\n    fn test_json_to_map() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n        canvas.set_size((100, 100));\n\n        let result = json_to_map(\n            JSONMap {\n                stations: vec![\n                    JSONStation {\n                        id: \"0\".to_string(),\n                        name: None,\n                        x: -1.0,\n                        y: -3.0,\n                    },\n                    JSONStation {\n                        id: \"1\".to_string(),\n                        name: Some(\"test 2\".to_string()),\n                        x: 1.0,\n                        y: 5.0,\n                    },\n                    JSONStation {\n                        id: \"s3\".to_string(),\n                        name: None,\n                        x: 3.0,\n                        y: 1.0,\n                    },\n                ],\n                lines: vec![JSONLine {\n                    id: \"0\".to_string(),\n                    name: Some(\"lineU1\".to_string()),\n                    color: Some(\"rgb(84, 167, 33)\".to_string()),\n                }],\n                edges: vec![\n                    JSONEdge {\n                        source: \"0\".to_string(),\n                        target: \"1\".to_string(),\n                        lines: vec![\"0\".to_string()],\n                    },\n                    JSONEdge {\n                        source: \"1\".to_string(),\n                        target: \"s3\".to_string(),\n                        lines: vec![\"0\".to_string()],\n                    },\n                ],\n            },\n            canvas,\n        )\n        .unwrap();\n\n        assert_eq!(\n            result\n                .get_stations()\n                .len(),\n            3\n        );\n        assert_eq!(\n            result\n                .get_lines()\n                .len(),\n            1\n        );\n        assert_eq!(\n            result\n                .get_edges()\n                .len(),\n            2\n        );\n\n        let mut edges = result\n            .get_edges()\n            .iter()\n            .map(|e| e.get_id())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        edges.sort();\n\n        let result_line = result\n            .get_line(0.into())\n            .expect(\"no line with id 0\");\n        let mut line_edges = result_line\n            .get_edges()\n            .to_vec();\n        line_edges.sort();\n\n        assert_eq!(result_line.get_color(), (84, 167, 33));\n        assert_eq!(result_line.get_name(), \"lineU1\");\n        assert_eq!(line_edges, edges);\n\n        let result_station = result\n            .get_station(1.into())\n            .expect(\"no station with id 1\");\n        assert_eq!(result_station.get_pos(), (10, 18));\n        assert_eq!(result_station.get_name(), \"test 2\");\n    }\n}\n","traces":[{"line":30,"address":[9284381,9283616,9284350],"length":1,"stats":{"Line":2}},{"line":31,"address":[9283731,9283651],"length":1,"stats":{"Line":4}},{"line":33,"address":[10069466,10069456],"length":1,"stats":{"Line":4}},{"line":36,"address":[9283814],"length":1,"stats":{"Line":2}},{"line":38,"address":[9283962,9284182,9284292,9284230,9284031,9283890],"length":1,"stats":{"Line":12}},{"line":40,"address":[9283991],"length":1,"stats":{"Line":2}},{"line":42,"address":[9284282],"length":1,"stats":{"Line":2}},{"line":43,"address":[9284287],"length":1,"stats":{"Line":2}},{"line":46,"address":[9284312],"length":1,"stats":{"Line":2}},{"line":50,"address":[9291069,9287478,9284400],"length":1,"stats":{"Line":2}},{"line":51,"address":[9284439],"length":1,"stats":{"Line":2}},{"line":53,"address":[9284579,9284728],"length":1,"stats":{"Line":3}},{"line":56,"address":[9284759,9284902,9284967,9290847],"length":1,"stats":{"Line":16}},{"line":61,"address":[9285039],"length":1,"stats":{"Line":3}},{"line":62,"address":[9290224],"length":1,"stats":{"Line":5}},{"line":65,"address":[9522359],"length":1,"stats":{"Line":5}},{"line":66,"address":[9290440],"length":1,"stats":{"Line":4}},{"line":69,"address":[9290470],"length":1,"stats":{"Line":1}},{"line":74,"address":[9285128,9285381,9285325],"length":1,"stats":{"Line":15}},{"line":75,"address":[9517625,9521402,9521469],"length":1,"stats":{"Line":13}},{"line":78,"address":[10069506,10069488],"length":1,"stats":{"Line":8}},{"line":79,"address":[9289380,9289533],"length":1,"stats":{"Line":13}},{"line":81,"address":[9290019,9289882],"length":1,"stats":{"Line":0}},{"line":83,"address":[9289582],"length":1,"stats":{"Line":0}},{"line":84,"address":[9289747],"length":1,"stats":{"Line":0}},{"line":90,"address":[9517774,9521144,9517827,9517643],"length":1,"stats":{"Line":18}},{"line":94,"address":[9285751,9287615],"length":1,"stats":{"Line":8}},{"line":96,"address":[9287729],"length":1,"stats":{"Line":5}},{"line":97,"address":[9519903],"length":1,"stats":{"Line":5}},{"line":100,"address":[9287972,9287831],"length":1,"stats":{"Line":10}},{"line":101,"address":[9520099,9520311],"length":1,"stats":{"Line":10}},{"line":104,"address":[9288040],"length":1,"stats":{"Line":5}},{"line":108,"address":[9518146,9517965,9518096],"length":1,"stats":{"Line":8}},{"line":112,"address":[9286400],"length":1,"stats":{"Line":2}},{"line":113,"address":[9286239,9286074],"length":1,"stats":{"Line":5}},{"line":114,"address":[9286288],"length":1,"stats":{"Line":3}},{"line":118,"address":[9518743,9518586,9519558],"length":1,"stats":{"Line":8}},{"line":119,"address":[9287199,9286724,9287017],"length":1,"stats":{"Line":7}},{"line":120,"address":[9286620],"length":1,"stats":{"Line":3}},{"line":121,"address":[9286861,9286982],"length":1,"stats":{"Line":6}},{"line":126,"address":[9287244],"length":1,"stats":{"Line":3}},{"line":127,"address":[9287312],"length":1,"stats":{"Line":2}},{"line":131,"address":[9286097],"length":1,"stats":{"Line":3}}],"covered":40,"coverable":43},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","json","encode.rs"],"content":"//! Contains the functions used to dencode a [`Map`] into a [`JSONMap`].\n\nuse super::json_models::{\n    JSONEdge,\n    JSONLine,\n    JSONMap,\n    JSONStation,\n};\nuse crate::{\n    components::CanvasState,\n    models::{\n        Edge,\n        Line,\n        Map,\n        Station,\n    },\n};\n\n/// Encodes a [`Station`] as a [`JSONStation`].\nfn encode_station(station: \u0026Station, state: CanvasState) -\u003e JSONStation {\n    let pos = station\n        .get_pos()\n        .to_canvas_pos(state);\n\n    let name = if station\n        .get_name()\n        .is_empty()\n    {\n        None\n    } else {\n        Some(\n            station\n                .get_name()\n                .to_owned(),\n        )\n    };\n\n    JSONStation {\n        id: \"s\".to_owned() + \u0026u64::from(station.get_id()).to_string(),\n        x: pos.0,\n        y: pos.1,\n        name,\n    }\n}\n\n/// Encodes a [`Line`] as a [`JSONLine`].\nfn encode_line(line: \u0026Line) -\u003e JSONLine {\n    let color = if line.get_color() == (0, 0, 0) {\n        None\n    } else {\n        Some(line.get_color()).map(|(r, g, b)| format!(\"#{r:02X}{g:02X}{b:02X}\"))\n    };\n\n    let name = if line\n        .get_name()\n        .is_empty()\n    {\n        None\n    } else {\n        Some(\n            line.get_name()\n                .to_owned(),\n        )\n    };\n\n    JSONLine {\n        id: \"l\".to_owned() + \u0026u64::from(line.get_id()).to_string(),\n        name,\n        color,\n    }\n}\n\n/// Encodes an [`Edge`] as a [`JSONEdge`].\nfn encode_edge(edge: \u0026Edge) -\u003e JSONEdge {\n    let source = \"s\".to_owned() + \u0026u64::from(edge.get_from()).to_string();\n    let target = \"s\".to_owned() + \u0026u64::from(edge.get_to()).to_string();\n\n    #[allow(unused_mut)]\n    let mut lines = edge\n        .get_lines()\n        .iter()\n        .map(|l| \"l\".to_owned() + \u0026u64::from(*l).to_string())\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    // Sort lines in an edge for deterministic output\n    #[cfg(test)]\n    {\n        lines.sort();\n    }\n\n    JSONEdge {\n        source,\n        target,\n        lines,\n    }\n}\n\n/// Translates the [`Map`] to a [`JSONMap`]\npub fn map_to_json(graph: \u0026Map, state: CanvasState) -\u003e JSONMap {\n    let mut json_map = JSONMap {\n        stations: Vec::new(),\n        lines: Vec::new(),\n        edges: Vec::new(),\n    };\n\n    // Add stations\n    json_map.stations = graph\n        .get_stations()\n        .into_iter()\n        .map(|s| encode_station(s, state))\n        .collect();\n\n    // Sort stations for deterministic output\n    #[cfg(test)]\n    {\n        json_map\n            .stations\n            .sort_by_key(|s| {\n                s.id.clone()\n            });\n    }\n\n    // Add lines\n    json_map.lines = graph\n        .get_lines()\n        .into_iter()\n        .map(encode_line)\n        .collect();\n\n    // Sort lines for deterministic output\n    #[cfg(test)]\n    {\n        json_map\n            .lines\n            .sort_by_key(|e| {\n                e.id.clone()\n            });\n    }\n\n    // Add edges\n    json_map.edges = graph\n        .get_edges()\n        .into_iter()\n        .map(encode_edge)\n        .collect();\n\n    // Sort edges for deterministic output\n    #[cfg(test)]\n    {\n        json_map\n            .edges\n            .sort_by_key(|e| {\n                e.source\n                    .clone()\n            });\n    }\n\n    json_map\n}\n","traces":[{"line":20,"address":[9292608,9293359,9293387],"length":1,"stats":{"Line":1}},{"line":21,"address":[9292651],"length":1,"stats":{"Line":1}},{"line":25,"address":[9292833,9292752],"length":1,"stats":{"Line":2}},{"line":29,"address":[9292835],"length":1,"stats":{"Line":0}},{"line":32,"address":[9831800],"length":1,"stats":{"Line":1}},{"line":39,"address":[9293340,9292850,9292923],"length":1,"stats":{"Line":2}},{"line":47,"address":[9294473,9294517,9293408],"length":1,"stats":{"Line":1}},{"line":48,"address":[9293446],"length":1,"stats":{"Line":1}},{"line":49,"address":[9293666],"length":1,"stats":{"Line":0}},{"line":51,"address":[9832561],"length":1,"stats":{"Line":8}},{"line":54,"address":[9293686,9293758,9293823],"length":1,"stats":{"Line":2}},{"line":58,"address":[9293805],"length":1,"stats":{"Line":0}},{"line":61,"address":[9293784,9293843],"length":1,"stats":{"Line":2}},{"line":67,"address":[9293898,9294454,9293974],"length":1,"stats":{"Line":2}},{"line":74,"address":[9295661,9295611,9294544],"length":1,"stats":{"Line":1}},{"line":75,"address":[9295674,9294577],"length":1,"stats":{"Line":1}},{"line":76,"address":[9294935,9295620],"length":1,"stats":{"Line":1}},{"line":79,"address":[9295278],"length":1,"stats":{"Line":1}},{"line":82,"address":[9669376,9669411],"length":1,"stats":{"Line":2}},{"line":99,"address":[9834848,9835877],"length":1,"stats":{"Line":1}},{"line":101,"address":[9295746],"length":1,"stats":{"Line":1}},{"line":102,"address":[9834904],"length":1,"stats":{"Line":1}},{"line":103,"address":[9295820],"length":1,"stats":{"Line":1}},{"line":107,"address":[9835296,9835160,9835100],"length":1,"stats":{"Line":3}},{"line":110,"address":[9669712,9669740],"length":1,"stats":{"Line":2}},{"line":111,"address":[9296160],"length":1,"stats":{"Line":0}},{"line":124,"address":[9296218,9296405],"length":1,"stats":{"Line":2}},{"line":128,"address":[9296373],"length":1,"stats":{"Line":0}},{"line":141,"address":[9296431,9296618],"length":1,"stats":{"Line":2}},{"line":145,"address":[9296586],"length":1,"stats":{"Line":0}},{"line":158,"address":[9296657],"length":1,"stats":{"Line":1}}],"covered":25,"coverable":31},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","json","json_models.rs"],"content":"//! Contains all objects that together represent the [`crate::models::Map`] in\n//! the JSON file.\n\n// No need to document all fields on the model structs here.\n#![allow(clippy::missing_docs_in_private_items)]\n\nuse serde::{\n    Deserialize,\n    Serialize,\n};\n\n/// Represents a connection between two stations for the JSON file.\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\npub struct JSONEdge {\n    pub source: String,\n    pub target: String,\n    pub lines: Vec\u003cString\u003e,\n}\n\n/// Represents a line for the JSON file.\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\npub struct JSONLine {\n    pub id: String,\n    pub name: Option\u003cString\u003e,\n    pub color: Option\u003cString\u003e,\n}\n\n/// Represents a station for the JSON file.\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\npub struct JSONStation {\n    pub id: String,\n    pub name: Option\u003cString\u003e,\n    pub x: f64,\n    pub y: f64,\n}\n\n/// Represents the whole map in the JSON file.\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\npub struct JSONMap {\n    pub stations: Vec\u003cJSONStation\u003e,\n    pub lines: Vec\u003cJSONLine\u003e,\n    pub edges: Vec\u003cJSONEdge\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","json","mod.rs"],"content":"//! This module provides the capability of decoding JSON data into the\n//! [`Map`] struct used in this project and vice versa.\n\nuse serde_json::from_str;\n\nmod decode;\nmod encode;\nmod json_models;\n\nuse decode::json_to_map;\nuse encode::map_to_json;\nuse json_models::JSONMap;\n\nuse super::Result;\nuse crate::{\n    components::CanvasState,\n    models::Map,\n};\n\n/// Decode the given JSON string into a [`Map`] struct.\n/// This decoder also requires the target grid square size to know which station\n/// goes onto which grid node.\npub fn decode_map(input: \u0026str, state: CanvasState) -\u003e Result\u003cMap\u003e {\n    let decoded: JSONMap = from_str(input)?;\n\n    json_to_map(decoded, state)\n}\n\n/// Encode the given [`Map`] into a JSON string.\npub fn encode_map(map: \u0026Map, state: CanvasState) -\u003e Result\u003cString\u003e {\n    let json_map = map_to_json(map, state);\n\n    serde_json::to_string(\u0026json_map).map_err(Into::into)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decode_map() {\n        let test_file_content = std::fs::read_to_string(\"existing_maps/small_test.json\")\n            .expect(\"test data file does not exist\");\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n\n        let result = decode_map(\u0026test_file_content, canvas).expect(\"failed to decode json\");\n\n        let result_line = result\n            .get_line(0.into())\n            .expect(\"no line with id 0\");\n        assert_eq!(result_line.get_color(), (84, 167, 33));\n        assert_eq!(result_line.get_name(), \"lineU1\");\n\n        let result_station = result\n            .get_station(1.into())\n            .expect(\"no station with id 1\");\n        assert_eq!(result_station.get_pos(), (30, 58));\n        assert_eq!(result_station.get_name(), \"test-2\");\n    }\n\n    #[test]\n    fn test_encode_map() {\n        let test_file_content = std::fs::read_to_string(\"existing_maps/small_test.json\")\n            .expect(\"test data file does not exist\");\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n        canvas.set_size((100, 100));\n\n        let map = decode_map(\u0026test_file_content, canvas).expect(\"failed to decode json\");\n        let result = encode_map(\u0026map, canvas).expect(\"failed to encode map\");\n\n        assert_eq!(\n            result,\n            test_file_content\n                .replace(\"\\n\", \"\")\n                .replace(\" \", \"\")\n        );\n    }\n}\n","traces":[{"line":23,"address":[9283366,9283395,9282864],"length":1,"stats":{"Line":2}},{"line":24,"address":[9282902,9283275],"length":1,"stats":{"Line":2}},{"line":26,"address":[9283139],"length":1,"stats":{"Line":2}},{"line":30,"address":[9283408,9283590],"length":1,"stats":{"Line":1}},{"line":31,"address":[9283429],"length":1,"stats":{"Line":1}},{"line":33,"address":[9283492,9283550],"length":1,"stats":{"Line":2}}],"covered":6,"coverable":6},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","mod.rs"],"content":"//! Contains utility functions and structs that can be useful\n//! everywhere else in the project, but may not fit in other modules.\n\nmod error;\npub mod graphml;\nmod id_manager;\npub mod json;\nmod parsing;\n\npub use error::{\n    Error,\n    Result,\n};\npub use id_manager::{\n    IDData,\n    IDManager,\n};\n\n/// Compares two floats to determine if they do not differ more than 1.0.\n/// This can be used to see if two coordinates are for the same pixel on the\n/// canvas.\npub fn equal_pixel(left: f64, right: f64) -\u003e bool {\n    (left - right).abs() \u003c 1.0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_equal_pixel() {\n        assert!(equal_pixel(3.253, 3.0));\n        assert!(equal_pixel(3.0, 3.253));\n        assert!(equal_pixel(3.0, 3.0));\n        assert!(!equal_pixel(4.0, 3.0));\n        assert!(!equal_pixel(4.7, 3.6));\n    }\n}\n","traces":[{"line":22,"address":[9362576],"length":1,"stats":{"Line":1}},{"line":23,"address":[9362592],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","calli","Documents","university","graduation_project","metro-map-editor","src","utils","parsing.rs"],"content":"//! Parsing utilities for the application.\n\nuse std::hash::{\n    DefaultHasher,\n    Hash,\n    Hasher,\n};\n\nuse super::Result;\nuse crate::components::CanvasState;\n\n/// Saved data sometimes has maps/stations located in weird places (like all x\n/// coordinates being negative or only difference being in the decimals), this\n/// normalizes them so they fit within the canvas as it currently is.\npub(super) fn normalize_coords(mut items: Vec\u003c(f64, f64)\u003e, state: CanvasState) -\u003e Vec\u003c(f64, f64)\u003e {\n    let square_size = state.drawn_square_size();\n\n    let size_x = f64::from(\n        state\n            .get_size()\n            .1,\n    ) - 4.0 * square_size;\n    let size_y = f64::from(\n        state\n            .get_size()\n            .0,\n    ) - 4.0 * square_size;\n\n    let mut min_x = f64::MAX;\n    let mut max_x = f64::MIN;\n    let mut min_y = f64::MAX;\n    let mut max_y = f64::MIN;\n\n    for (x, y) in items\n        .iter()\n        .copied()\n    {\n        if min_x \u003e x {\n            min_x = x;\n        }\n        if max_x \u003c x {\n            max_x = x;\n        }\n        if min_y \u003e y {\n            min_y = y;\n        }\n        if max_y \u003c y {\n            max_y = y;\n        }\n    }\n\n    for (x, y) in \u0026mut items {\n        *x = (*x - min_x) / (max_x - min_x) * size_x + 2.0 * square_size;\n        *y = (*y - min_y) / (max_y - min_y) * size_y + 2.0 * square_size;\n    }\n\n    items\n}\n\n/// Parse the given string into an u64 to create an ID from.\npub(super) fn parse_id(given: \u0026str) -\u003e u64 {\n    given\n        .parse()\n        .ok()\n        .or_else(|| {\n            given\n                .get(1..)\n                .and_then(|i| {\n                    i.parse()\n                        .ok()\n                })\n        })\n        .unwrap_or_else(|| {\n            let mut hasher = DefaultHasher::new();\n            given.hash(\u0026mut hasher);\n            hasher.finish()\n        })\n}\n\n/// Parses the given string into a rgb color.\npub fn parse_color(given: \u0026str) -\u003e Result\u003c(u8, u8, u8)\u003e {\n    let color = csscolorparser::parse(given)?.to_rgba8();\n\n    Ok((color[0], color[1], color[2]))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_normalize_coords() {\n        let mut canvas = CanvasState::new();\n        canvas.set_square_size(5);\n        canvas.set_size((100, 100));\n\n        let result = normalize_coords(\n            vec![(-1.0, -3.0), (1.0, 1.0), (3.0, 5.0)],\n            canvas,\n        );\n\n        assert_eq!(\n            result,\n            vec![(10.0, 10.0), (50.0, 50.0), (90.0, 90.0)]\n        );\n    }\n\n    #[test]\n    fn test_parse_id() {\n        assert_eq!(parse_id(\"test\"), 14402189752926126668);\n        assert_eq!(parse_id(\"1\"), 1);\n        assert_eq!(parse_id(\"a\"), 8186225505942432243);\n        assert_eq!(parse_id(\"a1\"), 1);\n        assert_eq!(\n            parse_id(\"test\") as f64,\n            14402189752926126668.0\n        );\n    }\n\n    #[test]\n    fn test_parse_color() {\n        assert_eq!(\n            parse_color(\"rgb(255, 0, 0)\").unwrap(),\n            (255, 0, 0)\n        );\n        assert_eq!(\n            parse_color(\"rgb(0, 40, 0)\").unwrap(),\n            (0, 40, 0)\n        );\n        assert_eq!(\n            parse_color(\"rgb(0, 0, 255)\").unwrap(),\n            (0, 0, 255)\n        );\n        assert_eq!(\n            parse_color(\"rgb(255, 255, 255)\").unwrap(),\n            (255, 255, 255)\n        );\n        assert_eq!(\n            parse_color(\"rgb(0, 0, 0)\").unwrap(),\n            (0, 0, 0)\n        );\n        assert_eq!(\n            parse_color(\"#ff0000\").unwrap(),\n            (255, 0, 0)\n        );\n        assert_eq!(\n            parse_color(\"#00ff00\").unwrap(),\n            (0, 255, 0)\n        );\n        assert_eq!(\n            parse_color(\"#0000FF\").unwrap(),\n            (0, 0, 255)\n        );\n    }\n}\n","traces":[{"line":15,"address":[9291088,9292235],"length":1,"stats":{"Line":2}},{"line":16,"address":[9291138,9291219],"length":1,"stats":{"Line":4}},{"line":18,"address":[9291314],"length":1,"stats":{"Line":2}},{"line":19,"address":[9291228],"length":1,"stats":{"Line":2}},{"line":22,"address":[9291310],"length":1,"stats":{"Line":2}},{"line":23,"address":[9291416],"length":1,"stats":{"Line":2}},{"line":24,"address":[9291336],"length":1,"stats":{"Line":2}},{"line":27,"address":[9291412],"length":1,"stats":{"Line":2}},{"line":29,"address":[9291445],"length":1,"stats":{"Line":2}},{"line":30,"address":[9291463],"length":1,"stats":{"Line":2}},{"line":31,"address":[9291471],"length":1,"stats":{"Line":2}},{"line":32,"address":[9291479],"length":1,"stats":{"Line":2}},{"line":34,"address":[9291694,9291487],"length":1,"stats":{"Line":4}},{"line":38,"address":[9291742,9292134],"length":1,"stats":{"Line":4}},{"line":39,"address":[9292125],"length":1,"stats":{"Line":2}},{"line":41,"address":[8183266,8183198],"length":1,"stats":{"Line":4}},{"line":42,"address":[9292165],"length":1,"stats":{"Line":2}},{"line":44,"address":[9292213,9292142],"length":1,"stats":{"Line":4}},{"line":45,"address":[9292204],"length":1,"stats":{"Line":2}},{"line":47,"address":[9292182,9292230],"length":1,"stats":{"Line":4}},{"line":48,"address":[8183313],"length":1,"stats":{"Line":2}},{"line":52,"address":[9291673,9291776,9292095,9291936],"length":1,"stats":{"Line":8}},{"line":53,"address":[9291975],"length":1,"stats":{"Line":2}},{"line":54,"address":[9292034],"length":1,"stats":{"Line":2}},{"line":57,"address":[8182974],"length":1,"stats":{"Line":2}},{"line":61,"address":[9292272],"length":1,"stats":{"Line":1}},{"line":62,"address":[9292302],"length":1,"stats":{"Line":1}},{"line":65,"address":[10184912],"length":1,"stats":{"Line":1}},{"line":66,"address":[10184926],"length":1,"stats":{"Line":1}},{"line":68,"address":[10184976],"length":1,"stats":{"Line":1}},{"line":69,"address":[9371476],"length":1,"stats":{"Line":1}},{"line":73,"address":[10185040],"length":1,"stats":{"Line":1}},{"line":74,"address":[10185053],"length":1,"stats":{"Line":1}},{"line":75,"address":[10185063],"length":1,"stats":{"Line":1}},{"line":76,"address":[10185083],"length":1,"stats":{"Line":1}},{"line":81,"address":[9292384],"length":1,"stats":{"Line":1}},{"line":82,"address":[9292407,9292569],"length":1,"stats":{"Line":1}},{"line":84,"address":[9292518],"length":1,"stats":{"Line":1}}],"covered":38,"coverable":38}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>